<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GAGA – 中间件学习</title>
    <link>http://localhost:1313/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 中间件学习 on GAGA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 29 Jun 2025 00:13:38 +0800</lastBuildDate>
    
	  <atom:link href="http://localhost:1313/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>从 Pod 到 StatefulSet：一文读懂 Kubernetes 核心组件</title>
      <link>http://localhost:1313/post/from-pod-to-statefulset-understanding-kubernetes-core-components-in-one-article-zadm4x.html</link>
      <pubDate>Sun, 29 Jun 2025 00:13:38 +0800</pubDate>
      
      <guid>http://localhost:1313/post/from-pod-to-statefulset-understanding-kubernetes-core-components-in-one-article-zadm4x.html</guid>
      <description>
        
        
        &lt;h1&gt;从 Pod 到 StatefulSet：一文读懂 Kubernetes 核心组件&lt;/h1&gt;&lt;p&gt;刚接触 Kubernetes (K8s) 时，你可能会被其众多的组件和概念搞得眼花缭乱。但别担心，只要理解了其核心设计思想，一切都会变得清晰起来。本文将带你从最基本的计算单元开始，层层递进，逐步揭开 K8s 的神秘面纱。&lt;/p&gt;
&lt;h2&gt;1. Node &amp;amp; Pod：Kubernetes 的基本计算单元&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;1-node--podkubernetes-的基本计算单元&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1-node--podkubernetes-%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%ae%a1%e7%ae%97%e5%8d%95%e5%85%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;Node：集群的基石&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;node集群的基石&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#node%e9%9b%86%e7%be%a4%e7%9a%84%e5%9f%ba%e7%9f%b3&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 K8s 的世界里，&lt;strong&gt;Node&lt;/strong&gt; 是最基础的计算资源。你可以简单地将一个 Node 理解为一台服务器，无论它是物理机还是虚拟机。整个 K8s 集群就是由一个或多个这样的 Node 组成的。&lt;/p&gt;
&lt;h3&gt;Pod：最小的调度单元&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;pod最小的调度单元&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#pod%e6%9c%80%e5%b0%8f%e7%9a%84%e8%b0%83%e5%ba%a6%e5%8d%95%e5%85%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;K8s 并不直接调度单个容器，而是调度一个更高层次的抽象——&lt;strong&gt;Pod&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pod 是 K8s 中最小的部署和调度单元&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一个 Pod 包含一个或多个紧密协作的容器。这些容器共享同一个网络命名空间（即共享同一个 IP 地址和端口空间）、存储卷以及运行配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628214006-z18s8il.png&#34; alt=&#34;Node 与 Pod 的关系&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;虽然一个 Pod 可以运行多个容器，但最佳实践是 &lt;strong&gt;“一个 Pod，一个主容器”&lt;/strong&gt; 。只有当容器之间高度耦合，需要共享资源才能完成特定功能时，才考虑将它们放在同一个 Pod 中。一个典型的例子就是 &lt;strong&gt;Sidecar（边车）模式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Sidecar 模式&lt;/strong&gt;：将一个辅助容器（Sidecar）与主应用容器部署在同一个 Pod 中。Sidecar 负责处理日志收集、监控、网络代理等辅助任务，从而让主应用容器更专注于核心业务逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628214423-s8n3hab.png&#34; alt=&#34;Sidecar 模式示意图&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;2. Service：为 Pod 提供稳定的访问入口&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;2-service为-pod-提供稳定的访问入口&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#2-service%e4%b8%ba-pod-%e6%8f%90%e4%be%9b%e7%a8%b3%e5%ae%9a%e7%9a%84%e8%ae%bf%e9%97%ae%e5%85%a5%e5%8f%a3&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Pod 在创建时会被 K8s 自动分配一个集群内部的 IP 地址。Pod 之间可以通过这个 IP 直接通信。然而，这带来了两个棘手的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;访问性问题&lt;/strong&gt;：Pod 的 IP 是集群内部地址，集群外部无法直接访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性问题&lt;/strong&gt;：Pod 是“脆弱”的。当 Pod 发生故障或进行更新时，K8s 会销毁旧 Pod 并创建新 Pod。新 Pod 的 IP 地址会发生变化，导致依赖旧 IP 的服务调用失败。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了解决这些问题，K8s 引入了 &lt;strong&gt;Service (svc)&lt;/strong&gt;  资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service&lt;/strong&gt; 为一组功能相同的 Pod 提供了一个统一、稳定的访问入口。它拥有一个固定的虚拟 IP（ClusterIP），并将所有发往该 IP 的请求，通过内置的负载均衡机制，智能地转发到其后端健康的 Pod 上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628215514-n0io8bq.png&#34; alt=&#34;Service 封装 Pod&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;即使后端的 Pod 因故障被重建，IP 地址发生了变化，Service 的地址依然保持不变。它会自动发现新的健康 Pod，确保服务不中断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628215719-6s63vvr.png&#34; alt=&#34;Service 自动转发请求&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;3. Ingress：集群的智能流量网关&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;3-ingress集群的智能流量网关&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-ingress%e9%9b%86%e7%be%a4%e7%9a%84%e6%99%ba%e8%83%bd%e6%b5%81%e9%87%8f%e7%bd%91%e5%85%b3&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Service 解决了集群内部的访问问题，但如果想让外部用户访问我们的应用（例如网站前端或 API 接口），又该怎么办呢？&lt;/p&gt;
&lt;p&gt;一种方法是使用 &lt;code&gt;NodePort&lt;/code&gt;​ 类型的 Service，它会在每个 Node 上开放一个指定的端口，并将流量转发到 Service。这样，我们就可以通过 &lt;code&gt;[Node IP]:[NodePort]&lt;/code&gt;​ 来访问服务。&lt;/p&gt;
&lt;p&gt;这种方式在开发测试阶段尚可接受，但在生产环境中，我们更希望通过域名（如 &lt;code&gt;api.example.com&lt;/code&gt;​）来访问服务。这时，&lt;strong&gt;Ingress&lt;/strong&gt; 就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ingress&lt;/strong&gt; 是 K8s 集群的流量入口管理器。它像一个智能的七层（HTTP/HTTPS）网关，可以根据不同的域名或 URL 路径，将外部流量转发到集群内不同的 Service。&lt;/p&gt;
&lt;p&gt;通过 Ingress，我们可以实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;域名路由&lt;/strong&gt;：将 &lt;code&gt;app1.example.com&lt;/code&gt;​ 指向 &lt;code&gt;service-a&lt;/code&gt;​，将 &lt;code&gt;app2.example.com&lt;/code&gt;​ 指向 &lt;code&gt;service-b&lt;/code&gt;​。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;路径路由&lt;/strong&gt;：将 &lt;code&gt;example.com/api&lt;/code&gt;​ 指向 &lt;code&gt;api-service&lt;/code&gt;​，将 &lt;code&gt;example.com/web&lt;/code&gt;​ 指向 &lt;code&gt;web-service&lt;/code&gt;​。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSL/TLS 终止&lt;/strong&gt;：集中管理 HTTPS 证书，为服务提供加密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;：在多个 Service 之间分配流量。&lt;/p&gt;
&lt;p&gt;‍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628223820-1ncd6et.png&#34; alt=&#34;Ingress 流量分发&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;4. ConfigMap &amp;amp; Secret：解耦配置与敏感数据&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;4-configmap--secret解耦配置与敏感数据&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#4-configmap--secret%e8%a7%a3%e8%80%a6%e9%85%8d%e7%bd%ae%e4%b8%8e%e6%95%8f%e6%84%9f%e6%95%b0%e6%8d%ae&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;为了保持应用程序的可移植性，我们应该将&lt;strong&gt;配置信息&lt;/strong&gt;与&lt;strong&gt;应用程序镜像&lt;/strong&gt;分离开。K8s 提供了两种资源来帮助我们实现这一点。&lt;/p&gt;
&lt;h3&gt;ConfigMap：管理普通配置&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;configmap管理普通配置&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#configmap%e7%ae%a1%e7%90%86%e6%99%ae%e9%80%9a%e9%85%8d%e7%bd%ae&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;​&lt;code&gt;ConfigMap&lt;/code&gt;​ 用于存储非敏感的配置数据，如数据库地址、端口号、功能开关等。应用程序可以在运行时动态读取这些配置。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;当配置需要变更时，我们只需修改 &lt;code&gt;ConfigMap&lt;/code&gt;​ 对象并重启 Pod 即可，无需重新构建和部署整个应用程序镜像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Secret：管理敏感信息&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;secret管理敏感信息&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#secret%e7%ae%a1%e7%90%86%e6%95%8f%e6%84%9f%e4%bf%a1%e6%81%af&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;​&lt;code&gt;ConfigMap&lt;/code&gt;​ 中的数据是明文存储的，不适合存放密码、API 密钥等敏感信息。为此，K8s 提供了 &lt;code&gt;Secret&lt;/code&gt;​。&lt;/p&gt;
&lt;p&gt;​&lt;code&gt;Secret&lt;/code&gt;​ 的用途和 &lt;code&gt;ConfigMap&lt;/code&gt;​ 类似，但它是专门为存储敏感数据而设计的。需要注意的是，&lt;code&gt;Secret&lt;/code&gt;​ 默认只对数据进行 Base64 编码，并非强加密。它真正的安全性来自于 K8s 的访问控制（RBAC）和网络策略，确保只有授权的 Pod 才能访问到特定的 &lt;code&gt;Secret&lt;/code&gt;​。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628230455-roq18nq.png&#34; alt=&#34;ConfigMap 与 Secret&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;5. Volume：让容器数据不再“昙花一现”&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;5-volume让容器数据不再昙花一现&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#5-volume%e8%ae%a9%e5%ae%b9%e5%99%a8%e6%95%b0%e6%8d%ae%e4%b8%8d%e5%86%8d%e6%98%99%e8%8a%b1%e4%b8%80%e7%8e%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;容器的文件系统是临时的。当容器被销毁或重启时，其中的数据也会随之丢失。这对于需要持久化数据的应用（如数据库、文件上传服务）是不可接受的。&lt;/p&gt;
&lt;p&gt;K8s 的 &lt;strong&gt;Volume&lt;/strong&gt; 机制解决了这个问题。它允许我们将一个存储卷（Volume）挂载到 Pod 的一个或多个容器中。这个存储卷的生命周期独立于容器，可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点本地磁盘&lt;/strong&gt; (&lt;code&gt;hostPath&lt;/code&gt;​)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;云存储&lt;/strong&gt; (如 AWS EBS, GCE Persistent Disk)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络存储&lt;/strong&gt; (如 NFS, Ceph)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，即使 Pod 被销毁重建，只要新的 Pod 挂载回同一个 Volume，数据就能得以保留。&lt;/p&gt;
&lt;h2&gt;6. Deployment：轻松管理无状态应用&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;6-deployment轻松管理无状态应用&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#6-deployment%e8%bd%bb%e6%9d%be%e7%ae%a1%e7%90%86%e6%97%a0%e7%8a%b6%e6%80%81%e5%ba%94%e7%94%a8&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;单个 Pod 无法保证高可用。如果 Pod 所在的 Node 宕机，或者我们需要对应用进行升级，服务就会中断。&lt;/p&gt;
&lt;p&gt;解决方案很简单：&lt;strong&gt;运行多个副本&lt;/strong&gt;。当一个副本失效时，流量可以无缝切换到其他健康副本上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deployment&lt;/strong&gt; 是 K8s 中用于管理&lt;strong&gt;无状态应用&lt;/strong&gt;（如 Web 服务器、API 网关）的核心控制器。它在 Pod 的基础上增加了一层强大的管理能力：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;副本控制&lt;/strong&gt;：定义并维护指定数量的 Pod 副本。如果某个 Pod 挂了，Deployment 会自动创建一个新的来替代它，始终确保运行的副本数符合预期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滚动更新&lt;/strong&gt;：支持平滑地升级应用版本。它会逐个用新版 Pod 替换旧版 Pod，确保在整个更新过程中服务不中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚操作&lt;/strong&gt;：如果新版本出现问题，可以一键回滚到之前的稳定版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628231940-8wkrdsc.png&#34; alt=&#34;Deployment 管理多个 Pod 副本&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以说，Deployment 是在 Pod 之上的一层抽象，它赋予了我们对应用进行生命周期管理、扩缩容和版本控制的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;7. StatefulSet：有状态应用的守护神&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;7-statefulset有状态应用的守护神&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#7-statefulset%e6%9c%89%e7%8a%b6%e6%80%81%e5%ba%94%e7%94%a8%e7%9a%84%e5%ae%88%e6%8a%a4%e7%a5%9e&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;对于数据库、消息队列这类&lt;strong&gt;有状态应用&lt;/strong&gt;，Deployment 就不太适用了。因为这类应用的每个副本通常不是完全对等的，它们有自己独特的身份和持久化数据。&lt;/p&gt;
&lt;p&gt;例如，一个主从数据库集群，主节点和从节点承担的角色不同，每个节点都有自己独立的数据存储。&lt;/p&gt;
&lt;p&gt;为了管理这类应用，K8s 提供了 &lt;strong&gt;StatefulSet&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StatefulSet&lt;/strong&gt; 和 Deployment 类似，也能管理 Pod 副本。但它为有状态应用提供了额外的保障：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定的网络标识&lt;/strong&gt;：每个 Pod 都有一个固定的、可预测的主机名（如 &lt;code&gt;db-0&lt;/code&gt;​, &lt;code&gt;db-1&lt;/code&gt;​）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定的持久化存储&lt;/strong&gt;：每个 Pod 都关联一个独立的、持久的存储卷。即使 Pod 重启，它也会被重新挂载到原来的存储卷上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序的部署和伸缩&lt;/strong&gt;：Pod 会按照顺序（0, 1, 2&amp;hellip;）创建和销毁，这对于需要依赖启动顺序的集群应用至关重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/image-20250628235851-rho2le5.png&#34; alt=&#34;StatefulSet 管理有状态应用&#34;  loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;总结与思考&lt;span class=&#34;hx:absolute hx:-mt-20&#34; id=&#34;总结与思考&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%80%bb%e7%bb%93%e4%b8%8e%e6%80%9d%e8%80%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我们从最基础的 &lt;strong&gt;Pod&lt;/strong&gt; 和 &lt;strong&gt;Node&lt;/strong&gt; 出发，通过 &lt;strong&gt;Service&lt;/strong&gt; 实现了稳定的服务访问，利用 &lt;strong&gt;Ingress&lt;/strong&gt; 对外暴露服务并进行流量管理。接着，我们用 &lt;strong&gt;ConfigMap&lt;/strong&gt; 和 &lt;strong&gt;Secret&lt;/strong&gt; 解耦了配置，用 &lt;strong&gt;Volume&lt;/strong&gt; 实现了数据持久化。最后，我们学习了如何用 &lt;strong&gt;Deployment&lt;/strong&gt; 管理无状态应用，以及用 &lt;strong&gt;StatefulSet&lt;/strong&gt; 驾驭复杂的有状态应用。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;一个实用的建议&lt;/strong&gt;：StatefulSet 虽然强大，但管理起来也相对复杂。在许多场景下，一种更简单、更通用的做法是将数据库这类核心有状态服务部署在 K8s 集群之外（例如使用云厂商提供的 RDS 服务），让 K8s 专注于管理无状态应用。这可以大大简化集群的架构和维护成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;‍&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
