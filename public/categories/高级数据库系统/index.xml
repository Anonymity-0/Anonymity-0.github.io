<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>高级数据库系统 on </title>
        <link>https://anonymity-0.github.io/categories/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 高级数据库系统 on </description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 11 Jan 2024 05:27:05 +0800</lastBuildDate><atom:link href="https://anonymity-0.github.io/categories/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>第5章 缓冲区管理</title>
        <link>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-buffer-management/</link>
        <pubDate>Thu, 11 Jan 2024 05:27:05 +0800</pubDate>
        
        <guid>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-buffer-management/</guid>
        <description>&lt;h2 id=&#34;缓冲区结构&#34;&gt;缓冲区结构
&lt;/h2&gt;&lt;h3 id=&#34;frame的参数&#34;&gt;frame的参数
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Dirty
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Frame中的块是否已经被修改&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pin-count
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Frame的块的已经被请求并且还未释放的计数，即当前的用户数&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;*Others
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Latch: 是否加锁&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;当请求块时&#34;&gt;当请求块时
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当一个程序请求一个不在内存中的数据块时，操作系统需要从磁盘中读取该数据块。
&lt;ul&gt;
&lt;li&gt;首先，它需要在内存中找到一个帧来存放这个数据块。&lt;/li&gt;
&lt;li&gt;如果选中的帧是&lt;strong&gt;脏的&lt;/strong&gt;（即，&lt;font color=&#34;#ff0000&#34;&gt;帧中的数据已被修改但尚未写回磁盘&lt;/font&gt;），那么操作系统需要先将这个帧的内容写回磁盘。&lt;/li&gt;
&lt;li&gt;然后，操作系统从磁盘中读取请求的数据块，并将其放入选中的帧中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后，操作系统会增加该&lt;strong&gt;帧的固定计数&lt;/strong&gt;Pin-count（即，标记该帧正在被使用），并返回该数据块在内存中的地址。这样，程序就可以直接访问内存中的数据，而不需要再次从磁盘中读取。这个过程是操作系统管理内存的重要部分，也是实现虚拟内存的关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;当释放块时&#34;&gt;当释放块时
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当程序完成对一个数据块的访问后，它需要取消&lt;font color=&#34;#ff0000&#34;&gt;固定（unpin）&lt;/font&gt;包含该数据块的帧，以便操作系统可以在需要时重新使用该帧。&lt;/li&gt;
&lt;li&gt;同时，如果程序修改了数据块的内容，它需要设置该帧的&lt;font color=&#34;#ff0000&#34;&gt;脏位（dirty bit）&lt;/font&gt;。脏位是用来标记帧中的数据是否已被修改，但尚未写回磁盘。如果脏位被设置，那么在帧被替换之前，操作系统需要先将帧的内容写回磁盘。这样可以确保磁盘中的数据始终是最新的，即使发生了系统崩溃或电源故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓冲区替换策略&#34;&gt;缓冲区替换策略
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;当内存中没有空闲的帧来存放新的数据块时，操作系统需要选择一个已经被使用的帧进行替换。选择哪个帧进行替换是由替换策略决定的，常见的替换策略包括最近最少使用（LRU），时钟，先进先出（FIFO），最近最常使用（MRU）等。&lt;/li&gt;
&lt;li&gt;只有当帧的固定计数为0时，也就是说，当没有程序正在使用该帧时，该帧才会被考虑作为替换的候选者。&lt;/li&gt;
&lt;li&gt;替换策略的选择可以对系统的I/O性能产生重大影响，因为每次替换都可能需要从磁盘中读取数据或将数据写回磁盘。不同的访问模式可能会导致某些替换策略比其他策略表现得更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;理论最优算法opt算法&#34;&gt;理论最优算法：OPT算法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;也称为Belady’s算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;理论上最佳的页面置换算法。它每次都置换以后永远也用不到的页面，如果没有则淘汰最久以后再用到的页面。&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;OPT算法必须预先知道全部的页面访问序列，而这在实际DBMS/OS中是无法实现的，因此仅有理论意义&lt;/font&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但OPT算法可以在实验中作为算法性能上界加以对比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lru&#34;&gt;LRU
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;LRU (Oracle, Sybase, Informix)
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;所有frame按照最近一次访问时间排列成一个链表&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;基于时间局部性(Temporal Locality) 假设：&lt;font color=&#34;#ff0000&#34;&gt;越是最近访问的在未来被访问的概率越高. 总是替换LRU端的frame&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pros
&lt;ul&gt;
&lt;li&gt;适用于满足时间局部性的场景（多次重复请求同一页）&lt;/li&gt;
&lt;li&gt;选取frame的时间复杂度是O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cons:
&lt;ul&gt;
&lt;li&gt;缓存污染(Sequentialflooding)：容易出现被频次少的一次连续大量的请求污染,将之前维护的良好的LRU结构都清洗掉了(最大的问题&amp;mdash;by老师)
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;清洗掉&amp;quot;是指低频请求的数据占据了缓存空间，导致原本频繁访问的数据（即LRU结构中的数据）被挤出缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;维护LRU链表代价昂贵：修改链表耗时&lt;/li&gt;
&lt;li&gt;如果访问不满足时间局部性，则性能较差&lt;/li&gt;
&lt;li&gt;只考虑最近一次访问，不考虑访问频率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lru-k&#34;&gt;LRU-K
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LRU不考虑frame的访问频率，不合理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRU-K：如果某个frame的访问次数达到了K次以上，则应当尽量不置换
-&lt;font color=&#34;#245bdb&#34;&gt; 维护2个LRU链表&lt;/font&gt;
- 1个是访问次数小于K次的
- 1个是访问次数K次以上的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;优先按照LRU策略置换小于K次的链表&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;保证高频访问的页能够尽量在buffer中&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;实验表明
&lt;ul&gt;
&lt;li&gt;K并非越大越好，LRU-2 性能较好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点：&lt;font color=&#34;#ff0000&#34;&gt;需要额外记录访问次数&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2q&#34;&gt;2Q
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;与LRU-2类似，不同之处在于访问1次的队列采用FIFO，而不是LRU
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401111003023.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401111005788.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;ul&gt;
&lt;li&gt;这题按照题意，其实说的是2Q的变体，并不是LRU-K，将2Q左边FIFO换成LRU，中间控制阈值改为K
&lt;ul&gt;
&lt;li&gt;根本原因就是：K值只增不减&lt;/li&gt;
&lt;li&gt;策略1：根据负载，动态调整K&lt;/li&gt;
&lt;li&gt;策略2; 引入老化机制，减少右侧队列累计的访问次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实际上LRU-K，按上述情况并不会退化成LRU，而是会退化成一个优先队列
&lt;ul&gt;
&lt;li&gt;LRU-K算法会淘汰那个在所有帧中具有最大向后k距离的帧。向后k距离是指当前时间戳与第k次之前访问的时间戳之间的差值。这意味着，如果一个帧在最近k次访问中没有被访问过，那么它的向后k距离就会很大，因此它有可能被LRU-K算法淘汰。&lt;/li&gt;
&lt;li&gt;如果一个帧的历史访问次数少于k次，那么它的向后k距离被赋予+∞。这意味着，这个帧在最近k次访问中从未被访问过，因此它的向后k距离被视为无穷大。&lt;/li&gt;
&lt;li&gt;当有多个帧的向后k距离都是+∞时，淘汰器会淘汰那个具有最早时间戳的帧。这实际上是FIFO（先进先出）策略的应用。也就是说，当有多个帧都没有在最近k次访问中被访问过时，LRU-K算法会淘汰最早被加载到内存中的帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;second-chance-fifo&#34;&gt;Second-Chance FIFO
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有frame组成FIFO链表，每个frame附加一个bit位，初始为0。当FO页第一次被选中置换时置为1，并移到FI端。只有bit位为1的FO端的页才被选中置换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401111015014.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相当于每个frame给了两次置换机会，避免高频访问但最近一轮没有被访问的frame被置换出buffer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个frame只需要1个额外bit，空间代价很低&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：置换时需要移动多个元素，理论性能比LRU差&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;clock时钟置换算法&#34;&gt;Clock(时钟置换算法)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把Second-Chance FIFO组织成环形&lt;/li&gt;
&lt;li&gt;N个frame组成环形，current指针指向当前frame；每个frame有一个referenced位，初始为1；&lt;/li&gt;
&lt;li&gt;当需要置换页时按顺序执行下面操作:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssd上的置换算法&#34;&gt;SSD上的置换算法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;闪存：读快写慢，写次数有限
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;减少缓存置换中对闪存的写是一个重要指标&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SSD-aware缓存算法
&lt;ul&gt;
&lt;li&gt;CFLRU (CASES’06，CASES’21 Testof Time Award)
&lt;ul&gt;
&lt;li&gt;Clean-first&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LRU-WSR (IEEE Trans CE’08)
&lt;ul&gt;
&lt;li&gt;Clean-first + cold flag&lt;/li&gt;
&lt;li&gt;置换：clean&amp;gt;cold dirty&amp;gt;hot dirty&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AD-LRU (DKE’10)
&lt;ul&gt;
&lt;li&gt;cold LRU list + hot LRU list&lt;/li&gt;
&lt;li&gt;Dynamically adjust two LRUs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Q: 为什么不适用OS缓冲区管理，而需要DBMS？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS经常能预测访问模式(AccessPattern)
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;可以使用更专门的缓冲区替换策略&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;有利于pre-fetch策略的有效使用&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DBMS需要强制写回磁盘能力（如WAL），OS的缓冲写回一般通过记录写请求来实现（来自不同应用），实际的磁盘修改推迟，因此不能保证写顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓冲区管理的实现&#34;&gt;缓冲区管理的实现
&lt;/h2&gt;&lt;p&gt;实验 略&lt;/p&gt;
&lt;h2 id=&#34;习题&#34;&gt;习题
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假 设 我 们 采 ⽤ L R U 作 缓 冲 区 置 换 策 略 ， 当 我 们 向 B u f f e r M a n a g e r 发 出 ⼀ 个 读 页 请 求时 ， 请 讨 论 ⼀ 下 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（ 1 ） 如 果 页 不 在 缓 冲 区 中 ， 我 们 需 要 从 磁 盘 中 读 ⼊ 该 页 。 请 问 如 何 才 能 在 缓 冲 区 不 满 的时 候 快 速 地 返 回 ⼀ 个 f r e e 的 f r a m e ？ 请 给 出 ⾄ 少 两 种 策 略 ， 并 分 析 ⼀ 下 各 ⾃ 的 时 间 复 杂 度 。
&lt;ul&gt;
&lt;li&gt;a.将所有的空闲的frame id插入到一个&lt;strong&gt;链表&lt;/strong&gt;中，每次从链表头部返回一个空闲frame id，时间复杂度为&lt;strong&gt;O(1）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;b. 使用&lt;strong&gt;位图&lt;/strong&gt;，位图的每一位表示一个frame的空闲/占用情况（例如1表示被占用，0表示空闲），需要寻找一个free的frame时，直接扫描位图，找到位图中为0的位置，进而得出其frame id。时间复杂度为&lt;strong&gt;O（n）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;（2）如何才能快速地判断所请求的页是否在缓冲区中？如果请求的页在缓冲区中，如何快速返回该页对应的frame地址？请给出至少两种策略，并分析一下各自的时间复杂度。
&lt;ul&gt;
&lt;li&gt;a.将在缓冲区的的页的page id以及所在的frame的id以&lt;strong&gt;键值对&lt;/strong&gt;的形式（page id內key, frame id为value）存储在一个&lt;strong&gt;哈希表&lt;/strong&gt;中。可以在**O(1)**的时间复杂度下判断所请求的页是否在缓冲区中，若在缓冲区中可以找到键值对，进而返回该页对应的frame地址。&lt;/li&gt;
&lt;li&gt;b.将在缓冲区的的页的page id以及所在的frame的id以&lt;strong&gt;键值对&lt;/strong&gt;的形式（page idkey,frame id为value）存储在一棵&lt;strong&gt;B+-tree&lt;/strong&gt;中，可以在**O(logn)**的时间复杂度下判断所请求的页是否在缓冲区中，若在缓冲区中可以找到键值对，进而返回该页对应的frame地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、我们在讲义上介绍了 SSD感知的 CF-LRU 算法，即 Clean-First LRU 算法。该算法虽然看起来可以减少对SSD 的写操作，但依然存在一些问题。请分析一下该算法的主要缺点有哪些？给出三点，并简要解释你的理由。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CF-LRU算法的基本思想是：把LRU链表分为工作区和替换区，工作区负责维护最近访问的数据页，替换区则负责维护替换候选队列，替换时总是优先替换替换区中的&lt;strong&gt;干净页&lt;/strong&gt;，若替换区没有干净页，则选择LRU链表尾部的第一个脏页作为置换页。在CF-LRU算法中替换区的大小是由窗口大小决定的。CF-LRU通过优先替换出替换区的干净页，在一定程度上可以有效地减少对闪存的写和擦除操作，提升了性能，但还存在一些不足
&lt;ul&gt;
&lt;li&gt;（1）很难确定一个合适窗口大小的值来适应不同类型的负载。&lt;/li&gt;
&lt;li&gt;（2）当链表较长时，查找干净页作为置换页的代价会较高。由于算法在选择置换页时需要沿着链表反向查找干净页，当链表较长时查找代价会增加。&lt;/li&gt;
&lt;li&gt;（3）没有考虑缓冲区页的访问频率，在进行替换操作时，容易保留较老的脏页，而替换热的干净页，这会导致缓冲区命中率的降低。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设一个磁盘块可以存储8条记录或64个“键-指针”对，记录数为n，且记录定长。&lt;/p&gt;
&lt;p&gt;密集索引：在密集索引中，数据库中的每个搜索键值都有一个索引记录1。因此，索引的大小将与记录的数量成正比。如果我们有n条记录，那么我们需要n/8个磁盘块来存储索引（因为每个磁盘块可以存储8个索引项）。加上存储数据本身需要的n/8个磁盘块，总共需要n/4个磁盘块。&lt;/p&gt;
&lt;p&gt;稀疏索引：在稀疏索引中，不会为每个搜索键创建索引记录1。通常，稀疏索引为每个磁盘块的第一个记录建立索引1。因此，如果我们有n条记录，那么我们需要n/64个磁盘块来存储索引（因为每个磁盘块可以存储64个索引项）。加上存储数据本身需要的n/8个磁盘块，总共需要n/64 + n/8个磁盘块。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第4章 数据表达</title>
        <link>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-data-representation/</link>
        <pubDate>Wed, 10 Jan 2024 04:27:05 +0800</pubDate>
        
        <guid>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-data-representation/</guid>
        <description>&lt;h2 id=&#34;数据元素的表示层次&#34;&gt;数据元素的表示层次
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101821632.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据项&#34;&gt;数据项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;字节序列&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;表示关系数据库中元组的属性值&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据项表示的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示什么?
&lt;ul&gt;
&lt;li&gt;姓名&lt;/li&gt;
&lt;li&gt;年龄&lt;/li&gt;
&lt;li&gt;出生日期&lt;/li&gt;
&lt;li&gt;照片  &amp;hellip;..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用什么表示?
&lt;ul&gt;
&lt;li&gt;Bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据项表示方法:SQL数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Integer (short)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 bytes&lt;/li&gt;
&lt;li&gt;例如，35 表示为 &lt;code&gt;00000000 00100011&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Real，Float&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4 bytes (32 bits)&lt;/li&gt;
&lt;li&gt;N bits表示小数，M bits表示指数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Char(n) 或 Character(n) 定长字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小于n时使用特殊填充符&lt;/li&gt;
&lt;li&gt;例如，若属性类型为Char(5)，则属性值’cat’ 表示为&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101826582.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Varchar(n) 变长字符串&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NULL终止符，例 Varchar(5) &lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101827553.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;带长度 &lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101827373.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;定长表示，&lt;font color=&#34;#245bdb&#34;&gt;n+1 bytes &lt;/font&gt;Varchar(4): &lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101827412.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Boolean&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TRUE&lt;/li&gt;
&lt;li&gt;FALSE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;{RED,GREEN,YELLOW}&lt;/li&gt;
&lt;li&gt;整数表示
&lt;ul&gt;
&lt;li&gt;RED ↔ 1，GREEN ↔ 2，YELLOW ↔ 3&lt;/li&gt;
&lt;li&gt;若用两个字节的短整型来表示，则可以表示 216 个不同值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Date&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10字符(SQL92):’YYYY-MM-DD’字符串表示&lt;/li&gt;
&lt;li&gt;8字符:’YYYYMMDD’&lt;/li&gt;
&lt;li&gt;7字符:’YYYYDDD’, NOT ‘&lt;font color=&#34;#ff0000&#34;&gt;YYMMDD&lt;/font&gt;’!&lt;/li&gt;
&lt;li&gt;Integer，自1900-01-01以来的天数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Time&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8字符(SQL92):’HH:NN:SS’ ——整数秒&lt;/li&gt;
&lt;li&gt;Varchar(n):’HH:NN:SS.FF’——带小数秒&lt;/li&gt;
&lt;li&gt;Integer，自00:00:00以来的秒数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带长度的二进制位串&lt;/li&gt;
&lt;li&gt;按字节表示，例如 010111110011&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;类型&lt;/th&gt;
          &lt;th&gt;表示方法&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;整数和实数&lt;/td&gt;
          &lt;td&gt;字符串&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;定长字符&lt;/td&gt;
          &lt;td&gt;n字符的数组&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;变长字符&lt;/td&gt;
          &lt;td&gt;n+1字符&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;VARCHAR(n)&lt;/td&gt;
          &lt;td&gt;长度加内容 |空值-终止字符串&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;日期和时间&lt;/td&gt;
          &lt;td&gt;某种格式定长字符串｜变长值｜整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;二进制位/位字符串&lt;/td&gt;
          &lt;td&gt;长度加内容 ｜字节表示&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;枚举类型&lt;/td&gt;
          &lt;td&gt;使用整数编码表示一个枚举类型的值&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;两种不同的数据项表示
&lt;ul&gt;
&lt;li&gt;定长数据项&lt;/li&gt;
&lt;li&gt;变长数据项
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;带长度 (常用!)&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;Null Terminated&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记录的组织&#34;&gt;记录的组织
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据项 [字段，Fields] 的集合&lt;/li&gt;
&lt;li&gt;E.g.: Employee record: name field,
&lt;ul&gt;
&lt;li&gt;salary field, date-of-hire field, ..&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定格式 vs. 可变格式 Fixed Format vs. Variable Format&lt;/li&gt;
&lt;li&gt;定长 vs. 变长 Fixed Length vs. Variable Length&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定格式定长记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有记录具有相同的逻辑结构(模式)&lt;/li&gt;
&lt;li&gt;记录的模式(Schema)
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;# fields&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Name of each field &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Type of each field &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Order in record &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Offset of each field in the record&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构造
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101841533.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不考虑寻址特点
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101841493.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考虑寻址特点
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;假设记录和字段的开始地址必须按4的倍数对齐&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101842583.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;E.g. 固定格式定长记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101840860.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录首部&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在记录首部(Head)的描述记录的信息
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录类型(模式信息) &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录长度 &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;时间戳 &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;其它信息&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101849469.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可变格式记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个记录的格式不同&lt;/li&gt;
&lt;li&gt;记录的格式存储于记录中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可变格式变长记录表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101850161.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;记录都以“KEY+VALUE”方式表示&lt;/li&gt;
&lt;li&gt;KEY与VALUE都以字节流(byte string)存储， 如下:&lt;code&gt;typedef struct { void *data; //字节流指针 int size; //字节流长度} DBT;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;特点
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;数据类型没有限制 &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;应用与数据库之间不需转换数据格式&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;不提供KEY和VALUE的内容和结构信息&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;应用必须知道所用的VALUE的含义&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此类型数据库
&lt;ul&gt;
&lt;li&gt;BerkeleyDB&lt;/li&gt;
&lt;li&gt;Memcached&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;LevelDB&lt;/li&gt;
&lt;li&gt;RocksDB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;好处
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;灵活的记录格式，适合“松散”记录 &lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽管一个记录可能有大量字段，但某个记录通常只有有限的几个字段&lt;/li&gt;
&lt;li&gt;例如，病人的检验结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;适合处理重复字段&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;适合记录格式演变&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;标记存储方式空间代价高，KV方式难以支持复杂查询、应用负担重而且事务处理等实现困难&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变长记录表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部指针法
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;定长字段在前，变长字段在后 name、address变长&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101855730.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合格式:定长记录+变长记录
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101855429.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记录在块中的组织&#34;&gt;记录在块中的组织
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;块的大小固定&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录组织成单个文件&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101937832.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定长记录的两种块内组织&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录地址rid通常使用&amp;laquo;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;块号，槽号&lt;/font&gt;&amp;gt;表示&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101938606.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变长记录在块内的组织&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101945530.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录在块内的分隔&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定长记录:不需分隔&lt;/li&gt;
&lt;li&gt;使用特殊标记&lt;/li&gt;
&lt;li&gt;通过块内偏移量&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101947897.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨块 vs. 不跨块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Unspanned: 记录必须在一个块中存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101949866.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Spanned:记录可跨块存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101949201.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101949616.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;unspanned:实现简单，但空间浪费 &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;spanned:有效利用空间，实现更复杂&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;But &amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;If record size &amp;gt; block size，MUST be spanned&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同类型的记录聚簇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个块中存储不同类型的记录&lt;/li&gt;
&lt;li&gt;(对于RDB:&lt;font color=&#34;#ff0000&#34;&gt;多关系&lt;/font&gt;上的聚簇)&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101951814.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处——聚簇 (clustering)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;经常一起访问的记录存储在同一块或连续块中&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101952183.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;STUDENT(s#,sname,age) SC(s#,cname,score)&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;Q1: select student.s#,sc.cname from student s,sc where s.s# = sc.s# Q2: select * from student
&lt;ul&gt;
&lt;li&gt;如果Q1经常被查询，则聚簇非常有效&lt;/li&gt;
&lt;li&gt;若Q2经常被查询，则聚簇反而降低了效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在块中按序存储记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;另一种聚簇 (对于RDB:单关系上的聚簇)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;将记录按某个字段顺序排列在块中&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好处&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;加快按排序字段查询记录时的效率 &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;利于归并联接 (will be discussed later)&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101956349.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401101956308.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录的分裂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合于变长记录的混合格式表示 定长部分存储于某个块中&lt;/li&gt;
&lt;li&gt;变长部分存储于另一个块中&lt;/li&gt;
&lt;li&gt;与spanned存储类似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理地址
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102000569.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑地址(间接地址)
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102000378.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;借助文件系统的逻辑块地址
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;文件号+逻辑块地址+块内偏移&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102006078.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;记录的修改&#34;&gt;记录的修改
&lt;/h2&gt;&lt;h3 id=&#34;插入&#34;&gt;插入
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录无序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;插入到任意块的空闲空间中&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;或申请一个新块(当所有块都已满时) &lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录变长时，可使用偏移量表&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102008107.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录有序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;找到记录应该放置的块&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;如果有空间，放入并调节记录顺序即可，否则有两种方法:&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;在“邻近块”中找空间&lt;/li&gt;
&lt;li&gt;创建溢出块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102009531.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;立即回收空间
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;例如，加到可用空间列表中&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除记录时处理溢出块
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;若删除的记录位于溢出块链上，则删除记录后可对整个链进行重新组织以去除溢出块&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用删除标记
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;若使用偏移表，则可以修改偏移表项指针，将其置空&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;若使用逻辑-物理地址映射表，则可以将物理地址置空&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;可以在记录首部预留一开始位:0-未删除，1- 已删除
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102012846.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;块在文件中的组织&#34;&gt;块在文件中的组织
&lt;/h2&gt;&lt;h3 id=&#34;堆文件&#34;&gt;堆文件
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;最基本、最简单的文件结构 &lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录不以任何顺序排序 &lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;记录可能存放在物理不邻接的块上&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入容易，但查找和删除代价高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;链表式堆文件组织&#34;&gt;链表式堆文件组织
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102015384.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;目录式堆文件组织&#34;&gt;目录式堆文件组织
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102015525.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;sql-server的数据存储结构&#34;&gt;SQL Server的数据存储结构
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SQL Server的数据库文件是多个对象的集合，包括多个表、索引等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;页&#34;&gt;页
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在SQL Server中，数据存储的基本单位是页 。在 SQL Server 中，页的大小是 8 KB。
&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102017584.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;扩展盘区&#34;&gt;扩展盘区
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扩展盘区是一种基本单元，可将其中的空间分配给 表和索引。一个扩展盘区是 8 个邻接的页(或 64 KB)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了使空间分配更有效，SQL Server 对只含少量 数据的表不分配完整的扩展盘区。SQL Server 有 两种类型的扩展盘区:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  统一扩展盘区:由单个对象所有，扩展盘区中的所有八页
  只能由拥有该盘区的对象使用。
  混合扩展盘区:最多可由 8 个对象共享。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常从混合扩展盘区中向新表或新索引分配页。当 表或索引增长到 8 页时，就变成统一扩展盘区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102019173.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;sql-server文件组织&#34;&gt;SQL Server文件组织
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQL Server 数据库有三种类型的文件:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要数据文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要数据文件是数据库的起点，指向数据库中文件的其它部分。 每个数据库都有一个主要数据文件。主要数据文件的推荐文件扩 展名是 &lt;strong&gt;.mdf&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;次要数据文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;次要数据文件包含除主要数据文件外的所有数据文件。有些数据 库可能没有次要数据文件，而有些数据库则有多个次要数据文件 。次要数据文件的推荐文件扩展名是 &lt;strong&gt;.ndf&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志文件包含恢复数据库所需的所有日志信息。每个数据库必须 至少有一个日志文件，但可以不止一个。日志文件的推荐文件扩展名是** .ldf**。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据文件的页按顺序编号，文件首页的页码 是 0。每个文件都有一个文件 ID 号。在数 据库中唯一标识一页需要同时使用文件 ID 和页码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102021458.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据文件的起始结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102022109.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;PFS页:给对象分配了扩展盘区后，SQL Server 使用&lt;font color=&#34;#ff0000&#34;&gt;页可用空间 (PFS) &lt;/font&gt;页记录扩展盘区的哪些页 已分配或可用，以及有多少可用的剩余空间。每 个 PFS 页包含大约 8,000 页。PFS 对每一页都 有一个1B的位图，该位图记录这一页是空的、1- 50% 已满、51-80% 已满、81-95% 已满还 是 96-100% 已满。&lt;/li&gt;
&lt;li&gt;GAM页:&lt;font color=&#34;#ff0000&#34;&gt;全局分配映射表 (GAM) &lt;/font&gt;页记录已分配 的扩展盘区。每个 GAM 包含 64,000 个扩展盘 区，将近 4 GB 的数据。GAM 对所涵盖区间内 的每个扩展盘区都有一位。如果这个位是 1，则 扩展盘区可用;如果这个位是 0，则扩展盘区已 分配&lt;/li&gt;
&lt;li&gt;SGAM 页:&lt;font color=&#34;#ff0000&#34;&gt;共享全局分配映射表 (SGAM)页&lt;/font&gt;记录特定的扩展盘区，这些盘区当前用作混合扩展盘区而且至少有一个未使用的页。每个 SGAM 包含 64,000 个扩展盘区。SGAM 对所涵盖区间内的 每个扩展盘区都有一位。如果这个位是 1，则该 扩展盘区就用作混合扩展盘区且有可用的页;如 果这个位是 0，则该扩展盘区不用作混合扩展盘 区，或者虽然用作混合扩展盘区但其所有页都正 在使用中。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102024790.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;若要分配统一扩展盘区，SQL Server 在 GAM 中搜索是 1 的 位，然后将它设成 0。&lt;/li&gt;
&lt;li&gt;若要查找有可用页的混合扩展盘区，SQL Server 在 SGAM 中 搜索是 1 的位。&lt;/li&gt;
&lt;li&gt;若要分配混合扩展盘区，SQL Server 在 GAM 中搜索是 1 的 位，并将它设置为 0，然后将 SGAM 中相应的位也设置为 1。&lt;/li&gt;
&lt;li&gt;若要释放扩展盘区，SQL Server 应确保 GAM 位设置为 1 而 且 SGAM 位设置为 0。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表(Table)的组织&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102026170.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表的组织&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102026640.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401102026515.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;li&gt;当 需要插入新行而当前页没有可用空间时，SQL Server 使用 IAM 页查找分配给对象的扩展盘区 。对于每个扩展盘区，SQL Server 搜索 PFS 页 以查看是否有一页具有足够的空间容纳这一行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>第3章 数据存储</title>
        <link>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link>
        <pubDate>Wed, 10 Jan 2024 03:27:05 +0800</pubDate>
        
        <guid>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid>
        <description>&lt;h2 id=&#34;典型磁盘结构&#34;&gt;典型磁盘结构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239172.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;盘片platter, 盘面 surface, 磁头 R/W head, 磁道 track, 柱面
cylinder, 扇区 sector&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;磁盘块存取时间&#34;&gt;磁盘块存取时间
&lt;/h2&gt;&lt;h3 id=&#34;相关计算概念&#34;&gt;相关计算概念
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;块（Block）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS或DBMS进行磁盘数据存取的最小逻辑单元，由若干连续扇区构成&lt;/li&gt;
&lt;li&gt;块是DBMS中数据存取的最小单元&lt;/li&gt;
&lt;li&gt;扇区是磁盘中数据存储的最小单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读块时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从“发出块存取请求”到“块位于主存”的时间&lt;/li&gt;
&lt;li&gt;读块时间＝&lt;font color=&#34;#ff0000&#34;&gt;寻道时间S＋旋转延迟R＋传输时间T＋其它延迟&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寻道时间（Seek Time）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁头定位到所要的柱面所花费的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均寻道时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239197.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转延迟(Rotation Latency)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘转动到块的第一个扇区到达磁头所需的时间&lt;/li&gt;
&lt;li&gt;平均时间为旋转1/2周所费的时间&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;一个7200RPM的磁盘 平均旋转延迟 R≈4.17 ms&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传输延迟(Transfer Time)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块的扇区及其间隙旋转通过磁头所需的时间&lt;/li&gt;
&lt;li&gt;如果磁道大约有100 000字节，约10ms转一周，则每秒可从磁盘读取约10M字节，一个4K字节的块传输时间小于0.5ms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;其它延迟&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU请求I/O的时间 (CPU time to issueI/O)&lt;/li&gt;
&lt;li&gt;争用磁盘控制器时间 (Contention for controller)&lt;/li&gt;
&lt;li&gt;争用总线和主存的时间 (Contention forbus, memory)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如何读下一块？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CASE 1：下一块在同一柱面上
&lt;ul&gt;
&lt;li&gt;Sequential I/O&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;旋转延迟＋传输时间＋其它（忽略）&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CASE 2：不在一个柱面上
&lt;ul&gt;
&lt;li&gt;Random I/O&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;寻道＋旋转＋传输＋其它&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;写块&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与读块类似&lt;/li&gt;
&lt;li&gt;如果需要校验块是否正确写入，则需要加上一次旋转时间和一次块传输时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;块修改&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将块读入主存&lt;/li&gt;
&lt;li&gt;在主存中完成修改&lt;/li&gt;
&lt;li&gt;将块重新写入磁盘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;块地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理设备号&lt;/li&gt;
&lt;li&gt;柱面号&lt;/li&gt;
&lt;li&gt;盘面号（或磁头号）&lt;/li&gt;
&lt;li&gt;扇区号&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;磁盘例子-megatron747计算磁盘块存取时间&#34;&gt;磁盘例子: Megatron747计算磁盘块存取时间
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数
3.5 inch
3840 RPM
8 surfaces
8192 tracks/surface
256 sectors/track
512 bytes/sector&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Megatron 747大小 = 8*8192*256*512 = 233 = 8 GB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寻道时间 (最大)：17.4 ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;磁头启动停止1 ms，每移动500个柱面需1ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 block ＝ 4 KB ＝ 8 sectors&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;块之间的间隙占块的10%大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每磁道大小=(256/8)*4 KB=128KB=32块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每柱面大小=8*128KB=1 MB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3840 RPM → 1/64 秒/转 = 15.625 ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取一个磁道时间=15.625 ms, 其中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于磁道数据的时间=15.625 * 0.9=14.0625 ms&lt;/li&gt;
&lt;li&gt;用于扇区间隙的时间=15.625*0.1=1.5625 ms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取一个块的时间=15.625/32－1.5625/256 ≈0.482 ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取数据的时间=15.625/32 * 0.9 ≈ 0.439 ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OS或DBMS随机读取一块的最大时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;T=S＋R＋T&lt;/font&gt;=17.4 + 15.625 + 0.482 ≈ 33. 507 ms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最小时间：0.482 ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;T=S＋R＋T=6.5 + 7.8125 + 0.482 ≈ 14.8 ms&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;平均寻道数＝8192/3＝2730 (see Fig.13.9)1＋2730/500 = 6.5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例题&#34;&gt;例题
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239210.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239217.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239226.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239232.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;磁盘存取优化&#34;&gt;磁盘存取优化
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;按柱面组织数据
&lt;ul&gt;
&lt;li&gt;减少平均寻道时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘调度算法
&lt;ul&gt;
&lt;li&gt;如电梯算法 (Elevator Algorithm)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;磁盘阵列(Disk Arrays)&lt;/li&gt;
&lt;li&gt;磁盘镜像(Disk Mirrors)&lt;/li&gt;
&lt;li&gt;Random IO to Sequential IO&lt;/li&gt;
&lt;li&gt;预取(Pre-fetch)和缓冲(Buffering)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;random-io-to-sequential-io&#34;&gt;Random IO to Sequential IO
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;随机I/O（Random I/O）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：随机I/O 是指以随机的顺序访问数据的方式，即不按照存储介质上的物理顺序进行读取或写入。在随机I/O 中，数据块的访问顺序不是连续的，可能是分散的。&lt;/p&gt;
&lt;p&gt;特点：随机I/O 通常需要更多的时间和资源，因为存储设备不能有效地预取下一个数据块，而需要在不同位置之间移动磁头或访问不同的存储块。随机I/O 对于小型数据集或需要随机查找的操作比较常见。&lt;/p&gt;
&lt;p&gt;示例：从数据库表中随机读取特定记录，访问随机分布的文件块，或执行随机的内存访问操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序I/O（Sequential I/O）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：顺序I/O 是指按顺序访问数据的方式，通常从存储介质中按照顺序读取或写入数据。这种访问模式通常涉及连续的数据块，一次读取或写入一个数据块，然后按照顺序移动到下一个数据块。&lt;/p&gt;
&lt;p&gt;特点：顺序I/O 是按照数据的物理存储顺序来操作的。这意味着数据块的读取或写入通常是高效的，因为存储设备可以预取（预读取）下一个数据块，以提高性能。顺序I/O 对于大型文件和数据集的扫描操作非常高效。&lt;/p&gt;
&lt;p&gt;示例：顺序读取或写入文件的内容，如逐行读取文本文件，逐个扇区地写入磁盘，以及顺序扫描数据库表中的记录等。&lt;/p&gt;
&lt;p&gt;在数据库中，我们经常会遇到两种类型的输入/输出（IO）操作：随机IO和顺序IO¹²³⁵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随机IO&lt;/strong&gt;是指读写操作的访问地址不连续，随机分布在磁盘的地址空间中³。在数据库中，索引访问就是典型的随机读IO¹。例如，当我们需要查找特定的行时，由于I/O的粒度是页级的，其中大部分可能是浪费的⁵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序IO&lt;/strong&gt;则是指读写操作的访问地址连续³。在顺序IO访问中，硬盘驱动器（HDD）所需的磁道搜索时间显着减少，因为读/写磁头可以以最小的移动访问下一个块³。在数据库中，全表扫描就是连续读IO¹。例如，当我们进行数据备份和日志记录等业务时，通常会发生在想要的数据块上的所有行⁵。&lt;/p&gt;
&lt;p&gt;在数据库系统的设计中，日志文件采用顺序写入（sequential logging），这是基于传统磁盘访问特性的最大特点¹。数据库中的日志文件，要求必须在事务提交时写入到磁盘，对响应时间的要求很高，所以设计为顺序写入的方式，可以有效降低磁盘寻道花费的时间，减少延迟时间¹。&lt;/p&gt;
&lt;p&gt;然而，数据文件的写入通常包括写数据（写聚簇索引）和写索引（普通索引），所以一般不可能在同一个文件中顺序写入。因此，数据文件的写入通常被视为随机写IO。&lt;/p&gt;
&lt;p&gt;总的来说，&amp;ldquo;Random IO to Sequential IO&amp;quot;可能是指通过某种方式或策略，尽可能地将随机IO转化为顺序IO，以提高数据库的性能。具体的实现方式&lt;/p&gt;
&lt;p&gt;3.2. 存储器结构3.3. 不同类型存储介质之间的差异3.3.1. 闪存(NAND)3.3.2. 相变存储器(PCM)&lt;/p&gt;
&lt;h3 id=&#34;预取缓冲&#34;&gt;预取/缓冲
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单缓冲(Single Buffering)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例：一个文件由一系列块构成：B1, B2,…设有一程序，按下面顺序处理数据：1、处理B1 2、处理B23、处理B3&lt;/li&gt;
&lt;li&gt;单缓冲处理策略
&lt;ul&gt;
&lt;li&gt;(1) 将B1读入缓冲区&lt;/li&gt;
&lt;li&gt;(2) 在缓冲区中处理B1中的数据&lt;/li&gt;
&lt;li&gt;(3) 将B2读入缓冲区&lt;/li&gt;
&lt;li&gt;(4) 处理缓冲区中的B2数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设 P = 在缓冲区中处理一块的时间,R = 将一块读入缓冲区的时间,n = 块数.单缓冲处理时间 = &lt;strong&gt;n(P+R)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双缓冲(Double Buffering)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双缓冲处理时间＝&lt;strong&gt;R＋nP（P&amp;gt;=R）＝ nR＋P（R&amp;gt;=P）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1Ck4y1W7WC/?spm_id_from=333.337.search-card.all.click&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;操作系统-单缓冲区与双缓冲区计算_哔哩哔哩_bilibili&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1gF411F74B/?spm_id_from=333.337.search-card.all.click&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;19-磁盘管理-磁盘单缓冲区与双缓冲区读取_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主存代价&lt;/li&gt;
&lt;li&gt;缓冲区管理&lt;/li&gt;
&lt;li&gt;一致性维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;块大小选择&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O次数 ↓
&lt;ul&gt;
&lt;li&gt;可能读入大量无用数据&lt;/li&gt;
&lt;li&gt;每次I/O要花费更多时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;趋势
-&lt;font color=&#34;#245bdb&#34;&gt; 大块&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;新型存储&#34;&gt;新型存储
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机系统性能依赖于
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;处理器的数据计算能力&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;存储层次向处理器传输数据的能力&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;随着多/众核、多线程技术的发展，传统存储器件构成的存储层次面临的&lt;font color=&#34;#245bdb&#34;&gt;存储墙&lt;/font&gt;问题愈发严重
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;处理单元（核）数的增长与存储数据供应能力（容量）不匹配&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;SRAM/DRAM的功耗过高&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新型存储器件包括：&lt;font color=&#34;#ff0000&#34;&gt;闪存、相变存储器&lt;/font&gt;、磁阻式存储、电阻式存储器、忆阻器等等。具备一个共同特点：&lt;font color=&#34;#0070c0&#34;&gt;非易失性&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;优点：高存储密度、低功耗、无机械延迟、存取速度快、便携、抗震、低噪音等&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;缺点：读写性能不对称、读写次数有限、可靠性不高等&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;闪存&#34;&gt;闪存
&lt;/h3&gt;&lt;h3 id=&#34;相变存储器&#34;&gt;相变存储器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;闪存的工业化程度最高&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;SSD（solid state drive）&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;闪存芯片+控制器+FTL（WL, LBA-PBA, GC）&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（NAND）闪存的特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;读写不对称&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;写慢读快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;写前擦除：异位更新、块擦除操作&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;寿命有限：块擦除次数有限&lt;/font&gt;
SLC （约10万次擦写）
MLC（小于1万次）
TLC（小于1000次）&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;按页读写&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;E.g., 1 page =2 KB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;按块擦除&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;E.g., 1 block = 64 pages
&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239237.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;相变存储器-phase-change-memory&#34;&gt;相变存储器 Phase Change Memory
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;PCM
&lt;ul&gt;
&lt;li&gt;起源于20世纪60年代&lt;/li&gt;
&lt;li&gt;电阻式非易失性半导体存储器&lt;/li&gt;
&lt;li&gt;以硫族化物材料作为存储介质，利用相变材料在不同结晶状态时呈现出显著的电阻值差异性来实现数据存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基于新型存储的计算机架构&#34;&gt;基于新型存储的计算机架构
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401082239244.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第2章 关系型数据库回顾</title>
        <link>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9E%E9%A1%BE/</link>
        <pubDate>Wed, 10 Jan 2024 01:27:05 +0800</pubDate>
        
        <guid>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9E%E9%A1%BE/</guid>
        <description>&lt;h2 id=&#34;数据库体系结构&#34;&gt;数据库体系结构
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从模式的角度描述一般数据库系统的概念和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用于解释特定数据库系统的内部结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ANSI/SPARC体系结构——三级模式结构＋两级映象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Oracle、Informix等SQL数据库系统的模式结构可通过ANSI/SPARC体系结构进行解释&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式（Schema）和实例（Instance）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及类型的描述，不涉及具体的值&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;模式的一个具体值称为模式的一个实例&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091025914.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;模式类型&lt;/th&gt;
          &lt;th&gt;描述&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
          &lt;th&gt;视图&lt;/th&gt;
          &lt;th&gt;DDL&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;概念模式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据库中全体数据的逻辑结构和特征的描述&lt;/td&gt;
          &lt;td&gt;不涉及数据物理存储的细节和硬件环境，一个数据库只有一个概念模式&lt;/td&gt;
          &lt;td&gt;概念视图&lt;/td&gt;
          &lt;td&gt;通过模式DDL进行定义&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;外模式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;单个用户所看到的局部数据的逻辑结构和特征的描述&lt;/td&gt;
          &lt;td&gt;用户与数据库系统的数据接口，对于用户而言，外模式就是数据库，同一模式上可有多个不同的外模式&lt;/td&gt;
          &lt;td&gt;外部视图&lt;/td&gt;
          &lt;td&gt;通过子模式DDL进行定义&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内模式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据物理结构和存储方式的描述&lt;/td&gt;
          &lt;td&gt;不涉及物理块（或页）的大小，也不考虑具体设备的柱面或磁道大小，一个数据库只有一个内模式&lt;/td&gt;
          &lt;td&gt;内部视图&lt;/td&gt;
          &lt;td&gt;通过内模式DDL定义&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;数据库的三级模式结构&#34;&gt;数据库的三级模式结构
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念模式（模式、逻辑模式）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库中全体数据的逻辑结构和特征的描述
&lt;ul&gt;
&lt;li&gt;数据记录由哪些数据项构成&lt;/li&gt;
&lt;li&gt;数据项的名字、类型、取值范围&lt;/li&gt;
&lt;li&gt;数据之间的联系、数据的完整性等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不涉及数据物理存储的细节和硬件环境&lt;/li&gt;
&lt;li&gt;一个数据库只有一个概念模式&lt;/li&gt;
&lt;li&gt;概念视图：概念模式的实例&lt;/li&gt;
&lt;li&gt;通过模式DDL进行定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外模式（子模式、用户模式）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个用户所看到的局部数据的逻辑结构和特征的描述&lt;/li&gt;
&lt;li&gt;用户与数据库系统的数据接口，对于用户而言，外模式就是数据库&lt;/li&gt;
&lt;li&gt;建立在概念模式之上，同一模式上可有多个不同的外模式&lt;/li&gt;
&lt;li&gt;外部视图：外模式的实例&lt;/li&gt;
&lt;li&gt;通过子模式DDL进行定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内模式（存储模式）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据物理结构和存储方式的描述
&lt;ul&gt;
&lt;li&gt;记录的存储方式：&lt;font color=&#34;#0070c0&#34;&gt;顺序存储、按B树组织还是散列存储？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;索引按什么方式组织：排序、散列？&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;数据是否加密？是否压缩存储？&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不涉及物理块（或页）的大小，也不考虑具体设备的柱面或磁道大小&lt;/li&gt;
&lt;li&gt;一个数据库只有一个内模式&lt;/li&gt;
&lt;li&gt;内部视图：内模式的实例&lt;/li&gt;
&lt;li&gt;通过内模式DDL定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二级映象和数据独立性&#34;&gt;二级映象和数据独立性
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;二级映象实现三级模式结构间的联系和转换，使用户可以逻辑地处理数据，不必关系数据的底层表示方式和存储方式&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091034656.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外模式/模式映象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义了外模式与概念模式之间的对应关系
&lt;ul&gt;
&lt;li&gt;属性名称可能不同&lt;/li&gt;
&lt;li&gt;外模式中的属性可能由模式中的多个属性运算而得&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当概念模式发生改变时，只要修改外模式/模式映象，可保持外模式不变，从而保持用户应用程序不变，保证了数据与用户程序的逻辑独立性——数据的逻辑独立性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式/内模式映象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义了概念模式与内模式之间的对应关系
-&lt;font color=&#34;#0070c0&#34;&gt; 概念模式中的逻辑记录和字段在内部如何表示&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;当数据库的内部存储结构发生改变时，只要修改模式/内模式映象，可保持概念模式不变，从而保持外模式以及用户程序的不变，保证了数据与程序的物理独立性——数据的物理独立性&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091427010.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;sql数据库体系结构&#34;&gt;SQL数据库体系结构
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091427074.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;关系型数据库&#34;&gt;关系型数据库
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用数据库技术，首先必须把现实世界中的事物表示为计算机能够处理的数据&lt;/li&gt;
&lt;li&gt;模型是对现实世界特征的抽象&lt;/li&gt;
&lt;li&gt;数据模型是对现实世界数据特征的抽象&lt;/li&gt;
&lt;li&gt;数据模型的定义
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;描述现实世界实体、实体间联系以及数据语义和一致性约束的模型&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据模型的分类&#34;&gt;数据模型的分类
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;概念数据模型（概念模型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按用户的观点对数据进行建模，强调语义表达功能&lt;/li&gt;
&lt;li&gt;独立于计算机系统和DBMS&lt;/li&gt;
&lt;li&gt;主要用于数据库的概念设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构数据模型（数据模型）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按计算机系统的观点对数据进行建模，直接面向数据库的逻辑结构&lt;/li&gt;
&lt;li&gt;与计算机系统和DBMS相关（DBMS支持某种数据模型）&lt;/li&gt;
&lt;li&gt;有严格的形式化定义，以便于在计算机系统中实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据抽象的层次&#34;&gt;数据抽象的层次
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091433547.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据模型的例子&#34;&gt;数据模型的例子
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;现实世界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户存款&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息世界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念模型（E-R模型）&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091434056.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;机器世界&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据模型（关系模型&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091434443.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据模型的要素&#34;&gt;数据模型的要素
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据结构
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;现实世界实体及实体间联系的表示和实现&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据操作
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;数据检索和更新的实现&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的完整性约束
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#0070c0&#34;&gt;数据及数据间联系应具有的制约和依赖规则&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系模型&#34;&gt;关系模型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;关系模型
&lt;ul&gt;
&lt;li&gt;用&lt;font color=&#34;#ff0000&#34;&gt;规范化的二维表格结构&lt;/font&gt;表示实体集，&lt;font color=&#34;#ff0000&#34;&gt;外码&lt;/font&gt;表示实体间联系，&lt;font color=&#34;#ff0000&#34;&gt;三类完整性&lt;/font&gt;表示数据约束的数据模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091437344.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;几个术语&#34;&gt;几个术语
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;术语&lt;/th&gt;
          &lt;th&gt;定义&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;属性(Attribute)&lt;/td&gt;
          &lt;td&gt;二维表格的每一列称为关系的一个属性，列的数目称为&lt;font color=&#34;#ff0000&#34;&gt;度（degree）&lt;/font&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;元组(Tuple)&lt;/td&gt;
          &lt;td&gt;每一行称为关系的一个元组，元组的数目称为&lt;font color=&#34;#ff0000&#34;&gt;势（cardinality）&lt;/font&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;域(Domain)&lt;/td&gt;
          &lt;td&gt;一组具有相同数据类型的值的集合。每个属性有一个域&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;关系（Relation）&lt;/td&gt;
          &lt;td&gt;元组的集合&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;超码（Super Key）&lt;/td&gt;
          &lt;td&gt;在关系中能&lt;font color=&#34;#ff0000&#34;&gt;唯一标识一个元组&lt;/font&gt;的属性集称为关系模式的超码&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;候选码（Candidate Key）&lt;/td&gt;
          &lt;td&gt;不含多余属性的超码&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;主属性（Primary Attribute）&lt;/td&gt;
          &lt;td&gt;包含在任何一个候选码中的属性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非主属性（Nonprime Attribute）&lt;/td&gt;
          &lt;td&gt;不包含在任何一个候选码中的属性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;主码（Primary Key）&lt;/td&gt;
          &lt;td&gt;用户选作元组标识的一个候选码称为主码，其余的候选码称为&lt;font color=&#34;#ff0000&#34;&gt;替换码&lt;/font&gt;（Alternate Key）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Student(Sno, Name, Age, LibraryID)&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;超码
&lt;ul&gt;
&lt;li&gt;(sno,name)&lt;/li&gt;
&lt;li&gt;(libraryID, name) …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;候选码
&lt;ul&gt;
&lt;li&gt;Sno&lt;/li&gt;
&lt;li&gt;LibraryID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主码
&lt;ul&gt;
&lt;li&gt;若选sno，则sno为主码，libraryID为替换码&lt;/li&gt;
&lt;li&gt;若选libraryID，则libraryID 为主码， sno为替换码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系的性质&#34;&gt;关系的性质
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个关系是一个规范化的二维表格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;属性值不可分解&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;不允许表中有表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt; 元组不可重复&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因此一个关系模式至少存在一个候选码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;没有行序，即元组之间无序&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系是元组的集合，集合的元素是无序的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#245bdb&#34;&gt;没有列序，即属性之间无序&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系模式是属性的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系模式与关系数据库&#34;&gt;关系模式与关系数据库
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#ff0000&#34;&gt;关系模式（Relation Schema）&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;关系的逻辑结构和特征的描述&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;对应于二维表格的表头&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;通常由属性集和各属性域表示，不关心域时可省略域&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;Student（Name, Age, Class）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#ff0000&#34;&gt;关系&lt;/font&gt;：关系模式的实例，即二维表（元组的集合）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#ff0000&#34;&gt;关系数据库模式&lt;/font&gt;（Relational DatabaseSchema）：关系模式的集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;font color=&#34;#ff0000&#34;&gt;关系数据库&lt;/font&gt;：关系数据库模式的实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系模式的形式化定义&#34;&gt;关系模式的形式化定义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关系模式可以形式化定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R（U，D，dom，F）&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;R为关系模式名，U是一个属性集，D是U中属性的值所来自的域，Dom是属性向域的映射集合，F是属性间的依赖关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例：Student关系模式的定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Student(U,D,dom,F)&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;U={sno,name,age}&lt;/li&gt;
&lt;li&gt;D={CHAR,INT}&lt;/li&gt;
&lt;li&gt;Dom={dom(sno)=dom(name)=CHAR,dom(age)=INT}&lt;/li&gt;
&lt;li&gt;F={sno→name, sno→age}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系模式通常简写为R(U)，或R(A1,A2,…,An)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函数依赖&#34;&gt;函数依赖
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;R(U，D，dom，F)中的F在实际中一般只考虑函数依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数依赖(Functional Dependency, FD)是指一个关系模式中一个属性集和另一个属性集间的多对一关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如选课关系SC(S#, C#, Score)&lt;/li&gt;
&lt;li&gt;存在由属性集{S#, C#}到属性集{Score}的函数依赖
&lt;ul&gt;
&lt;li&gt;对于任意给定的S#值和C#值，只有一个Score值与其对应&lt;/li&gt;
&lt;li&gt;反过来，可以存在多个S#值和C#值，它们对应的Score值相等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数依赖（FD，Functional Dependency）的形式化定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;设关系模式R(A1,A2,…,An)或简记为R(U)，X和Y是U的子集。r是R的任意一个实例（关系），若r的任意两个元组t1、t2，由t1[X]=t2[X]可导致t1[Y]=t2[Y]，即如果X相等则Y也相等，则称Y函数依赖于X或称为X函数决定Y，记作 X→Y&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;即R的X属性集上的值可唯一决定R的Y属性集上的值&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;也即对于R的任意两个元组，X上的值相等，则Y上的值也必相等&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FD是相对于关系模式而言的，因此关系模式R的所有实例都要满足FD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;Student关系模式中，{S#} →{Sname} （单个属性可去掉括号，简写成 S# →Sname ）&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;SC关系模式中， {S#,C#} →{Score}&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FD是否成立，唯一办法是仔细考察应用中属性的 含义。FD实际上是对现实世界的断言。数据库设计者在设计时把应遵守的函数依赖通知DBMS，则DBMS会自动检查关系的合法性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;对于关系模式 R( Tname, Addr, C#, Cname)&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;若一门课只能有一个教师，则有{C#} →{Tname}&lt;/li&gt;
&lt;li&gt;若一门课可有多个教师任教，则{C#} →{Tname}不成立&lt;/li&gt;
&lt;li&gt;因此FD是与具体应用相关的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系模型的形式化定义&#34;&gt;关系模型的形式化定义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据结构
-&lt;font color=&#34;#245bdb&#34;&gt; 关系：数据库中全部数据及数据间联系都以关系来表示&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;数据操作
&lt;ul&gt;
&lt;li&gt;关系运算
&lt;ul&gt;
&lt;li&gt;关系代数&lt;/li&gt;
&lt;li&gt;关系演算（元组关系演算、域关系演算）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的完整性约束
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;关系模型的三类完整性规则&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系代数relational-algebra&#34;&gt;关系代数(Relational Algebra)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;以关系为运算对象的一组运算集合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运算结果仍是关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以集合操作为基本运算
&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091830614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数表达式的符号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学符号表示
并∪ 、交∩、差－、笛卡儿积×
选择σ 、投影π 、联接 ∞ 、除÷
重命名 ρx（E）
赋值 ←&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;英语关键字表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并Union、交Intersect、差Minus、笛卡儿积Times、选择Where…、投影{All But…}、联接Join、除Devidedby&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数的封闭性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;任意关系代数操作的结果仍是一个关系&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数的封闭性保证了关系代数操作的可嵌套性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091848464.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子：&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091849151.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;关系模型中数据操作都通过关系代数表达式来表示&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数中的基本表达式是关系代数表达式，基本表达式由如下之一构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;数据库中的一个关系&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;一个常量关系&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设E1和E2是关系代数表达式，则下面的都是关系代数表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;E1∪E2 、E1－E2、E1×E2&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;σP(E1),其中P是E1中属性上的谓词&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;πs(E1),其中S是E1中某些属性的列表&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;ρx(E1),其中x是E1结果的新名字&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系代数操作的语义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并∪ 、交∩、差－、笛卡儿积×&lt;/li&gt;
&lt;li&gt;选择σ 、投影π 、联接 ∞ 、除÷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R∪S＝｛t∣t∈R∨t∈S｝
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;t是元组变量&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R和S是关系代数表达式&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R与S的degree必须相同&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R与S的类型必须相同&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091837766.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R∩S＝｛t∣t∈R∧t∈S｝&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091837820.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;差&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R－S＝｛t∣t∈R∧t S｝&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091838386.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;积&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R×S＝｛t∣t=&amp;lt;tr,ts&amp;gt;∧tr∈R∧ts∈S｝&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091839636.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;σF(R)＝｛t∣t∈R∧F(t)=TRUE｝
&lt;ul&gt;
&lt;li&gt;水平划分关系&lt;/li&gt;
&lt;li&gt;F是一个逻辑表达式，表示所选的元组应满足的条件&lt;/li&gt;
&lt;li&gt;F由逻辑运算符┐(NOT)、∧(AND)、∨(OR)连接算术表达式构成
&lt;ul&gt;
&lt;li&gt;算术表达式形为XθY，θ可以是&amp;gt;,&amp;lt;,=, ≤,≥或≠，X和Y可以是属性名、常量或简单函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091842784.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投影&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;πA(R)＝｛t[A]∣t∈R｝,其中A是R的属性子集
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;垂直划分关系，选取若干列所构成的关系&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;A中的属性不可重复&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091843713.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联接：自然联接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设R的属性集为{X,Y}，S的属性集为{Y,Z}&lt;/li&gt;
&lt;li&gt;R∞S=t|t=&amp;lt;X,Y,Z&amp;gt;∧t[X,Y]∈R∧t[Y,Z]∈S}
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;相当于在R×S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091845001.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联接： θ联接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设R的属性集为{X,Y}，S的属性集为{Y,Z}&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091846598.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;ul&gt;
&lt;li&gt;相当于在R×S中选取R的属性A值与S的属性B值满足比较关系θ的元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091846504.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;联接： 等值联接（equijoin）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在θ联接中θ为等号时，称为“等值联接”&lt;/li&gt;
&lt;li&gt;等值联接是θ联接中比较常见的形式&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091847725.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据更新仍通过关系代数实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R←R－E：R是关系，E是关系代数查询&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;例“从数据库中删除姓名为‘Rose’的学生”&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;Student←Student－σname=‘Rose’(Student)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;R←R∪E：R是关系，E是关系代数表达式&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;如果E是常量关系，则可以插入单个元组&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;例：插入一个新的学生&lt;/font&gt;
&lt;ul&gt;
&lt;li&gt;S1←S1∪ { (‘001’,’Rose’,19) }&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091851095.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关系模型的三类完整性规则&#34;&gt;关系模型的三类完整性规则
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实体完整性（Entity Integrity）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系模式R的&lt;strong&gt;主码&lt;/strong&gt;不可取空值&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091852883.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参照完整性（Referential Integrity）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外码（Foreign Key）
&lt;ul&gt;
&lt;li&gt;关系模式R的外码是它的一个属性集FK，满足：
&lt;ul&gt;
&lt;li&gt;存在带有候选码CK的关系模式S，且&lt;/li&gt;
&lt;li&gt;R的任一非空FK值都在S的CK中有一个相同的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;S称为被参照关系（Referenced Relation），R称为参照关系（Referential Relation）&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091853384.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参照关系R的任一个外码值必须
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;等于被参照关系S中所参照的候选码的某个值&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;或者为空&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户自定义完整性（User-Defined Integrity）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对某一具体数据的约束条件，反映某一具体应用所涉及的数据必须满足的特殊语义&lt;/li&gt;
&lt;li&gt;由应用环境决定&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091855588.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql&#34;&gt;SQL
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&#34;#245bdb&#34;&gt;数据库语言是用户使用数据库的接口，DBMS支持用户通过数据库语言进行数据存取与管理&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有三类数据库语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言(Data Definition Language, DDL)&lt;/li&gt;
&lt;li&gt;数据操纵语言(Data Manipulation Language， DML)&lt;/li&gt;
&lt;li&gt;数据控制语言 (Data Control Language, DCL)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sql基本组成&#34;&gt;SQL基本组成
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091856088.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;sql与关系模型&#34;&gt;SQL与关系模型
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据结构:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;SQL使用表来组织和存储数据。&lt;/li&gt;
&lt;li&gt;在关系模型中，数据以关系的形式组织。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据操作:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;SQL使用数据操纵语言（DML）进行操作，如SELECT、INSERT、UPDATE、DELETE。&lt;/li&gt;
&lt;li&gt;关系模型使用关系代数进行数据操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据约束:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;SQL包含主键、外键、唯一和检查等约束。&lt;/li&gt;
&lt;li&gt;在关系模型中，约束涉及实体完整性（确保每行具有唯一标识符）、参照完整性（维护表之间的关系）和用户自定义完整性（用户定义的其他约束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;习题&#34;&gt;习题
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202401091909276.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>第1章 数据库系统概述</title>
        <link>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
        <pubDate>Wed, 10 Jan 2024 00:40:05 +0800</pubDate>
        
        <guid>https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
        <description>&lt;h2 id=&#34;11-dbms系统结构组成&#34;&gt;1.1. DBMS系统结构组成
&lt;/h2&gt;&lt;h2 id=&#34;数据库dbms数据库系统等基本概念&#34;&gt;数据库、DBMS、数据库系统等基本概念
&lt;/h2&gt;&lt;h3 id=&#34;数据&#34;&gt;数据
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据(Data)是数据库中存储的基本对象&lt;/li&gt;
&lt;li&gt;数据的定义
&lt;ul&gt;
&lt;li&gt;人们用来反映客观世界而记录下来的可以鉴别的符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的种类
&lt;ul&gt;
&lt;li&gt;数值数据：0－9&lt;/li&gt;
&lt;li&gt;非数值数据：字符、文字、声音、图形、图像等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的特点
&lt;ul&gt;
&lt;li&gt;数据与其语义是不可分的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例子1：93是一个数据
&lt;ul&gt;
&lt;li&gt;语义1：学生某门课的成绩&lt;/li&gt;
&lt;li&gt;语义2：某人的体重&lt;/li&gt;
&lt;li&gt;语义3：计算机学院2016级学生人数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例子2：学生档案记录（李明，197205，中国科大，1990）
&lt;ul&gt;
&lt;li&gt;语义1：学生，出生年月，所在学校，毕业年份&lt;/li&gt;
&lt;li&gt;语义2： 学生，出生年月，录取大学，入学时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库&#34;&gt;数据库
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据库的定义
数据库(Database,简称DB)是长期储存在计算机内、有
组织的、可共享的大量数据的集合&lt;/li&gt;
&lt;li&gt;数据库的基本特征
&lt;ul&gt;
&lt;li&gt;数据按一定的数据模型组织、描述和储存&lt;/li&gt;
&lt;li&gt;可为各种用户共享&lt;/li&gt;
&lt;li&gt;数据间联系密切，具有最小的冗余度和较高的独立性&lt;/li&gt;
&lt;li&gt;服务于某个特定的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;例：图书馆的图书数据库、机场的航班数据库、银行数据库……&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库模式-schema&#34;&gt;数据库模式 (Schema)
&lt;/h3&gt;&lt;p&gt;数据库模式是数据库中全体数据的逻辑结构和特征的描述
![[Pasted image 20240108110812.png]]&lt;/p&gt;
&lt;h3 id=&#34;数据库管理系统&#34;&gt;数据库管理系统
&lt;/h3&gt;&lt;p&gt;DBMS（Database Management System），是计算机程序的集
合，用于创建和维护数据库
![[Pasted image 20240108110347.png]]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位于操作系统和用户应用之间&lt;/li&gt;
&lt;li&gt;总是基于某种数据模型&lt;/li&gt;
&lt;li&gt;数据库厂商的产品通常指DBMS，如Oracle11g、Microsoft SQL Server 2008、DB2、MySQL等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dbms一般架构&#34;&gt;DBMS一般架构
&lt;/h3&gt;&lt;p&gt;![[Pasted image 20240108210938.png]]&lt;/p&gt;
&lt;h3 id=&#34;数据库系统&#34;&gt;数据库系统
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DBS（DataBase System），指在计算机系统中引入了数据库后的系统，即采用了数据库技术的计算机系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库设计问题&#34;&gt;数据库设计问题
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如何设计和实现一个DBMS来高效的组织和管理数据库？——DBMS实现问题    研究生课程内容&lt;/li&gt;
&lt;li&gt;如何针对特定应用的需求设计一个合理的数据库结构？——数据库设计问题       本科课程内容&lt;/li&gt;
&lt;li&gt;应用程序如何有效地存取数据库中的数据？——数据库存取问题      本科课程内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dbms实现问题&#34;&gt;DBMS实现问题
&lt;/h2&gt;&lt;p&gt;1、一个虚拟的DBMS：Megatron2000&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNIX下的关系型DBMS，支持SQL&lt;/li&gt;
&lt;li&gt;实现细节
&lt;ul&gt;
&lt;li&gt;关系通过文件（ASCII）存储，e.g. R存储在/usr/db/R中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;  Smith # 123 # CS
  Jones # 522 # EE
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt; - 数据库模式存储在特定的文件（ASCII）中
	R1 # A # INT # B # STR …
	R2 # C # STR # A # INT …
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Megatron 2000如何执行查询？
执行 “&lt;strong&gt;select * from R where condition&lt;/strong&gt;”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读数据字典获取R的属性&lt;/li&gt;
&lt;li&gt;读R对应的文件，对于每一行数据:
&lt;ul&gt;
&lt;li&gt;检查条件&lt;/li&gt;
&lt;li&gt;如果条件满足，则输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行”&lt;strong&gt;select A,B from R,S where condition&lt;/strong&gt;”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读数据字典获取R和S的属性&lt;/li&gt;
&lt;li&gt;读R文件，对于每一行数据:
&lt;ul&gt;
&lt;li&gt;读S文件，对于每一行数据:
&lt;ul&gt;
&lt;li&gt;生成连接元组&lt;/li&gt;
&lt;li&gt;检查条件&lt;/li&gt;
&lt;li&gt;若条件满足，则输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Megatron 2000功能总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以定义表&lt;/li&gt;
&lt;li&gt;可以进行数据操作
&lt;ul&gt;
&lt;li&gt;数据更新&lt;/li&gt;
&lt;li&gt;数据查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Megatron 2000 存在什么问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;元组平铺在磁盘上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 ’EE’改为 ’ECON’，需要重写整个文件&lt;/li&gt;
&lt;li&gt;ASCII存储过于昂贵&lt;/li&gt;
&lt;li&gt;删除操作同样代价很高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低级的查询处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例，&lt;code&gt;select *from Student S,SC where S.sno = SC.sno and SC.credit &amp;gt; 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;先做连接比先做选择效率要低&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;未考虑更高效的连接算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有缓冲区管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据直接从磁盘存取，磁盘I/O的代价昂贵&lt;/li&gt;
&lt;li&gt;需要Buffer来加速数据存取效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有并发控制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多用户同时存取数据时数据一致性得不到保证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有索引；数据查询效率低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能快速地根据给定键值查询元组&lt;/li&gt;
&lt;li&gt;总是要读入整个关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有可靠性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生数据库系统故障时没有恢复机制&lt;/li&gt;
&lt;li&gt;易出现数据不一致的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有应用程序编程接口（API）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用如何存取数据库？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;糟糕的数据字典组织&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
