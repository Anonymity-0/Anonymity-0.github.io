[{"content":"Welcome to AGA\u0026rsquo;s Blog. This is my first post.\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\n","date":"2023-10-18T17:55:36+08:00","image":"https://anonymity-0.github.io/posts/hello-world/cover_huf17888c423d4998eadaee1ca18c79e46_784100_120x120_fill_q75_box_smart1.jpg","permalink":"https://anonymity-0.github.io/posts/hello-world/","title":"Hello World"},{"content":"2.1 套接字协议及其数据传输特性 协议 如果相隔很远的两人想展开对话,必须先决定对话方式。如果一方使用电话,那么另一方也只能使用电话,而不是书信。可以说,电话就是两人对话的协议。协议是对话中使用的通信规则, 把上述概念拓展到计算机领域可整理为“计算机间对话必备通信规则”。\n创建套接字 1 2 3 4 5 6 #include \u0026lt;sys/socket.h\u0026gt; int socket (int domain, int type, int protocol); //成功时返回文件描述符,失败时返回-1。 //domain 套接字中使用的协议族(Protocol Family)信息。 //type 套接字数据传输类型信息。 //protocol 计算机间通信中使用的协议信息。 在 Go 语言的 syscall 包中，Socket 函数是对底层 socket 系统调用的封装。这样做的目的是为了提供一个更加 Go 风格（例如错误处理）的接口，同时隐藏一些底层细节。\nSocket 函数内部调用了 socket 函数。socket 函数直接执行了系统调用，并返回了原始的结果，包括一个文件描述符和一个错误号。然后 Socket 函数将这些原始结果转换为 Go 风格的结果：如果系统调用成功，它返回一个文件描述符和一个 nil 错误；如果系统调用失败，它返回一个 -1 文件描述符和一个非 nil 错误。\n这样做的好处是，对于大多数 Go 程序员来说，他们只需要关心 Socket 函数，而不需要了解底层的 socket 系统调用和错误处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 func Socket(domain, typ, proto int) (fd int, err error) { // 如果 domain 是 AF_INET6（即，我们正在尝试创建一个 IPv6 套接字）， // 但是 SocketDisableIPv6 为 true（即，我们禁用了 IPv6），则返回错误 EAFNOSUPPORT。 if domain == AF_INET6 \u0026amp;\u0026amp; SocketDisableIPv6 { return -1, EAFNOSUPPORT } // 调用底层的 socket 函数创建套接字。 fd, err = socket(domain, typ, proto) return } // socket 函数创建一个新的套接字，并返回其文件描述符和可能的错误。 // domain 参数指定了套接字的协议族（例如，AF_INET 代表 IPv4，AF_INET6 代表 IPv6）。 // typ 参数指定了套接字的类型（例如，SOCK_STREAM 代表 TCP，SOCK_DGRAM 代表 UDP）。 // proto 参数指定了套接字使用的协议（例如，IPPROTO_TCP 代表 TCP，IPPROTO_UDP 代表 UDP）。 // rawSyscall 函数执行一个底层的系统调用，其参数是系统调用的编号和参数。 // 如果系统调用失败，它返回一个非零的错误号 e1，我们将其转换为 Go 的 error 类型并返回。 func socket(domain int, typ int, proto int) (fd int, err error) { r0, _, e1 := rawSyscall(abi.FuncPCABI0(libc_socket_trampoline), uintptr(domain), uintptr(typ), uintptr(proto)) fd = int(r0) if e1 != 0 { err = errnoErr(e1) } return } 协议族(Protocol Family) 通过socket函数的第一个参数传递套接字中使用的协议分类信息。此协议分类信息称为协议族。 原文给的c语言头文件中的分类 在 Go 语言的 syscall 包中，domain 参数用于指定套接字的协议族。以下是一些常见的 domain 值：\n值 描述 AF_INET IPv4 网络协议 AF_INET6 IPv6 网络协议 AF_UNIX UNIX 域套接字 AF_NETLINK 内核用户接口设备 AF_PACKET 低级包接口 AF_CAN Controller Area Network AF_BLUETOOTH 蓝牙设备 请注意，不是所有的 domain 值都在所有的平台上可用。具体可用的 domain 值取决于你的操作系统和平台。\n套接字类型(Type) 套接字类型指的是套接字的数据传输方式,通过socket函数的第二个参数传递,只有这样才能决定创建的套接字的数据传输方式。这种说法可能会使各位感到疑惑。已通过第一个参数传递了协议族信息,还要决定数据传输方式?问题就在于,决定了协议族并不能同时决定数据传输方式,换言之,socket数第一个参数PF_INET协议族中也存在多种数据传输方式。\n面向连接的套接字(SOCK_STREAM) 如果向socket函数的第二个参数传递SOCK_STREAM,将创建面向连接的套接字。面向连接的套接字到底具有哪些特点呢?\n套接字连接必须一一对应 传输过程中数据不会消失 按序传输数据 传输的数据不存在数据边界 收发数据的套接字内部有缓冲(buffer),简言之就是字节数组。通过套接字传输的数据将保存到该数组。因此,收到数据并不意味着马上调用read函数。只要不超过数组容量,则有可能在数据填充满缓冲后通过1次read函数调用读取全部,也有可能分成多次read函数调用进行读取。也就是说,在面向连接的套接字中,read函数和write函数的调用次数并无太大意义。所以说面向连接的套接字不存在数据边界。\n套接字缓冲已满是否意味着数据丢失 之前讲过,为了接收数据,套接字内部有一个由字节数组构成的缓冲。如果这个缓冲被接收的数据填满会发生什么事情?之后传递的数据是否会丢失? 首先调用read函数从缓冲读取部分数据,因此,缓冲并不总是满的。但如果read函数读取速度比接收数据的速度慢,则缓冲有可能被填满。此时套接字无法再接收数据, 但即使这样也不会发生数据丢失,因为传输端套接字将停止传输。也就是说,面向连接的套接字会根据接收端的状态传输数据,如果传输出错还会提供重传服务。因此,面向连接的套接字除特殊情况外不会发生数据丢失。\n面向消息的套接字(SOCK_DGRAM) 如果向socket函数的第二个参数传递SOCK_DGRAM,则将创建面向消息的套接字。面向消息的套接字可以比喻成高速移动的摩托车快递。\n强调快速传输而非传输顺序 传输的数据可能丢失也可能损毁 传输的数据有数据边界 限制每次传输的数据大小 众所周知,快递行业的速度就是生命。用摩托车发往同一目的地的2件包裹无需保证顺序, 只要以最快速度交给客户即可。这种方式存在损坏或丢失的风险,而且包裹大小有一定限制。因此,若要传递大量包裹,则需分批发送。另外,如果用2辆摩托车分别发送2件包裹,则接收者也需要分2次接收。这种特性就是“传输的数据具有数据边界”。\n面向消息的套接字比面向连接的套接字具有更快的传输速度,但无法避免数据丢失或损毁。另外,每次传输的数据大小具有一定限制,并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。面向消息的套接字特性总结如下: “不可靠的、不按序传递的、以数据的高速传输沟目的的套接字\u0026quot;\n最终选择的协议 下面讲解socket函数的第三个参数,该参数决定最终采用的协议。 前面已经通过socket函数的前两个参数传递了协议族信息和套接字数据传输方式,这些信息还不足以决定采用的协议吗?为什么还需要传递第3个参数呢? 传递前两个参数即可创建所需套接字。所以大部分情况下可以向第三个参数传递0,除非遇到以下这种情况: “同一协议族中存在多个数据传输方式相同的协议”数据传输方式相同,但协议不同。此时需要通过第三个参数具体指定协议信息。\nTCP套接字示例 tcp_server.go (系统函数调用版)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 2 { fmt.Printf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } port, _ := strconv.Atoi(os.Args[1]) //1.创建一个 TCP 套接字。 fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) if err != nil { fmt.Printf(\u0026#34;socket() error: %v\u0026#34;, err) } //2.将套接字绑定到指定的 IP 地址和端口号。 // 创建一个 SockaddrInet4 结构体实例，并设置端口号 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} // 将 IP 地址设置为 0.0.0.0，这样服务器可以接受来自任何客户端的连接 copy(servAddr.Addr[:], []byte{0, 0, 0, 0}) err = syscall.Bind(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;bind() error: %v\u0026#34;, err) } //3.将套接字转为可接收连接状态 err = syscall.Listen(fd, 10) if err != nil { log.Fatalf(\u0026#34;listen() error: %v\u0026#34;, err) } //4.Accept()接收连接 connFd, _, err := syscall.Accept(fd) if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 message := \u0026#34;Hello world!\u0026#34; _, err = syscall.Write(connFd, []byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } syscall.Close(connFd) syscall.Close(fd) } tcp_clinet.go 更改read函数调用方式，在客户端中分多次调用read函数以接收服务器端发送的全部数据,以验证tcp传输的数据不存在数据边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] portStr := os.Args[2] port, err := strconv.Atoi(portStr) if err != nil { log.Fatalf(\u0026#34;Invalid port number: %s\\n\u0026#34;, portStr) } fd, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 设置服务器的地址和端口 servAddr := \u0026amp;syscall.SockaddrInet4{Port: port} copy(servAddr.Addr[:], net.ParseIP(ip).To4()) // 使用 syscall.Connect 函数将套接字连接到服务器 err = syscall.Connect(fd, servAddr) if err != nil { log.Fatalf(\u0026#34;connect() error: %v\u0026#34;, err) } // 使用 syscall.Read 接收信息 buf := make([]byte, 1024) message := make([]byte, 0) for { n, err := syscall.Read(fd, buf) if err != nil { if err != io.EOF { log.Fatalf(\u0026#34;Read error: %v\u0026#34;, err) } break } if n == 0 { break } message = append(message, buf[:n]...) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) fmt.Printf(\u0026#34;Function read() read %d bytes\\n\u0026#34;, len(message)) syscall.Close(fd) } 运行\n1 2 3 4 5 6 7 8 go build -o ch2/tcpServer/tcp_server ch2/tcpServer/tcp_server.go go build -o ch2/tcpClient/tcp_client ch2/tcpClient/tcp_client.go ./ch2/tcpServer/tcp_server 8888 ./ch2/tcpClient/tcp_client 127.0.0.1 8888 Message from server: Hello world! Function read() read 12 bytes 2.2 Windows平台啊下的实现及验证 略\n2.3 习题 什么是协议?在收发数据中定义协议有何意义?\n面向连接的TCP套接字传输特性有3点,请分别说明。\n无数据边界 传输过程中数据不会消失 按序传输 下列哪些是面向消息的套接字的特性? a. 传输数据可能丢失 b. 没有数据边界(Boundary) （面向连接） c. 以快速传递为目标 d. 不限制每次传递数据的大小 （限制大小） e. 与面向连接的套接字不同,不存在连接的概念\n下列数据适合用哪类套接字传输?并给出原因。\na. 演唱会现场直播的多媒体数据(面向消息) 因为面向消息的套接字以快速传递为目标，适合传输多媒体数据，即使传输数据可能丢失也不会影响整体效果。 b. 某人压缩过的文本文件(面向连接) 因为面向连接的套接字可以保证数据的可靠传输，适合传输对数据完整性要求较高的文本文件。 c. 网上银行用户与银行之间的数据传递(面向连接) 面向连接的套接字提供可靠的、按顺序传送的数据传输服务，适合对数据完整性和安全性要求较高的网上银行交易。 何种类型的套接字不存在数据边界?这类套接字接收数据时需要注意什么? 面向连接的套接字不存在数据边界。面向连接的TCP套接字在接收数据时需要注意处理粘包和拆包的问题，确保按照应用层协议的要求正确解析和处理接收到的数据\ntcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用I次write函数传递的字符串。更改程序,使服务器端多次调用(次数自拟)write函数传输数据,客户端调用1 次read函数进行读取。为达到这一目的,客户端需延迟调用read函数,因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。for(1=0;i\u0026lt;3000;i++) printf(\u0026ldquo;wait time %d \\n\u0026rdquo;, i); 让CPU执行多余任务以延迟代码运行的方式称为 “Busy Waiting”。使用得当即可推迟函数调用。\n","date":"2023-11-11T12:48:30+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第二章笔记"},{"content":"1.1 理解网络和套接字 套接字 套接字（socket）是计算机网络中进程间通信的一种机制，它将进程间通信抽象为一个端点，该端点由一个IP地址和一个端口号来标识。 套接字是网络数据传输用的软件设备。网络编程又称为套接字编程。\n编写\u0026quot; Hello world! \u0026quot; 服 务 器 端 网络编程中接受连接请求的套接字创建过程可整理如下。\n第一步:调用s o c k e t 函数创建套接字。 第二步:调用b i n d 函数分配E地址和端口号。 第三步:调用l i s t e n 函数转为可接收请求状态。 第四步:调用a c c e p t 函数受理连接请求。 hello_server.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { //检查参数 if len(os.Args) != 2 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } //设置监听端口和信息 message := \u0026#34;Hello world!\u0026#34; port := os.Args[1] //当你调用 net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) 时，Go 会执行以下操作： //1.创建一个 TCP 套接字。 //2.将套接字绑定到指定的 IP 地址和端口号。 //3.将套接字转为可接收连接状态 listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) if err != nil { log.Fatalf(\u0026#34;socket() error: %v\u0026#34;, err) } //延迟关闭监听 defer listener.Close() //循环监听 for { //4.Accept()接收连接 conn, err := listener.Accept() if err != nil { log.Fatalf(\u0026#34;accept() error: %v\u0026#34;, err) } //5.write()发送信息 _, err = conn.Write([]byte(message)) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } conn.Close() } } client 创建套接字,但此时套接字并不马上分为服务器端和客户端。如果紧接着调用bind和listen函数,将成为服务器端套接字;如果调用connect函数将成为客户端套接字。\nhello_client.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) != 3 { log.Fatalf(\u0026#34;Usage: %s \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\\n\u0026#34;, os.Args[0]) } ip := os.Args[1] port := os.Args[2] address := fmt.Sprintf(\u0026#34;%s:%s\u0026#34;, ip, port) //1.创建一个 TCP 套接字。 //2.调用 Connect() 连接到指定的 IP 地址和端口号。 conn, err := net.Dial(\u0026#34;tcp\u0026#34;, address) if err != nil { log.Fatalf(\u0026#34;Failed to connect to server: %v\u0026#34;, err) } defer conn.Close() //net.Conn 对象来读取服务器发送的消息 message, err := io.ReadAll(conn) if err != nil { log.Fatalf(\u0026#34;Failed to read from server: %v\u0026#34;, err) } fmt.Printf(\u0026#34;Message from server: %s\\n\u0026#34;, message) } 运行 编译运行服务器 1 2 go build -o ch1/hello_server ch1/hello_server.go ./ch1/hello_server 8080 编译运行客户端 1 2 3 4 5 go build -o ch1/hello_client ch1/hello_client/hello_client.go ./ch1/hello_client 127.0.0.1 8080 Message from server: Hello world! 1.2 文件操作 打开文件 首先介绍打开文件以读写数据的函数。 调用此函数时需传递两个参数:第一个参数是打开的目标文件名及路径信息,第二个参数是文件打开模式(文件特性信息)。\n1 2 3 4 5 6 7 #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; int open(const char * path ，int flag) //成功时返回文件描述符事失败时返回1 //path 文件名字符串地址 //flag 文件打开模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } // OpenFile 是一个通用的文件打开函数，它接受三个参数：文件名、打开文件的标志和文件权限。 // 它返回一个 *os.File 对象和一个 error 对象。如果打开文件失败，它会返回一个非 nil 的 error 对象。 func OpenFile(name string, flag int, perm FileMode) (*File, error) { // 记录打开文件的操作 testlog.Open(name) // 使用 openFileNolog 函数打开文件，这个函数不记录日志 f, err := openFileNolog(name, flag, perm) // 如果打开文件失败，返回错误 if err != nil { return nil, err } // 检查打开文件的标志是否包含 O_APPEND，如果包含，设置 f.appendMode 为 true f.appendMode = flag\u0026amp;O_APPEND != 0 // 返回打开的文件 return f, nil } 关闭文件 1 2 3 4 #include \u0026lt;unistd.h\u0026gt; int close(int fd); //成功时返回Q,失败时返回-1。 //fd:需要关闭的文件或套接字的文件描述符 1 2 3 4 5 6 7 8 9 10 // Close closes the File, rendering it unusable for I/O. // On files that support SetDeadline, any pending I/O operations will // be canceled and return immediately with an ErrClosed error. // Close will return an error if it has already been called. func (f *File) Close() error { if f == nil { return ErrInvalid } return f.file.close() } 将数据写入文件 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t write(int fd, const void * buf, size_t nbytes); //成功时返回写入的字节数,失败时返回-1。 //fd:数据传输对象的文件描述符 //buf 保存数据的缓冲地址 //nbytes：要传输的字节数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // write writes len(b) bytes to the File. // It returns the number of bytes written and an error, if any. // write 是 File 结构体的一个方法，它接受一个字节切片 b 作为参数， // 尝试将这个字节切片写入到文件中。 func (f *File) write(b []byte) (n int, err error) { // f.pfd.Write(b) 调用 pfd（代表平台依赖的文件描述符）的 Write 方法， // 尝试将 b 写入到文件。这个方法返回写入的字节数和一个错误（如果有的话）。 n, err = f.pfd.Write(b) // runtime.KeepAlive(f) 是一个用于防止 f 被垃圾回收的调用。 // 在某些情况下，如果 f 在 f.pfd.Write(b) 调用之后没有被再次使用， // Go 的垃圾回收器可能会在 Write 调用还在进行时就回收 f。 // runtime.KeepAlive(f) 确保 f 在 Write 调用完成之前不会被垃圾回收。 runtime.KeepAlive(f) // 返回写入的字节数和错误（如果有的话） return n, err } 代码示例改写 low_open.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { buf := []byte(\u0026#34;Let\u0026#39;s go!\\n\u0026#34;) //打开文件，如果不存在则创建，如果存在则清空，权限为 0644 f, err := os.OpenFile(\u0026#34;data.txt\u0026#34;, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //写入文件 _, err = f.Write(buf) if err != nil { log.Fatalf(\u0026#34;write() error: %v\u0026#34;, err) } } 运行代码\n1 2 3 go build -o ch1/low_open ch1/lowOpen/low_open.go ./ch1/low_open file descriptor: 3 读取数据 1 2 3 4 5 6 #include \u0026lt;unistd.h\u0026gt; ssize_t read(int fdJ void * buf, size_t nbytes); //\u0026#39;成功时返回接收的字节数(但遇到文件结尾则返回θ),失败时返回10 //fd 显示数据接收对象的文件描述符。 //buf 要保存接收数据的缓冲地址值。 //nbytes 要接收数据的最大字节数。 示例代码改写 low_read.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { //只读打开文件 f, err := os.Open(\u0026#34;data.txt\u0026#34;) if err != nil { log.Fatalf(\u0026#34;open() error: %v\u0026#34;, err) } defer f.Close() //输出文件描述符 log.Printf(\u0026#34;file descriptor: %d \\n\u0026#34;, f.Fd()) //读取文件 buf := make([]byte, 1024) n, err := f.Read(buf) if err != nil { log.Fatalf(\u0026#34;read() error: %v\u0026#34;, err) } log.Printf(\u0026#34;file data: %s\u0026#34;, buf[:n]) } 运行代码\n1 2 3 4 5 go build -o ch1/low_read ch1/lowRead/low_read.go ./ch1/low_read 2023/11/10 16:45:54 file descriptor: 3 2023/11/10 16:45:54 file data: Let\u0026#39;s go! 文件描述符与套接字 原文c代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; int main() { int fd1, fd2, fd3; //创建一个文件和两个套接字 fd1 = socket(PF_INET, SOCK_STREAM, 0); fd2 = open(\u0026#34;test.dat\u0026#34;, O_CREAT | O_WRONLY | O_TRUNC); fd3 = socket(PF_INET, SOCK_DGRAM, 0); //输出之前创建的文件描述符的整数值 printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1); printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2); printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3); close(fd1); close(fd2); close(fd3); return 0; } 改写后 fd_seri.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { // 使用 syscall.Socket 函数创建一个 TCP 套接字，返回的是文件描述符 fd1 fd1, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) // 使用 os.OpenFile 函数创建一个文件 \u0026#34;test.dat\u0026#34;，返回的是 *os.File 类型的 fd2 fd2, _ := os.OpenFile(\u0026#34;test.dat\u0026#34;, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) // 使用 syscall.Socket 函数创建一个 UDP 套接字，返回的是文件描述符 fd3 fd3, _ := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, 0) // 使用 fmt.Printf 函数打印出三个文件描述符的值 // 注意，对于 *os.File 类型的 fd2，我们使用了 Fd 方法来获取其底层的文件描述符 fmt.Printf(\u0026#34;file descriptor 1: %d\\n\u0026#34;, fd1) fmt.Printf(\u0026#34;file descriptor 2: %d\\n\u0026#34;, fd2.Fd()) fmt.Printf(\u0026#34;file descriptor 3: %d\\n\u0026#34;, fd3) // 使用 Close 方法和 syscall.Close 函数关闭了这三个文件描述符，以释放系统资源 fd2.Close() syscall.Close(fd1) syscall.Close(fd3) } 运行\n1 2 3 4 5 go build -o ch1/fd_seri ch1/fdSeri/fd_seri.go ./ch1/fd_seri file descriptor 1: 3 file descriptor 2: 4 file descriptor 3: 5 1.3 基于Windows平台的实现 略\n1.4 基于Windows的套接字相关函数及示例 1.5 习题 套接字在网络编程中的作用是什么?为何称它为套接字? 套接字（socket）是网络编程中的抽象概念，它提供了一种机制，使得不同计算机之间可以进行通信和数据交换。套接字可以看作是网络通信的端点，它包含了通信所需的各种信息，如IP地址、端口号、协议等。套接字的名称来源于插座（socket），类比插座连接电器，套接字连接网络。通过套接字，计算机可以在网络上进行数据的发送和接收，实现网络通信的功能。\n在服务器端创建套接字后,会依次调用listen函数和accept 函数。请比较并说明二者作用。 listen函数用于将套接字标记为被动套接字，即用于接受客户端的连接请求。它告诉操作系统该套接字将用于接受传入的连接，而不是发起连接。在调用listen函数后，套接字将进入监听状态，等待客户端的连接请求。 accept函数用于从处于监听状态的套接字中接受一个连接。当客户端尝试连接到服务器时，服务器调用accept函数来接受这个连接，并创建一个新的套接字来与客户端进行通信。这个新的套接字可以用于与该客户端进行数据交换，而原始的监听套接字则继续等待其他客户端的连接请求。accept函数的返回值是一个新的套接字，通过它可以进行与客户端的通信。\nLinux中,对套接字数据进行I/O时可以直接使用文件I/O 相关函数;而在Windows中则不可以。原因为何? 这是因为在Linux中，套接字被视为一种文件描述符，因此可以使用文件I/O相关函数（如read和write）来进行I/O操作。而在Windows中，套接字和文件描述符是不同的概念，Windows采用了不同的I/O模型，因此不能直接使用文件I/O相关函数来对套接字数据进行I/O操作。在Windows中，需要使用特定的套接字I/O函数（如recv和send）来进行套接字数据的读写操作。\n创建套接字后一般会给它分配地址,为什么?为了完成地址分配需要调用哪个函数 创建套接字后需要给它分配地址，这是为了让其他主机能够找到并与该套接字进行通信。在网络编程中，这个地址通常是IP地址和端口号的组合。 为了完成地址分配，需要调用bind函数。bind函数将一个本地地址（IP地址和端口号）分配给套接字，使得其他主机可以通过这个地址与该套接字进行通信。\nLinux中的文件描述符与Windows的句柄实际上非常类似。请以套接字为对象说明它们的含义。 文件描述符和Windows的句柄在套接字的上下文中具有类似的含义。它们都是用来标识和引用套接字的抽象概念。 在Linux中，套接字也被视为一种文件描述符，因此可以使用类似于文件I/O的操作来进行套接字的读写等操作。 在Windows中，套接字使用句柄来进行引用和操作，句柄是一种抽象的引用类型，可以用来标识和操作套接字。 因此，无论是文件描述符还是句柄，它们都是用来引用和操作套接字这种抽象对象的标识符。\n底层文件I/O函数与ANSI 标准定义的文件I/O函数之间有何区别? 底层文件I/O函数是直接调用操作系统提供的文件操作接口，如open、read、write等，它们提供了对文件的低级别访问，可以更加灵活地控制文件的读写操作。 而ANSI标准定义的文件I/O函数则是标准C库中提供的一组文件操作函数，如fopen、fread、fwrite等，它们提供了更加抽象和便捷的文件操作接口，使得跨平台开发更加方便，并且提供了一些缓冲和错误处理的功能。 因此，底层文件I/O函数更加接近操作系统提供的文件操作接口，而ANSI标准定义的文件I/O函数则提供了更加便捷和跨平台的文件操作接口。\n参考本书给出的示例low_open.c 和low_read.c ,分别利用底层文件I/O 和ANSI标准I/O 编写文件复制程序。可任意指定复制程序的使用方法。\n","date":"2023-11-11T12:47:47+08:00","permalink":"https://anonymity-0.github.io/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/","title":"TCP、IP网络编程第一章笔记"},{"content":"尝试学习一下vim\nvim模式切换 normal转insert i 光标前插入 I行首插入 o进入下一行输入 O上一行插入 a光标之后输入 A行末尾插入\ninsert 转normal esc/jj 变回普通模式\nnormal转visual v变成可视模式（无法编辑）\nvisual转nomal esc或者v变回普通模式\n普通模式转命令模式 ：转成命令模式\n命令模式转普通模式 esc\n光标移动 普通模式下光标移动 动作 motion 操作符 删除全部 die 复制全部 yie u 撤销\n大小写 常用 gd 查看函数定义 ^O返回 g数字 切换标签/ctrl+数字 command+0 到文件夹 o打开 回车修改名字\neasymotion 空格空格s + 要查询的字幕 空格空格+e 空格空格+w\nvim surround 光标转移到终端 leader + t\n切换tab gt或gT\n","date":"2023-11-10T12:43:42+08:00","permalink":"https://anonymity-0.github.io/posts/vim/","title":"Vim"},{"content":"实验内容 arp 在 HostA 和 HostB 中分别打开一个终端用于本实验。\n在 HostA 和 HostB 中分别执行命令ifconfig ens5，查看并记录它们各自的IPv4 地址。执行命令 ifconfig ens6 查看 IPv6 地址 (global 和 link 两种) 以及以太网接口的物理地址。 截图： 命令解释： ifconfig 是一个用于配置和显示网络接口信息的命令。ens5 和 ens6 是网络接口的名称，通常用于表示以太网接口。ifconfig ens5 命令用于显示名为 ens5 的网络接口的配置信息，包括 IP 地址、子网掩码、广播地址、MAC 地址等。\n在 HostA 中执行命令 arp -n 或ip neigh show 查看并记录本机 ARP 缓存表的内容。\n命令解释： arp -n 是一个用于查看本地ARP缓存表的命令。它会显示已解析的IP地址和对应的MAC地址。 ip neigh show 是一个用于查看本地邻居表的命令。它会显示已解析的IP地址和对应的MAC地址，类似于 arp -n 命令。 arp -n 和 ip neigh show 都是用于查看本地ARP缓存表或邻居表的命令，它们的功能相似但有一些区别。\n命令格式不同：arp -n 是在大多数操作系统中使用的命令，而 ip neigh show 是在基于 Linux 的操作系统中使用的命令。 输出格式不同：arp -n 输出的结果通常是以表格形式显示的，包括IP地址和对应的MAC地址。而 ip neigh show 输出的结果可能更详细，包括IP地址、MAC地址、接口、状态等信息。 支持的功能不同：ip neigh show 命令在功能上更加强大，可以显示更多关于邻居的信息，如状态、接口类型等。而 arp -n 命令通常只显示基本的IP地址和MAC地址信息。 截图： 在 HostA 中执行命令 ping -c 1 HostB 的 IPv4 地址向 HostB 发送 ICMP 请求报文。收到 ICMP 响应后再次执行命令 arp -n 或ip neigh show 查看 HostA的 ARP 缓存表的内容。\n命令解释 ping -c 1 HostB 是一个用于向 HostB 发送一个 ICMP 回显请求（ping）的命令。其中，-c 1 表示只发送一次请求。\n截图 在 HostA 的 ARP 缓存表里面可获得 HostB 的 MAC 地址，记录下来，检查与 HostB 上ifconfig ens5 命令的执行结果是否一致。 与 HostB 上ifconfig ens5 命令的执行结果一致\n在 HostA 中执行命令ping -c 1 202.38.64.246，收到 ICMP 响应后继续执行命令ip neigh show 查看 HostA 的 ARP 缓存表，记录结果。简要解释为何无法看到对应于地址 202.38.64.246 的 ARP 表项而只能得到网关的某网卡的MAC 地址。提示：思考网段(链路)、广播域的概念。\n截图： 解释： 这是因为，ARP 协议用于在同一网段内查找主机的 MAC 地址。当 HostA 发送 ICMP 请求到目标地址 202.38.64.246 时，目标地址不在 HostA 的网段内，因此 HostA 需要向网关发送广播 ARP 请求。网关收到广播 ARP 请求后，会将自己的 MAC 地址回复给 HostA。HostA 收到网关的回复后，将网关的 MAC 地址存储在 ARP 缓存表中。因此，HostA 无法看到对应于地址 202.38.64.246 的 ARP 表项。\nIP 分别用命令 route -n 和命令route \u0026ndash;inet6 查看本机的 IPv4 和 IPv6 路由配置，记录所在子网的子网掩码/前缀长度，并于前面 ifconfig 的结果作比较。\n命令解释 route -n 是一个用于显示 IPv4 路由表的命令。它会列出系统中当前配置的所有 IPv4 路由项，包括目的网络、网关、子网掩码、接口和路由标志等信息。该命令中的 -n 选项表示以数字形式显示 IP 地址和子网掩码，而不进行主机名和网络地址的解析。 route --inet6 是一个用于显示 IPv6 路由表的命令。它会列出系统中当前配置的所有 IPv6 路由项，包括目的网络、网关、前缀长度、接口和路由标志等信息。该命令中的 --inet6 选项表示只显示 IPv6 路由表的信息。 截图： ![[Pasted image 20231106202048.png]] 比较两者的结果，可以看到，IPv4 和 IPv6 路由表中的子网掩码/前缀长度均与ifconfig的结果一致。\n执行以下两个命令分别查看系统内核的 IPv4 和 IPv6 的 FORWARD 值，记录下来。简单解释这个值的含义以及为何这个值是这样设定的。提示：思考主机与路由器的区别。\n命令 1：cat /proc/sys/net/ipv4/ip_forward 命令 2：cat /proc/sys/net/ipv6/conf/all/forwarding\n命令解释： 命令1：cat /proc/sys/net/ipv4/ip_forward 用于查看 IPv4 转发功能的状态。在 Linux 系统中，如果该值为 1，则表示启用了 IPv4 转发功能，即允许将数据包从一个网络接口转发到另一个网络接口。 命令2：cat /proc/sys/net/ipv6/conf/all/forwarding 用于查看 IPv6 转发功能的状态。类似于 IPv4，如果该值为 1，则表示启用了 IPv6 转发功能，允许将数据包从一个 IPv6 网络接口转发到另一个 IPv6 网络接口。\n截图： 解释： 可以看到，系统内核的 IPv4 和 IPv6 的 FORWARD 值均为 0。FORWARD 值的含义是是否允许系统转发 IP 数据包。如果 FORWARD 值为 0，则系统不允许转发 IP 数据包。主机和路由器的区别在于，主机只能与同一子网内的主机通信，而路由器可以连接多个子网，并负责将数据包从一个子网转发到另一个子网。由于主机只能与同一子网内的主机通信，因此不需要转发 IP 数据包。因此，主机的 FORWARD 值通常为 0。\nTCP 在 S 的终端 1 中执行 nc -l 1958 侦听1958 端口。。 命令解释： 命令 nc -l 1958 将在 TCP 端口 1958 上监听传入连接\nnc：netcat 命令 -l：监听传入连接 1958：端口号 截图： 在HostA 的终端 1 执行nc S 的IPv4 地址 1958\n截图： 在HostA 终端 2 中执行命令netstat -aunt 来观察自己主机上的所有 TCP 与UDP 连接状况，将输出的信息记录下来。请在上述记录的结果中找到对应于上述连接的那条记录并解释这条记录的含义。\n命令解释： 执行 netstat -aunt 命令可以查看当前系统上所有的网络连接和监听端口，以及它们的状态、协议类型、本地地址和远程地址等信息 截图： 这条记录表示，HostA 主机的60260端口与 S 主机的 1958 端口建立了 TCP 连接。\n执行命令 nc S 的 IPv4 地址 100，记录命令执行结果。同样使用 netstat -aunt 来查看本机的连接状况，请判断这次 telnet 连接是否成功建立并简单说明原因。 原因是 100 端口是 telnet 服务器的默认端口，但 S 主机没有在 100 端口上监听 telnet 连接。因此，HostA 主机无法与 S 主机建立 telnet 连接。\n思考题 现在有一个网段的 IP 地址和子网掩码分别为202.38.75.0/255.255.255.192，请计算该网段中一共有多少个全局 IPv4 地址可供主机使用，或者说这个网络中有多少真正可分配的 IP 地址？\n子网掩码 255.255.255.192 的二进制表示为 11111111 11111111 11111111 11000000，其中前 24 位为 1，表示该网段的网络地址部分，后 8 位为 0，表示该网段的广播地址部分。因此，该网段中一共有 2^6 - 2 = 62 个全局 IPv4 地址可供主机使用。\n实验中执行 ifconfig ens3 查看接口的配置信息时可以观察到一个重要的参数MTU，请问这个值是多少？查询资料说明 MTU 参数的用途。\nMTU 是最大传输单元（Maximum Transmission Unit）的缩写，指的是网络层协议所能通过的最大数据包大小。MTU 的值通常与通信接口有关（网络接口卡、串口等）。 MTU 的值通常以字节为单位，常见的默认值是 1500 字节。这是因为以太网是最常见的网络类型，而以太网的标准帧大小为 1518 字节（包括帧头和帧尾），减去以太网帧头的 18 字节，剩下的 1500 字节就是可用于数据传输的最大数据量。 当数据包的大小超过 MTU 值时，网络层协议会将数据包分片，将数据包拆分成多个小数据包，然后分别传输。分片会增加网络层协议的复杂度，并降低网络效率。因此，在实际应用中，需要根据网络环境调整 MTU 参数的值，以保证数据包能够正常传输，并提高网络效率。\n9. IPv6 地址长度是 IPv4 地址长度的 4 倍，不过在今后的纯 IPv6 网络环境中路由器的 路由表的规模反而有望减小，请简单解释这是为什么？\n在纯 IPv6 网络环境中，路由器的路由表规模有望减小的原因： 1. IPv6 支持路由重叠，即多个路由器可以指向同一个目标地址。这意味着 IPv6 路由器可以共享路由信息，从而减少路由条目的数量。 2. IPv6 路由表结构更加简化。IPv6 路由表采用了扁平化的结构，每个路由表项只需要存储一个目标地址和下一跳地址即可。而 IPv4 路由表采用了分层的结构，每个路由表项还需要存储一个前缀长度和子网掩码。 3. IPv6没有私有地址和NAT技术,减少了路由表中的条目。 4. IPv6 支持动态路由，即路由器可以自动学习到目标地址的路由信息。这意味着 IPv6 路由器不需要手动配置路由条目，从而减少路由条目的数量。 一条 TCP 连接需要哪几个参数标识？\n一条 TCP 连接需要四个参数来标识，即：\n本地 IP 地址：表示连接的本地主机的 IP 地址。 本地端口号：表示连接的本地主机的端口号。 远程 IP 地址：表示连接的远程主机的 IP 地址。 远程端口号：表示连接的远程主机的端口号。 ","date":"2023-11-07T12:46:21+08:00","permalink":"https://anonymity-0.github.io/posts/%E4%BF%A1%E7%BD%91%E5%AE%9E%E9%AA%8C1/","title":"信网实验1"},{"content":" 简述防火墙的定义 防火墙是位于两个(或多个)网络之间执行访问控制的软件和硬件系统，它根据访问控制规则对进出网络的数据流进行过滤。\n防火墙对数据流的拒绝和丢弃有何区别?\n当数据流被拒绝时，防火墙要向发送者回复一条消息，用ICMP包告知数据源数据包被拒绝的原因，提示发送者该数据流已被拒绝。 当数据流被丢弃时，防火墙不会对这些数据包进行任何处理，也不会向发送者发送任何提示信息。丢弃数据包的做法加长了网络扫描所花费的时间，发送者只能等待回应直至通信超时。 简述数据包过滤器和状态防火墙。\n数据包过滤器通过数据包的头部信息来判断是接受还是拒绝数据包，它并不查看数据包载荷中的应用数据。这种防火墙检查流经它的每个数据包，根据数据包本身所带的信息决定它的去留，而不用参考其他数据包的内容。 状态防火墙会通过对流经的数据包的分析查找通信中的数据流，根据数据流的信息来帮助判断是否让数据包通行。数据流提供了数据包的上下文。状态防火墙有时还会检测一些常用协议的应用数据（虽然可以检测的数据量是有限的），通过这些数据来识别和跟踪相关的数据流。 与包过滤防火墙相比，应用代理防火墙有哪些特点？\n在已有的安全模型中安全性较高。 具有强大的认证功能。 具有超强的日志功能。 应用级网关防火墙的规则配置比较简单 在防火墙的典型部署中，堡垒主机是一个组织机构网络安全的中心主机，它应该具备哪些主要特征？\n堡垒主机硬件平台运行较为安全的操作系统，成为可信任的系统。 只有网络管理员认为必要的服务(代理和用户认证等)才会安装在堡垒主机上。 当允许一个用户访问代理服务时，堡垒主机可能会要求进行额外认证。另外，每一个代理服务都可能需要相应的鉴别机制(Authentication) 每一个代理都只能支持标准应用服务命令集中的一个子集。 每一个代理只允许访问指定主机的通信，支持对通信进行详细的审计。 每一个代理模块都是一个为网络安全设计的一个很小的软件包。 代理之间相互独立。 代理通常无需进行磁盘访问，不需要读取初始配置文件。这使得入侵者很难在主机上安装Trojan horse、sniffers或其他危险的文件。 堡垒主机是一个组织机构网络安全的中心主机。 ","date":"2023-10-26T10:17:18+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A3/","title":"网络安全作业3"},{"content":"第一章 1. 如果你的网络服务器被黑客远程控制，列举3个可能被破坏的安全属性， 并解释理由。 机密性： 理由：远程控制服务器后，黑客可以在未被授权的情况下获取个人信息、数据库记录等数据，导致数据泄露和隐私侵犯。 完整性： 理由：黑客远程服务器后，可以篡改服务器上的数据或者程序文件，修改网站内容、更改配置文件、插入恶意代码等。 可用性： 理由：黑客可能通过远程控制服务器发动拒绝服务攻击或直接禁用服务器上的关键服务和功能，导致服务器无法正常运行。 不可抵赖性： 理由：黑客可以使用服务器的访问权限执行恶意操作如数据篡改。如果服务器没有足够的安全措施来记录这些操作并确保其不可抵赖性，那么黑客可能会否认曾经执行过这些操作，导致难以追踪和证明责任。\n2. 简述RFC2828安全服务的定义，例举Windows10系统的3种安全服务。\nRFC2828定义了安全服务为一种由系统提供的对系统资源进行特殊保护的处理或通信服务，安全服务通过安全机制来实现安全策略。ITU-T（即X.800）定义了五种服务：身份认证、访问控制、数据保密、数据完整性、不可否认。 Windows 10操作系统中的三种安全服务：\n认证服务：认证服务用于验证用户的身份，确保只有经过授权的用户能够访问系统或资源。在Windows 10中，用户必须提供正确的用户名和密码才能登录到系统。 访问控制服务：访问控制服务用于确定哪些用户或实体具有权限访问特定资源或执行特定操作，并确保未经授权的访问被拒绝。在Windows 10中，访问控制服务管理文件和文件夹的权限，以及系统资源的访问权限。 加密服务：加密服务用于将敏感数据转化为不可读的格式，以确保即使数据被未经授权的访问者获取，也无法理解其内容。只有具有正确密钥的用户才能解密数据。BitLocker是一个Windows 10中的工具，它可以加密整个硬盘或者某些部分，以保护数据免受丢失或盗取的威胁。 3 . 简述网络安全防护主要目标的“五不”。 1. 不泄露（Non-Disclosure）：确保网络中的敏感信息和数据不会泄露给未经授权的用户或系统。 2. 不破坏（Non-Destruction）：防止网络系统和数据被破坏、损坏或篡改。 3. 不拒绝（Non-Repudiation）：确保在网络交互中的各种操作和交易都可以被证明，不容易被否认。 4. 不中断（Non-Interruption）：确保网络服务的持续可用性，防止由于攻击、故障或其他原因导致的网络服务中断。 5. 不迟滞（Non-Delay）：保障网络通信的实时性，防止因网络拥塞、延迟或其他问题导致通信延迟。\n第三章 1. 在腾讯会议系统中，对称密码技术和公钥密码技术适合应用在哪几个阶段?说明理由。\n会话加密阶段：对称密码技术非常适合在会话加密阶段使用。一旦参与会议的用户建立了安全连接，可以使用对称加密算法来加密和解密数据通信。这是因为对称密码技术具有较高的加密和解密速度，使其非常适合对大量的音视频数据进行快速的加密和解密操作。\n登录时身份验证和密钥交换阶段：公钥密码技术通常用于安全地进行身份验证和密钥交换。在腾讯会议系统中，当用户首次登录时，可以使用公钥密码技术来验证其身份，并协商用于对称加密的会话密钥。\n2. 简述散列函数MD5的碰撞问题。既然MD5存在碰撞问题，为何http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/ 仍然给出MD5值作为完整性验证的依据。 MD5的碰撞问题是指两个不同的输入数据在经过MD5算法处理后，得到了相同的散列值。这种情况被称为碰撞。 至于为什么仍然给出MD5值作为完整性验证的依据，可能是因为MD5是一个相对快速的散列函数，适用于快速验证大量文件的完整性。发行盘之后的系统安装和软件安装也有额外的安全验证程序。\n3. 简述用RSA公钥算法实现数字签名的过程。（这个问题回答的不好） 数字签名过程如下： 1. 发送者使用自己的私钥对消息进行加密，生成数字签名。 2. 发送者将消息和数字签名一起发送给接收者。 3. 接收者使用发送者的公钥对数字签名进行解密，得到消息的摘要。 4. 接收者使用相同的摘要算法对消息进行摘要处理，得到摘要。 5. 接收者比较两个摘要是否相同，如果相同，则说明消息没有被篡改过。\n4. 用PGP加密某个文件，如果接收该加密文件的用户为1个，加密文件的大小为24kB；如果接收该加密文件的用户 为10个，请问加密文件的大小是原来的10倍(240kB)吗？为什么？ 答：加密文件的大小不会是原来的10倍，由于对称密钥是相对较短的，每个接收者的非对称密钥通常很小。因此，无论接收者数量是1个还是10个，对称密钥密文的总大小都不会显著增加，而文件内容加密只需一次，因此文件大小仍然是原始文件大小（24kB）加上对称密钥密文的大小的总和，而不会变成原来的10倍。\n","date":"2023-10-26T10:17:13+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BD%9C%E4%B8%9A1/","title":"网络安全作业1"},{"content":"网络安全实验配置 由于Mac的m系列芯片使用了arm架构与windows server镜像要求的x86架构不同，老师使用的virtual box和mac最常用的pd模拟器均只能进行同架构系统的模拟。于是乎我又查阅了资料，发现UTM可以在mac上进行不同架构的模拟（虽然很卡也很难用，终归是跑通了），以下是我的配置过程\nUTM下载和安装 直接官网UTM | Virtual machines for Mac下载并安装就好。\nwindows server镜像下载 这时候又出岔子了，老师提供的windows 2003不知道是不是太老了，UTM模拟不了。只能想办法换更新的windows sever2012 下载镜像地址：HelloWindows.cn - 精校 完整 极致 Windows系统下载仓储站 注：需下载迅雷进行磁力链下载\nwireshark的安装 直接官网Wireshark · Go Deep下载安装就好\nUTM和本地文件的共享 待补充\n终于是能在mac上跑实验了，类目。\nUTM下复制的主机互ping问题 本来像按照老师所给的内容配置了七个host-only网络，网络是可以搭建起来的，但是server和client两个虚拟机之间无法互ping。 查阅了很多资料之后发现得设置成桥接模式，并把接口设置成en0即可。如图： ","date":"2023-10-26T10:15:50+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE/","title":"网络安全实验配置"},{"content":"网络层 IP 即网际协议TCP/IP 的心脏是互联网层。这一层主要由 IP (Internet Protocol)和 ICMP (Internet Control Message Protocol)两个协议组成。 网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点(end-to-end)通信”。\n主机和节点 主机的定义应该是指“配置有I地址,但是不进行路由控制”的设备”。既配有IP地址又具有路由控制能力的设备叫做“路由器”,跟主机有所区别。而节点则是主机和路由器的统称。\nIP基础知识 IP地址 IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址” 不论一台主机与哪种数据链路连接,其IP地址的形式都保持不变。以太网、无线局域网、PPP 等,都不会改变IP地址的形式。 而数据链路的MAC地址的形式不一定必须一致。\n在网桥或交换集线器等物理层或数据链路层数据包转发设备中,不需要设置IP地址”。因为这些设备只负责将IP 包转化为0、1 比特流转发或对数据链路帧的数据部分进行转发,而不需要应对IP 协议”\n路由控制 路由控制(Routing)是指将分组数据发送到最终目标地址的功能。 Hop 译为中文叫“跳”。它是指网络中的一个区间。 一跳(1Hop)是指利用数据链路层以下分层的功能传输数据帧的一个区间。 以太网等数据链路中使用 MAC地址传输数据帧。此时的一跳是指从源MAC地址到目标MAC地址之间传输帧的区间。也就是说它是主机或路由器网卡不经其他路由器而能直接到达的相邻主机或路由器网卡之间的一个区间。\n多跳路由 IP 包正是在网络中一个个跳间被转发。因此 IP路由也叫做多跳路由。在每一个区间内决定着包在下一跳被转发的路径。 多跳路由是指路由器或主机在转发IP 数据包时只指定下一个路由器或主机, 而不是将到最终目标地址为止的所有通路全都指定出来。因为每一个区间(跳) 在转发 IP数据包时会分别指定下一跳的操作,直至包达到最终的目标地址。\n路由控制表 为了将数据包发给目标主机,所有主机都维护着一张路由控制表(Routing Table)。该表记录IP 数据在下一步应该发给哪个路由器。IP包将根据这个路由表在各个数据链路上传输。 数据链路的抽象化 IP 是实现多个数据链路之间通信的协议，对IP的上一层来说,不论底层数据链路使用以太网还是无线LAN 亦或是PPP,都将被一视同仁。\n不同数据链路有个最大的区别,就是它们各自的最大传输单位(MTU:Maximum Transmission Unit)不同。\nMTU 的值在以太网中是1500字节,在FDDI 中是4352字节,而ATM则为9180字节。IP 的上一层可能会要求传送比这些 MTU 更多字节的数据,因此必须在线路上传送比包长还要小的MTU。\n为了解决这个问题,IP 进行分片处理(IP Fragmentation)。顾名思义,所谓分片处理是指,将较大的IP 包分成多个较小的IP 包”即从 IP 的上次层看,它完全可以忽略数据包在途中的各个数据链路上的MTU,而只需要按照源地址发送的长度接收数据包。 IP 就是以这种方式抽象化了数据链路层,使得从上层更不容易看到底层网络构造的细节。\n面向无连接 IP 面向无连接。即在发包之前,不需要建立与对端目标地址之间的连接。上层如果遇到需要发送给IP 的数据,该数据会立即被压缩成 IP包发送出去。\n那么,为什么IP 要采用面向无连接呢? 主要有两点原因:一是为了简化,二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外,每次通信之前都要事先建立连接,又会降低处理速度。需要有连接时,可以委托上一层提供此项服务。因此,IP 为了实现简单化与高速化采用面向无连接的方式。 IP 提供尽力服务(Best Effort),意指“为了把数据包发送到最终目标地址,尽最大努力。”然而,它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。\n那么,有人可能会提出疑问:为什么不让IP 具有可靠传输的功能, 从而把这两种协议合并到一起呢?\n这其中的缘由就在于,如果要一种协议规定所有的功能和作用,那么该协议的具体实施和编程就会变得非常复杂,无法轻易实现。相比之下,按照网络分层,明确定义每层协议的作用和责任以后,针对每层具体的协议进行编程会更加有利于该协议的实现。 网络通信中如果能进行有效分层,就可以明确 TCP 与IP 各自协议的最终目的,也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。\nIPv4 IP 地址(IPv4 地址)由32位正整数来表示，将32位的IP地址以每8位为一组,分成4组,每组以“.”隔开,再将每组数转换为十进制数”\n实际上,IP地址并非是根据主机台数来配置的,而是每一台主机上的每一块网卡(NIC)都得设置IP 地址”。通常一块网卡只设置一个 IP 地址,其实一块网卡也可以配置多个 IP 地址。此外,一台路由器通常都会配置两个以上的网卡,因此可以设置两个以上的IP地址。 IP 地址由“网络标识(网络地址)”和“主机标识(主机地址)”两部分组成”\n网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP地址的“主机标识”则不允许在同一个网段内重复出现。\n究竞从第几位开始到第几位算是网络标识,又从第几位开始到第几位算是主机标识呢?关于这点,有约定俗成的两种类型。最初二者以分类进行区别。而现在基本以子网掩码(网络前缀)区分。 IP地址的分类 IP 地址分为四个级别,分别为A类、B类、C类、D类”。它根据 IP 地址中从第1位到第4位的比特列对其网络标识和主机标识进行区分。 关于分配IP 主机地址的注意事项 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时,不可以全部为0或全部为1。因为全部为只有。在表示对应的网络地址或IP 地址不可获知的情况下才使用。而全部为1的主机地址通常作为广播地址。\n广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据的目的主机地址部分全部设置为1,就成为了广播地址。\n以太网中如果将 MAC地址的所有位都改为1,则形成FF:FF: FF: FF: FF: FF 的广播地址。因此, 广播的IP包以数据链路的帧的形式发送时,得通过 MAC 地址为全 1 比特的 FF:FF: FF: FF: FF: FF转发。\n本地广播 在本网络内的广播叫做本地广播。例如网络地址为192.168.0.0/24 的情况下,广播地址是192.168.0.255。因为这个广播地址的 IP包会被路由器屏蔽,所以不会到达192.168.0.0/24 以外的其他链路上。\n直接广播 在不同网络之 的广播叫做直接广播。例如网络地址为192.168.0.0/24的主机向 192.168.1.255/24 的目标地址发送IP 包。收到这个包的路由器,将数据转发给192.168.1.0/24,从而使得所有192.168.1.1~ 192. 168.1.254 的主机都能收到这个包”\nIP多播 多播用于将包发送给特定组内的所有主机。由于其直接使用IP 协议,因此也不存在可靠传输。 多播使用D类地址。因此,如果从首位开始到第4位是“1110”,就可以认为是多播地址。而剩下的28 位可以成为多播的组编号。 从224.0.0.0到 239.255.255.255 都是多播地址的可用范围。其中从224.0.0.0到224.0.0.255 的范围不需要路由控制,在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。\n利用IP多播实现通信,除了地址外还需要IGMP\u0026rsquo;等协议的支持。 子网掩码 例： A类 255.0.0.0 B类255.255.0.0 C类 255.255.255.0\n网络标识相同的计算机必须同属于同一个链路。例如,架构B类IP 网络时, 理论上一个链路内允许6万5千多台计算机连接。然而,在实际网络架构当中, 一般不会有在同一个链路上连接6万5千多台计算机的情况。因此,这种网络结构实际上是不存在的。\n因此,直接使用A类或B类地址,确实有些浪费。随着互联网的覆盖范围逐渐增大,网络地址会越来越不足以应对需求,直接使用A类、B类、C类地址就更加显得浪费资源。为此,人们已经开始一种新的组合方式以减少这种浪费。\n对于子网掩码,目前有两种表示方式。以172.20.100.52的前26位是网络地址的情况为例,以下是其中一种表示方法,它将IP地址与子网掩码的地址分别用两行来表示。 另一种表示方式如下所示。它在每个 IP 地址后面追加网络地址的位数”用“/”隔开 CIDR 采用任意长度分割 IP 地址的网络标识和主机标识。这种方式叫做CIDR 根据 CIDR,连续多个C类地址”就可以划分到一个较大的网络内。CIDR 更有效地利用了当前 IPv4地址,同时通过路由集中“降低了路由器的负担。 VLSM 在CIDR被应用到互联网的初期,网络内部采用固定长度的子网掩码机制。也就是说,当子网掩码的长度被设置为/25以后,域内所有的子网掩码都得使用同样的长度。然而,有些部门可能有500台主机,另一些部门可能只有50台主机。如果全部采用统一标准,就难以架构一个高效的网络结构。为此人们提出组织内要使用可变长度的、高效的IP地址分配方式。\n于是产生了一种可以随机修改组织内各个部门的子网掩码长度的机制VLSM(可变长子网掩码)。它可以通过域间路由协议转换为 RIP2 以及 OSPF实现。根据 VLSM 可以将网络地址划分为主机数为500个时子网掩码长度为/23,主机数为50个时子网掩码长度为/26。\n有了 CIDR 和 VLSM技术,确实相对缓解了全局IP地址不够用的问题。但是IP 地址的绝对数本身有限的事实无法改变。\n全局地址与私有地址 出现了一种新技术。它不要求为每一台主机或路由器分配一个固定的IP 地址,而是在必要的时候只为相应数量的设备分配唯一的IP地址。 尤其对于那些没有连接互联网的独立网络中的主机,只要保证在这个网络内地址唯一,可以不用考虑互联网即可配置相应的IP地址。\n私有网络的IP 地址。它的地址范围如下所示: A类~C类范围中除去0/8、127/8。 包含在这个范围内的IP地址都属于私有 IP,而在此之外”的IP地址称为全局IP。 全局 IP地址基本上要在整个互联网范围内保持唯一\u0026rsquo;,但私有地址不需要。只要在同一个域里保证唯一即可。在不同的域里出现相同的私有IP 不会影响使用。\n在世界范围内,全局 IP 由ICANN\u0026lsquo;进行管理。对于 FTTH 和 ADSL 的服务,网络提供商直接给用户分配全局 IP地址,并且用户每次重连该IP地址都可能会发生变化。这时的IP 地址由提供商维护,不需要用户亲自申请全局 IP 地址。\n不过现在,普遍采用的一种方式是,在LAN 中设置私有地址,通过少数设置全局IP 地址的代理服务器结合 NAT的设置进行互联网通信。这时 IP地址个数就不限于LAN 中主机个数而是由代理服务器和 NAT的个数决定。\nNAT 私有IP 最早没有计划连接互联网,而只用于互联网之外的独立网络。然而, 当一种能够互换私有 IP 与全局IP 的NAT\u0026rsquo;技术诞生以后,配有私有地址的主机与配有全局地址的互联网主机实现了通信。 私有IP 地址结合NAT技术已成为现在解决 IP地址分配问题的主流方案。它与使用全局 IP 地址相比有各种限制。 WHOIS 互联网中从很早开始就可以通过网络信息查询机构和管理人联系方式。这种方法就叫做 WHOIS。WHOIS 提供查询IP地址、AS编号以及搜索域名分配登记和管理人信息的服务。\n路由控制 发送数据包时所使用的地址是网络层的地址,即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址,在数据发送过程中还需要类似于“指明路由器或主机”的信息,以便真正发往目标地址。保存这种信息的就是路由控制表(Routing Table)。\n该路由控制表的形成方式有两种:一种是管理员手动设置,另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制,而后者叫做**动态路由控制\nIP协议始终认为路由表是正确的。然而,IP 本身并没有定义制作路由控制表的协议。即 IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”(这个协议有别于IP)的协议制作而成。 路由控制表 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在发送IP 包时,首先要确定IP 包首部中的目标地址,再从路由控制表中找到与该地址具有相同网络地址的记录,根据该记录将IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录,就选择一个最为吻合的网络地址。所谓最为吻合是指相同位数最多的意思”\n如果路由表中下一个路由器的位置记录着某个主机或路由器网卡的IP地址,那就意味着发送的目标地址属于同一个链路。\n默认路由 如果一张路由表中包含所有的网络及其子网的信息,将会造成无端的浪费。这时,默认路由(Default Route)是不错的选择。默认路由是指路由表中任何一个地址都能与之匹配的记录。\n默认路由一般标记为 0.0.0.0/0或 defaul \u0026lsquo;。这里的0.0.0.0/0并不是指 IP 地址是0.0.0.0。由于后面是“/0”,所以并没有标识 IP 地址。它只是为了避免人们误以为0.0.0.0是IP地址。有时默认路由也被标记为 default,但是在计算机内部和路由协议的发送过程中还是以0.0.0.0/0进行处理。\n主机路由 “IP 地址/32”也被称为主机路由(Host Route)。例如,192.168.153.15/32就是一种主机路由。它的意思是整个 IP地址的所有位都将参与路由。 主机路由多被用于不希望通过网络地址路由的情况。\n环回地址 环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。计算机使用一个特殊的IP地址127.0.0.1作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时,数据包不会流向网络。\n路由控制表的聚合 利用网络地址的比特分布可以有效地进行分层配置。对内即使有多个子网掩码,对外呈现出的也是同一个网络地址。这样可以更好地构建网络,通过路由信息的聚合可以有效地减少路由表的条目”。 ","date":"2023-10-18T19:25:30+08:00","permalink":"https://anonymity-0.github.io/posts/%E7%BD%91%E7%BB%9C%E5%B1%82/","title":"网络层"},{"content":"数据链路层 数据链路是让互联计算机之间相互通信的一种协议,又指通信手段。 数据链路的段 数据链路的段是指一个被分割的网络。然而根据使用者不同,其含义也不尽相同。例如,引入中继器将两条网线相连组成一个网络。 这种情况下有两条数据链路: ◎从网络层的概念看,它是一个网络(逻辑上)一即,从网络层的立场出发,这两条网线组成一个段。 ◎从物理层的概念看,两条网线分别是两个物体(物理上)一即, 从物理层的观.点出发,一条网线是一个段。 网络拓扑 网络的连接和构成的形态称沟网络拓扑(Topology)。网络拓扑包括总线型、环型、星型、网状型等。拓扑一词不仅用于直观可见的配线方式上,也用于逻辑上网络的组成结构。两者有时可能会不一致。而目前实际的网络都是由这些简单的拓扑结构错综复杂地组合而成的。 MAC MAC地址用于识别数据链路中互连的节点。 MAC 地址长48 比特。在使用网卡(NIC)的情况下, MAC地址一般会被烧人到 ROM 中。因此,任何一个网卡的MAC地址都是唯一的,在全世界都不会有重复”。 注： 例外情况—MAC地址不一定是唯一的在全世界,MAC地址也并不总是唯一的。实际上,即使 MAC地址相同,只要不是同属一个数据链路就不会出现问题。 例如,人们可以在微机板上自由设置自己的MAC地址。再例如,一台主机上如果启动多个虚拟机,由于没有硬件的网卡只能由虚拟软件自己设定 MAC地址给多个虚拟网卡,这时就很难保证所生成的MAC地址是独一无二的了。 但是,无论哪个协议成员通信设备,设计前提都是 MAC地址的唯一性。这也可以说是网络世界的基本准则。 根据 MAC地址转发 以太网交换机就是持有多个端口”的网桥。它们根据数据链路层中每个帧的目标MAC地址,决定从哪个网络接口发送数据。这时所参考的、用以记录发送接口的表就叫做转发表(Forwarding Table)。 这种转发表的内容不需要使用者在每个终端或交换机上手工设置,而是可以自动生成。数据链路层的每个通过点在接到包时,会从中将源MAC地址以及曾经接收该地址发送的数据包的接口作为对应关系记录到转发表中。 以某个 MAC地址作为源地址的包由某一接口接收,实质上可以理解为该MAC地址就是该接口的目标。因此也可以说,以该 MAC地址作为目标地址的包,经由该接口送出即可。这一过程也叫自学过程。 交换机转发方式 存储转发 存储转发方式检查以太网数据帧末尾的 FCS\u0026rsquo;位后再进行转发。因此,可以避免发送由于冲突而被破坏的帧或噪声导致的错误帧。\n直通转发 直通转发方式中不需要将整个帧全部接收下来以后再进行转发。只需要得知目标地址即可开始转发。因此,它具有延迟较短的优势。但同时也不可避免地有发送错误帧的可能性。\n共享介质型网络 共享介质型网络指由多个设备共享一个通信介质的一种网络。最早的以太网和FDDI 就是介质共享型网络。在这种方式下,设备之间使用同一个载波信道进行发送和接收。为此,基本上采用半双工通信方式,并有必要对介质进行访问控制。\n争用方式 争用方式(Contention)是指争夺获取数据传输的权力,也叫 CSMA(载波监听多路访问)。这种方法通常令网络中的各个站”采用先到先得的方式占用信道发送数据,如果多个站同时发送帧,则会产生冲突现象。也因此会导致网络拥堵与性能下降。 CSMA/CD 在一部分以太网当中,采用了改良 CSMA 的另一种方式-CSMA/CD 方式。CSMA/CD 要求每个站提前检查冲突,一旦发生冲突,则尽早释放信道。其具体工作原理如下: 如果载波信道上没有数据流动,则任何站都可以发送数据。\n检查是否会发生冲突。一旦发生冲突时,放弃发送数据”,同时立即释放载波信道。 放弃发送以后,随机延时一段时间,再重新争用介质,重新发送帧。 令牌传递方式 令牌传递方式是沿着令牌环发送一种叫做“令牌”的特殊报文,是控制传输的一种方式。只有获得令牌的站才能发送数据。这种方式有两个特点:一是不会有冲突,二是每个站都有通过平等循环获得令牌的机会。因此,即使网络拥堵也不会导致性能下降。 当然,这种方式中,一个站在没有收到令牌前不能发送数据帧,因此在网络不太拥堵的情况下数据链路的利用率也就达不到100%\n非共享介质网络 非共享介质网络是指不共享介质,是对介质采取专用的一种传输控制方式。在这种方式下,网络中的每个站直连交换机,由交换机负责转发数据帧。\n该方式还可以根据交换机的高级特性构建虚拟局域网(VLAN,Virtual LAN)、进行流量控制等。当然,这种方式也有一个致命的弱点,那就是一旦交换机发生故障,与之相连的所有计算机之间都将无法通信。\n全双工通信 它允许在同一时间既可以发送数据也可以接收数据。类似于电话,接打双方可以同时说话。 同样是以太网,在使用交换机与双绞线电缆(亦或光纤电缆) 的情况下,既可以通过交换机的端口与计算机之间进行一对一的连接,也可以通过相连电缆内部的收发线路”分别进行接收和发送数据。因此,交换机的端口与计算机之间可以实现同时收发的全双工通信。 环路检测技术 通过网桥连接网络时,一旦出现环路该如何处理?这与网络的拓扑结构和所使用的网桥种类有直接关系。最坏的情况下,数据顿会在环路中被一而再再而三地持续转发。而一旦这种数据帧越积越多将会导致网络瘫痪。\n生成树方式 该方法由 IEEE802.1D定义。每个网桥必须在每1~10秒内相互交換 BPDU (Bridge Protocol Data Unit)包,从而判断哪些端口使用哪些不使用,以便消除环路。一旦发生故障,则自动切换通信线路,利用那些没有被使用的端口继续进行传输。\n源路由法 源路由法最早由TBM 提出,以解决令牌环”网络的问题。该方式可以判断发送数据的源地址是通过哪个网桥实现传输的,并将帧写人 RIF(Routing Information Field)。网桥则根据这个 RIF 信息发送帧给目标地址。因此,即使网桥中出现了环路,数据帧也不会被反复转发,可成功地发送到目标地址。在这种机制中发送端本身必须具备源路由的功能。\nVLAN 进行网络管理的时候,时常会遇到分散网络负载、变换部署网络设备的位置等情况。而有时管理员在做这些操作时,不得不修改网络的拓扑结构,这也就意味着必须进行硬件线路的改造。然而,如果采用带有 VLAN 技术的网桥,就不用实际修改网络布线,只需修改网络的结构即可。 注意：VLAN 是基于以太网的一种技术，它使用 VLAN 标签将数据帧划分到不同的逻辑网段。\n交换机按照其端口区分了多个网段,从而区分了广播数据传播的范围、减少了网络负载并提高了网络的安全性。然而异构的两个网段之间,就需要利用具有路由功能的交换机(如3层交换机), 或在各段中间通过路由器的连接才能实现通信。 对这种 VLAN 进行了扩展,又定义了 IEEE802.10 的标准(也叫 TAG VIAN),该标准允许包含跨越异构交换机的网段。TAG VLAN 中对每个网段都用一个 VLAN ID 的标签进行唯一标识。在交换机中传输帧时,在以太网首部加人这个 VID 标签,根据这个值决定将数据帧发送给哪个网段。 以太网 在众多数据链路中最为著名、使用最为广泛的莫过于以太网(Ethernet)”。它的规范简单,易于 NIC(网卡)及驱动程序实现。\n在以太网普及之初,一般采用多台终端使用同一根同轴电缆的共享介质型\u0026rsquo; 连接方式。 而现在,随着互连设备的处理能力以及传输速度的提高,一般都采用终端与交换机之间独占电缆的方式实现以太网通信 以太网的分类 10BASE 中的“10”、100BASE 中的“100”、1000BASE 中的“1000”以及10CBASE 中的“10G”分别指10Mbps、100Mbps、IGbps 以及 10Gbps 的传输速度。 而追加于后面的“5”、“2”、“T”、“F”等字符表示的是传输介质。 以太网帧格式 [[#以太网]]帧前端有一个叫做前导码(Preamble)的部分,它由0、1数字交替组合而成,表示一个以太网帧的开始,也是对端网卡能够确保与其同步的标志。 前导码末尾是一一个叫做 SFD (Start Frame Delimiter)的域,它的值是“11”。在这个域之后就是以太网帧的本体(图3.20)。前导码与SFD 合起来占8个字节”。 以太网帧本体的前端是以太网的首部,它总共占14个字节。分别是6个字节的目标 MAC地址、6个字节的源MAC地址以及2个字节的上层协议类型。 IEEE802.3 Ethernet 与一般的以太网在帧的首部上稍有区别。一般以太网帧中表示类型的字段,在 IEEE802.3以太网中却表示帧的长度。 紧随帧头后面的是数据。一个数据帧所能容纳的最大数据范围是 46~1500个字节。帧尾是一个叫做 FCS(Ftame Check Sequence,帧检验序列)的4个字节。它可以检查帧是否有所损坏。在通信传输过程中如果出现电子嗓声的干扰,可能会影响发送数据导致乱码位的出现。 在目标 MAC地址中存放了目标工作站的物理地址。源MAC地址中则存放构造以太网帧的发送端工作站的物理地址。\n[[#VLAN]]中,帧的格式又会有所变化 无线通信 无线通信,依据通信距离可分为如表3.3所列出的类型。IEEE802 委员会制定了无线PAN\u0026rsquo;(802.15)、无线 LAN\u0026rsquo;(802. 11)、无线 MAN\u0026rsquo;(802.16)以及无线 RAN\u0026rsquo;(802.22)等无线标准。无线 WAN\u0026rsquo;的最典型代表就是手机通信。手机通过基站能够实现长距离通信。\n无线LAN 允许使用者可以自由地移动位置、自由地放置设备,通过无线电波实现较广范围的通信。这也意味着,在其通信范围内,任何人都可以使用该无线LAN,因此会有被盗听或篡改的危险。 此外,无线LAN 可以无需牌照使用特定频段。因此无线IAN 的无线电波可能会收到其他通信设备的干扰,导致信号不稳定。例如在一台微波炉附近使用一个2.4GHz带宽的802.11b/g设备就得需要注意。微波炉启动后的放射出来的无线电波与设备频率相近,产生的干扰可能会显著地降低设备的传输能力。\nIEEE802.11 IEEE802.11定义了无线LAN 协议中物理层与数据链路层的一部分(MAC 层)。IEEE802.11 这个编号有时指众多标准的统称,有时也指无线LAN 的一种通信方式。 IEEE802.11 是所有IEEE802.11 相关标准的基础。其中定义的数据链路层的一部分(MAC层)适用于所有IEEE802.11 的其他标准。\nMAC层中物理地址与以太网相同,都使用MAC地址,而介质访问控制上则使用CSAM/CD 相似的CSAM/ CA方式。通常采用无线基站并通过高基站实现通信。\nCSMA/ CA CSMA/CA协议中，当一个站点要发送数据时，它会先发送一个RTS（请求发送）帧给接收方。接收方收到RTS帧后，会回复一个CTS（清除发送）帧。只有在接收方回复CTS帧后，发送方才能发送数据。这样可以避免多个站点同时发送数据导致的冲突。\nCSMA/CD和CSMA/区别\n特征 CSMA/CD CSMA/CA 有效性 发生冲突后生效 防止冲突发生 用途 有线网络 无线网络 功能 减少恢复时间 最小化冲突可能性 数据帧重传 发生冲突时重传数据帧 先发送数据传输意图，再发送数据 标准 802.3标准 802.11标准 WIFI Wi-Fi是 WECA(Wireless Fthernet Compatability Alliance,无线以太网兼容性联盟)为普及 IEEE802.11 的各种标准而打造的一个品牌名称。\n蓝牙 蓝牙与 IEEE802.11b/g 类似,是使用2.4GHz 频率无线电波的一种标准”。数据传输速率在 V2 中能达到3Mbps(实际最大吞吐量为2.1Mbps)。通信距离根据无线电波的信号的强弱,有1m、10m、100m 三种类型。通信终端最多允许8台设备。\nZigBee ZieBee 主要应用于家电的远程控制”,是一种短距离、低功耗的无线通信技术。它最多允许65536 个终端之间互连通信。ZigBee 的传输速度随着所使用的频率有所变化。但在日本,使用2.4GHz 频率的设备最高可达250kpbs®。\nPPP PPP(Point-to-Point Protocol)是指点对点,即1对1连接计算机的协议。 在理论上，PPP 协议属于网络层。在实际应用中，PPP 协议通常用于在数据链路层上使用。\nPPP 属于纯粹的数据链路层,与物理层没有任何关系。换句话说,仅有PPP 无法实现通信,还需要有物理层的支持。 PPP可以使用电话线或ISDN、专线、ATM 线路。此外,近些年人们更多是在用 ADSL 或有线电视通过 PPPoE (PPP over Ethernet)实现互联网接人。PPPOE 是在以太网的数据中加入 PPP 帧进行传输的一种方式。\nPPP和以太网的区别\n特征 PPP 以太网 层 网络层 链路层 作用 建立点对点连接 在多个设备之间共享介质 封装 封装 IP 数据包 不封装 使用场景 远程访问、拨号连接 局域网、广域网 在PPP的主要功能中包括两个协议:一个是不依赖上层的LCP 协议(Link Control Protocol),另一个是依赖上层的 NCP 协议(Network Control Protocol)。如果上层为IP,此时的 NCP 也叫做 IPCP (IP Control Protocol)。 LCP LCP 主要负责建立和断开连接、设置最大接收单元(MRU,Maximum Receive Unit)、设置验证协议(PAP 或CHAP)以及设置是否进行通信质量的监控。\nNCP 而 IPCP 则负责IP 地址设置以及是否进行 TCP/IP 首部压缩等设备”。\n通过PPP连接时,通常需要进行用户名密码的验证,并且对通信两端进行双方向的验证。其验证协议有两种,分别为PAP(Password Authentication Protocol) 和 CHAP(Challenge Handshake Authentication Protocol)。\nPAP PAP是PPP连接建立时,通过两次握手进行用户名和密码验证。其中密码以明文方式传输。因此一般用于安全要求并不很高的环境,否则会有窃听或盗用连接的危险。\nCHAP CHAP 则使用一次性密码 OTP(One Time Password),可以有效防止窃听。此外,在建立连接后还可以进行定期的密码交换,用来检验对端是否中途被替换。\nPPP 的帧格式 PPP 的数据帧格式如图3.26所示。其中标志码用来区分每个帧。这一点与HDLC\u0026rsquo;协议非常相似,因为PPP本身就是基于 HDIC制定出来的一种协议。 HDLC HDLC 就是在每个帧的前后加上一个8位字节“01111110”用来区分帧。这一个8位字节叫做标志码。 在两个标志码中间不允许出现连续6个以上的“1”。因此,在发送帧的时候,当出现连续5个“1”时后面必须插人一个0。而当接收端在接收帧时,如果收到连续的5个“1”且后面跟着的是0,就必须删除。由于最多只会出现5个连续的“1”,就可以比较容易地通过标志码区分帧的起始与终止。而PPP标准帧格式与此完全相同。\n另外,在通过电脑进行拨号时,PPP 已在软件中实现。因此,那些插人或删除“0”的操作或FCS 计算都交由电脑的CPU 去处理。这也是为什么人们常说PPP这种方式会给计算机带来大量负荷的原因所在。\nPPPoE 在这种互联网接入服务中,通信线路由以太网模拟。由于以太网越来越普及, 在加上它的网络设备与相应的NIC价格比较便宜,因而ISP 能够提供一个单价更低的互联网接人服务。 单纯的以太网没有验证功能,也没有建立和断开连接的处理,因此无法按时计费。而如果采用PPPoE 管理以太网连接,就可以利用 PPP的验证等功能使各家ISP 可以有效地管理终端用户的使用。 ATM ATM(Asynchronous Transfer Mode)是以一个叫做信元(5字节首部加48字节数据)的单位进行传输的数据链路,由于其线路占用时间短和能够高效传输大容量数据等特点主要用于广域网络的连接。\nATM 是面向连接的一种数据链路。因此在进行通信传输之前一定要设置通信线路。而ATM又与传统电话不同,它允许同时与多个对端建立通信连接。\nATM中没有类似以太网和FDDI那种发送权限的限制。它允许在任何时候发送任何数据。因此,当大量计算机同时发送大量数据时容易引发网络拥堵甚至使网络进入收敛状态”。为了防止这一现象的出现,ATM 中也增加了限制带宽的细分功能\n注：收敛状态指当网络非常拥堵时,路由器或交换机无法完成包的处理,从而丢弃这些包的一种状态。\nATM扩展了 TDM,能够有效地提高线路的利用率\u0026rsquo;。ATM 在 TDM 的时隙中放入数据时,并非按照线路的顺序而是按照数据到达的顺序放入。 为此,发送端还需要附加一个5字节的包首部,包含 VPI(Virtual Path Identifier)、VCI (Virtual Channel Identifier)等识别码”用来标识具体的通信类型。这种VPI 与VCI的值只在直连通信的两个ATM交换机之间设置。在其他交换机之间意思则完全不同。 ATM中信元传输所占用的时隙不固定,一个帧所占用的时隙数也不固定,而且时隙之间并不要求连续。这些特点可以有效减少空闲时隙, 从而提高线路的利用率。只不过需要额外附加5个字节的首部,增加了网络的开销”,因此也在一定程度上降低了通信速度。\n在以太网中一个帧最大可传输1500个字节,FDDI 可以最大传输 4352字节。 而ATM 的一个信元却只能发送固定的48字节数据。这48个字节的数据部分中若包含IP 首部和TCP首部则基本无法存放上层的数据。为此,一般不会单独使用ATM,而是使用上层的AAL(ATM Adapter Layer)。 在上层为IP 的情况下,则叫做 AAIS。每个IP包被附加各层的协议首部以后,最多可以被分为192个信元发送出去。 从这个图中还可以看出,在整个192个信元中只要有一个丢失,那么整个IP 包就相当于被损坏。此时,AAL5 的帧检查位报错,导致接收端不得不丢弃所有的信元。前面曾提到 TCP/IP 在包发生异常的时候可以实现重发,因此在 ATM网中即使只是一个信元丢失,也要重新发送最多192个信元。这也是ATM到目前为止的最大弊端。一且在网络拥堵的情况下,只要丢掉哪怕1%的信元也会导致整个数据都无法接收。特别是由于 ATM 没有发送权限上的控制,很容易导致网络收敛。\nPOS POS (Packet over SDH/SONET)是一种在 SDHY(SONET\u0026rsquo;)上进行包通信的一种协议。SDH(SONET)是在光纤上传输数字信号的物理层规范。\nFDDI FDDI(Fiber Distributed Data Interface)叫做分布式光线数据接口。曾几何时,人们为了用光纤和双绞线实现100Mbps 的传输速率,在主干网或计算机之间的高速连接上广泛使用了 FDDI。但是由于后来高速 LAN 提供了 Gbps 级的传输速率,FDDI 也就逐渐淡出了应用领域。 FDDI 采用令牌(追加令牌)环的访问方式。令牌环访问方式在网络拥堵的情况下极容易导致网络收敛。\n光纤通道 光纤通道(Fiber Channel)是实现高速数据通信的一种数据链路。与其说它是一种网络,不如说它更像是 SCSI那样类似于连接计算机周边设备的总线一样的规范。数据传输速率为 133Mbpx~4Gbps。近些年被广泛用于搭建SAN\u0026rsquo;,成为其主要数据链路。\nHDMI HDMI 是 High-Definition Multimedia Interface 的缩写,意为高清晰度多媒体接口。它可以通过一根缆线实现图像和声音等数字信号的高品质传输。曾主要用于DVD/蓝光播放器、录像机、AV 功放等设备与电视机、投影仪的连接,现在也逐渐开始用于计算机或平板电脑、数码相机与显示器的连接。从2009年发布的1.4 版开始它可以传输以太网帧,使得采用 HDMI介质实现 TCP/IP通信变为可能。\n公共网络 模拟电话线路 模拟电话线路其实就是利用固定电话线路进行通信。电话线中的音频带宽用于拔号上网。该方法不需要特殊的通信线路,完全使用已普及的电话网。 让计算机与电话线相连需要有一个将数字信号转换为模拟信号的调制解调器(俗称“猫”)。“猫”的传输速率一般只在56kbps 左右,所以现在已逐渐被淘汰。 （时代的眼泪）\nADSL ADSL’是对已有的模拟电话线路进行扩展的一种服务。模拟电话线路虽然也能传输高频数字通信,但是它与电信局的交换机之间只有发送音频信号时才能显示极好的传输效率,并会对其他多余频率的信号进行丢弃。\nADSL 正是利用话机到电信局交换机之间这段线路,附加一个叫做分离器的装置,将音频信号(低频信号)和数字信号(高频信号)隔离以免产生噪声干扰。\nFTTH FTTH(Fiber To The Home)顾名思义就是一根高速光纤直接连到用户家里或公司建筑物处的方法。它通过一个叫做ONU\u0026rsquo;的装置将计算机与之关连。该装置负责在光信号与电子信号之间的转换。使用FITH可以实现稳定的高速通信。不过它的线路传输速率与具体的服务内容仍受个别运营商限制。\n以上属于光纤到户。还有一种方式叫光纤到楼。它是指一个高速光纤直接连到某个大厦、公司或宾馆的大楼,随后在整个大楼内部再通过布线实现联网。简称FTTB(Fiber To The Building)。甚至还有一种方式是将光纤接人到某个家庭以后,再通过布线实现周围几户住家共同联网。这种方式简称为 FTIC (Fiber To The Curb\u0026rsquo;)。 有线电视 专线 随着互联网用户的急剧上升,专线服务向着价格更低、带宽更广以及多样化的方向发展。现在市面上已经出现了各种各样的“专线服务”。以NTT Group 的服务为例,有 Mega Data Nets(用 ATM 接口提供3Mbps~42Mbps 的专线接人)、ATM Mega-Link、Giga Stream(用以太网或 SONET/SDH 接口提供 0.5Mbps~135Mbps 的专线接人)等众多专线接入服务。\n专线的连接一定是一对一的连接。虽然 [[#ATM]] 的设计初衷允许有多个目标地, 但对于提供专线服务的ATMMega-Link中也只能指定一个目的地。因此不可能像ISDN 或帧中继那样引进一条线缆就能连接众多目的地。\nVPN 虚拟专用网络(VPN)用于连接距离较远的地域。这种服务包括 IP-VPN 和广域以太网。\nIP-VPN 意指在IP 网络(互联网)上建立 VPN。 网络服务商提供一种在 IP 网络上使用 MPIS 技术构建 VPN 的服务。其中MPLS(Multiprotocol Label Switching,多协议标签交换)在IP 包中附加一个叫做标签(Label\u0026rsquo;)的信息进行传输控制。每个用户的标签信息不同,因此在通过MPIS 网时,可以轻松地判断出目标地址。这样一来就可以将多个不同用户的VPN信息通过 MPLS 网加以区分,形成封闭的私有网络。此外,还能进行用户级的带宽控制。\nIPsec 除了使用服务提供商的 IP-VPN服务之外,有时企业还可以在互联网上建立自己的VPN\u0026rsquo;,一般采用的是 IPsec’技术。该方法对 VPN通信中的IP 包进行验证和加密,在互联网上构造一个封闭的私有网络。\n广域以太网 服务提供商所提供的用于连接相距较远的地域的一种服务。IP-VPN 是在IP 层面的连接,广域以太网则是在作为数据链路层的以太网上利用VLAN(虚拟局域网)实现 VPN的技术。该技术还可以使用 TCP/IP 中的其他协议。 广域以太网以企业专门使用服务提供商构建的 VLAN 网络为主要形式。只要指定同一个 VLAN,无论从哪里都能接入到同一个网络。\n公共无线 LAN 公共无线LAN 是指公开的可以使用[Wi-Fi]的服务。服务提供者可以在车站或餐饮店等人员相对比较集中的地方架设的一个叫做热点(HotSpot)的无线电波接收器。使用者到达这些区域就可以使用带有无线LAN网卡的笔记本电脑或智能手机连接上网。\n上网时使用者首先要通过这些热点建立互联网连接。连接以后,还可以通过那些利用 IPsec技术实现的VPN 连接到自己公司的内网。这种接人服务有时免费(如商场、车站等场所),有时也可能是收费的。 ","date":"2023-10-18T18:52:01+08:00","permalink":"https://anonymity-0.github.io/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","title":"数据链路层"}]