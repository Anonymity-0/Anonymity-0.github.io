<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='前言 其实从本科开始，计网相关的课上了也有三次：第一次是大二在CQU上的，当时用的自顶向下那本书，一上来方老师就无敌催眠，不过是开卷考试，最后面向考试临时复习也拿了90&#43;；第二次是考研的时候看的湖科大的网课，说实话这个老师动画做的很好，每个知识点好像都听懂了，但是还是没有形成成套的系统；第三次是在USTC上的高级计算机网络，上学期选这门课的时候，还是抱着一种想学东西的心态去听的，毕竟选的时候就听过这门课很硬核。遗憾的是，尝试听了一两节课后还是放弃了。机缘巧合之下，看到了cs144的lab，想给自己立一个新坑，这个学期搓出来cs144。计网的概念实在是玄乎又不好理解，或许换种方式，试试自己动手写写，顺便尝试读读英文文档（当然还是会借助一下翻译器），话不多说，cs144，启动！
前面都是一些配置相关废话，正式写代码请看[[#3.4 Writing webget]]
1 Set up GNU/Linux on your computer 文档中给出了几种环境的安装方式
Recommended: Install the CS144 VirtualBox virtual-machine image (instructions at https://stanford.edu/class/cs144/vm howto/vm-howto-image.html). Use a Google Cloud virtual machine using our class’s coupon code (instructions at https://stanford.edu/class/cs144/vm howto). Run Ubuntu version 23.10, then install the required packages: sudo apt update &amp;amp;&amp;amp; sudo apt install git cmake gdb build-essential clang \clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark Use another GNU/Linux distribution, but be aware that you may hit roadblocks along the way and will need to be comfortable debugging them.'>
<title>Check0</title>

<link rel='canonical' href='https://anonymity-0.github.io/posts/cs144/check0/'>

<link rel="stylesheet" href="/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css"><meta property='og:title' content='Check0'>
<meta property='og:description' content='前言 其实从本科开始，计网相关的课上了也有三次：第一次是大二在CQU上的，当时用的自顶向下那本书，一上来方老师就无敌催眠，不过是开卷考试，最后面向考试临时复习也拿了90&#43;；第二次是考研的时候看的湖科大的网课，说实话这个老师动画做的很好，每个知识点好像都听懂了，但是还是没有形成成套的系统；第三次是在USTC上的高级计算机网络，上学期选这门课的时候，还是抱着一种想学东西的心态去听的，毕竟选的时候就听过这门课很硬核。遗憾的是，尝试听了一两节课后还是放弃了。机缘巧合之下，看到了cs144的lab，想给自己立一个新坑，这个学期搓出来cs144。计网的概念实在是玄乎又不好理解，或许换种方式，试试自己动手写写，顺便尝试读读英文文档（当然还是会借助一下翻译器），话不多说，cs144，启动！
前面都是一些配置相关废话，正式写代码请看[[#3.4 Writing webget]]
1 Set up GNU/Linux on your computer 文档中给出了几种环境的安装方式
Recommended: Install the CS144 VirtualBox virtual-machine image (instructions at https://stanford.edu/class/cs144/vm howto/vm-howto-image.html). Use a Google Cloud virtual machine using our class’s coupon code (instructions at https://stanford.edu/class/cs144/vm howto). Run Ubuntu version 23.10, then install the required packages: sudo apt update &amp;amp;&amp;amp; sudo apt install git cmake gdb build-essential clang \clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark Use another GNU/Linux distribution, but be aware that you may hit roadblocks along the way and will need to be comfortable debugging them.'>
<meta property='og:url' content='https://anonymity-0.github.io/posts/cs144/check0/'>
<meta property='og:site_name' content='AGA&#39;s Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='lab' /><meta property='article:published_time' content='2024-03-29T14:16:37&#43;08:00'/><meta property='article:modified_time' content='2024-03-29T14:16:37&#43;08:00'/>
<meta name="twitter:title" content="Check0">
<meta name="twitter:description" content="前言 其实从本科开始，计网相关的课上了也有三次：第一次是大二在CQU上的，当时用的自顶向下那本书，一上来方老师就无敌催眠，不过是开卷考试，最后面向考试临时复习也拿了90&#43;；第二次是考研的时候看的湖科大的网课，说实话这个老师动画做的很好，每个知识点好像都听懂了，但是还是没有形成成套的系统；第三次是在USTC上的高级计算机网络，上学期选这门课的时候，还是抱着一种想学东西的心态去听的，毕竟选的时候就听过这门课很硬核。遗憾的是，尝试听了一两节课后还是放弃了。机缘巧合之下，看到了cs144的lab，想给自己立一个新坑，这个学期搓出来cs144。计网的概念实在是玄乎又不好理解，或许换种方式，试试自己动手写写，顺便尝试读读英文文档（当然还是会借助一下翻译器），话不多说，cs144，启动！
前面都是一些配置相关废话，正式写代码请看[[#3.4 Writing webget]]
1 Set up GNU/Linux on your computer 文档中给出了几种环境的安装方式
Recommended: Install the CS144 VirtualBox virtual-machine image (instructions at https://stanford.edu/class/cs144/vm howto/vm-howto-image.html). Use a Google Cloud virtual machine using our class’s coupon code (instructions at https://stanford.edu/class/cs144/vm howto). Run Ubuntu version 23.10, then install the required packages: sudo apt update &amp;amp;&amp;amp; sudo apt install git cmake gdb build-essential clang \clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark Use another GNU/Linux distribution, but be aware that you may hit roadblocks along the way and will need to be comfortable debugging them.">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu6c25cd778f8db4d2cb962eb2998a0673_130812_300x0_resize_box_3.png" width="300"
                            height="271" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🍚</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">AGA&#39;s Blog</a></h1>
            <h2 class="site-description">Hello World!</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/Anonymity-0'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
                <li id="i18n-switch">  
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                    <select name="language" onchange="window.location.href = this.selectedOptions[0].value">
                        
                            <option value="https://anonymity-0.github.io/" selected>English</option>
                        
                            <option value="https://anonymity-0.github.io/zh-cn/" >中文</option>
                        
                    </select>
                </li>
            
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>Dark Mode</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#前言">前言</a></li>
    <li><a href="#1-set-up-gnulinux-on-your-computer">1 Set up GNU/Linux on your computer</a></li>
    <li><a href="#2-networking-by-hand">2 Networking by hand</a>
      <ol>
        <li><a href="#21-fetch-a-web-page">2.1 Fetch a Web page</a></li>
        <li><a href="#22">2.2</a></li>
        <li><a href="#23">2.3</a></li>
      </ol>
    </li>
    <li><a href="#3-writing-a-network-program-using-an-os-stream-socket">3. Writing a network program using an OS stream socket</a>
      <ol>
        <li><a href="#31-lets-get-startedfetching-and-building-the-starter-code">3.1 Let’s get started—fetching and building the starter code</a></li>
        <li><a href="#32-modern-c-mostly-safe-but-still-fast-and-low-level">3.2 Modern C++: mostly safe but still fast and low-level</a></li>
        <li><a href="#33-阅读minnow支持代码">3.3 阅读Minnow支持代码</a>
          <ol>
            <li><a href="#explicit关键字">explicit关键字</a></li>
            <li><a href="#右值引用">右值引用</a></li>
            <li><a href="#stdmove">std::move()</a></li>
          </ol>
        </li>
        <li><a href="#34-writing-webget">3.4 Writing webget</a>
          <ol>
            <li><a href="#套接字">套接字</a></li>
            <li><a href="#套接字与服务端进行通信流程">套接字与服务端进行通信流程</a></li>
            <li><a href="#c套接字编程相关函数">c++套接字编程相关函数</a></li>
            <li><a href="#http报文格式">http报文格式</a></li>
            <li><a href="#实现代码">实现代码</a></li>
            <li><a href="#代码测试">代码测试</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#4an-in-memory-reliable-byte-stream">4.An in-memory reliable byte stream</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" >
                计算机网络基础知识
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/posts/cs144/check0/">Check0</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Mar 29, 2024</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    7 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="前言">前言</h2>
<p>其实从本科开始，计网相关的课上了也有三次：第一次是大二在CQU上的，当时用的自顶向下那本书，一上来方老师就无敌催眠，不过是开卷考试，最后面向考试临时复习也拿了90+；第二次是考研的时候看的湖科大的网课，说实话这个老师动画做的很好，每个知识点好像都听懂了，但是还是没有形成成套的系统；第三次是在USTC上的高级计算机网络，上学期选这门课的时候，还是抱着一种想学东西的心态去听的，毕竟选的时候就听过这门课很硬核。遗憾的是，尝试听了一两节课后还是放弃了。机缘巧合之下，看到了cs144的lab，想给自己立一个新坑，这个学期搓出来cs144。计网的概念实在是玄乎又不好理解，或许换种方式，试试自己动手写写，顺便尝试读读英文文档（当然还是会借助一下翻译器），话不多说，cs144，启动！</p>
<p>前面都是一些配置相关废话，正式写代码请看[[#3.4 Writing webget]]</p>
<h2 id="1-set-up-gnulinux-on-your-computer">1 Set up GNU/Linux on your computer</h2>
<p>文档中给出了几种环境的安装方式</p>
<ol>
<li>Recommended: Install the CS144 VirtualBox virtual-machine image (instructions at <a class="link" href="https://stanford.edu/class/cs144/vm"  target="_blank" rel="noopener"
    >https://stanford.edu/class/cs144/vm</a> howto/vm-howto-image.html).</li>
<li>Use a Google Cloud virtual machine using our class’s coupon code (instructions at <a class="link" href="https://stanford.edu/class/cs144/vm"  target="_blank" rel="noopener"
    >https://stanford.edu/class/cs144/vm</a> howto).</li>
<li>Run Ubuntu version 23.10, then install the required packages: sudo apt update &amp;&amp; sudo apt install git cmake gdb build-essential clang \clang-tidy clang-format gcc-doc pkg-config glibc-doc tcpdump tshark</li>
<li>Use another GNU/Linux distribution, but be aware that you may hit roadblocks along the way and will need to be comfortable debugging them. Your code will be tested on Ubuntu 23.10 LTS with g++ 13.2 and must compile and run properly under those conditions.</li>
<li>If you have a 2020–24 MacBook (with the ARM64 M1/M2/M3 chips), VirtualBox will not successfully run. Instead, please install the UTM virtual machine software and our ARM64 virtual machine image from <a class="link" href="https://stanford.edu/class/cs144/vm"  target="_blank" rel="noopener"
    >https://stanford.edu/class/cs144/vm</a> howto/.</li>
</ol>
<p>我是MAC系统所以就按第五种进行虚拟机的安装（上学期已经被折磨过一次）</p>
<ol>
<li>下载UTM并进行安装（这一步没啥好介绍的）</li>
<li>下载<a class="link" href="https://stanford.edu/class/cs144/vm_howto/"  target="_blank" rel="noopener"
    >Setting up your CS144 VM</a>提供的<a class="link" href="https://web.stanford.edu/class/cs144/vm_files/cs144-arm64-2024.utm.tar.gz"  target="_blank" rel="noopener"
    >ARM64 GNU/Linux virtual machine image</a>,并导入UTM</li>
<li>启动虚拟机,初始用户和密码都是<code>cs144</code>
到这里，虚拟机就安装完成了，开始实验！</li>
</ol>
<h2 id="2-networking-by-hand">2 Networking by hand</h2>
<p>这一节主要是体验一下，用图形化浏览器访问网页和在终端操作的区别。</p>
<h3 id="21-fetch-a-web-page">2.1 Fetch a Web page</h3>
<ol>
<li>在图形化浏览器访问<a class="link" href="http://cs144.keithw.org/hello"  target="_blank" rel="noopener"
    >cs144.keithw.org/hello</a>，可以看到下图内容
<img src="https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202403161810392.png"
	
	
	
	loading="lazy"
	
	
></li>
<li>在虚拟机的终端输入 <code>telnet cs144.keithw.org http</code>，结果如下
<ul>
<li>这个命令是用来通过Telnet协议手动模拟一个简单的HTTP请求，以连接到域名 <code>cs144.keithw.org</code> 上提供的HTTP服务。</li>
<li><strong>telnet</strong> 是一个基于TCP/IP协议的远端登录工具，它允许用户通过网络与远程主机上的指定端口建立直接交互式连接。</li>
<li><strong>cs144.keithw.org</strong> 是要连接的目标服务器的域名。</li>
<li><strong>http</strong> 指定要连接的TCP端口号，默认情况下HTTP服务运行在80端口，但在这种情况下省略了端口号，因为<code>http</code>作为参数实际上暗示telnet应连接到HTTP服务的标准端口80。</li>
<li><img src="https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202403161813923.png"
	
	
	
	loading="lazy"
	
	
></li>
</ul>
</li>
<li>当你执行这个命令后，telnet会尝试与该服务器的80端口建立连接。一旦连接成功，你可以在telnet会话中手工输入HTTP请求头和请求体来模拟浏览器与Web服务器之间的通信。
<ol>
<li>输入<code>GET /hello HTTP/1.1</code> ，回车。这是一个HTTP头部信息，告知服务器请求的目标主机名，确保服务器知道你请求的是哪个站点的资源，即使多个站点可能共享同一IP地址和端口。</li>
<li>输入<code>Host: cs144.keithw.org</code>，回车。这是一个HTTP头部信息，告知服务器请求的目标主机名，确保服务器知道你请求的是哪个站点的资源。</li>
<li>输入<code>Connection: close</code>，回车。这也是一个HTTP头部信息，指示服务器在完成响应后关闭TCP连接，因为在HTTP/1.1中默认采用持久连接，而这里明确要求一次请求结束后就关闭连接。</li>
<li>在输入完上述信息后，再按一次回车键，发送一个空行。在HTTP协议中，空行标志着请求头部的结束，接下来服务器将读取并处理你的请求。</li>
<li>如果一切正常，你将在telnet窗口中看到服务器发回的响应。</li>
</ol>
</li>
</ol>
<h3 id="22">2.2</h3>
<p>略</p>
<h3 id="23">2.3</h3>
<p>略</p>
<h2 id="3-writing-a-network-program-using-an-os-stream-socket">3. Writing a network program using an OS stream socket</h2>
<p>前面只是一些直观的体验，现在要真正开始编程了，在这个实验中，你将使用操作系统内置的传输控制协议支持。你需要编写一个名为“webget”的程序，创建一个TCP流套接字，连接到Web服务器，并获取一个页面。在后续的实验中，你将实现传输控制协议的另一部分，即自己实现TCP协议，将不可靠的数据报转换为可靠的字节流。</p>
<h3 id="31-lets-get-startedfetching-and-building-the-starter-code">3.1 Let’s get started—fetching and building the starter code</h3>
<ol>
<li>
<p>在虚拟机的终端窗口运行<code>git clone https://github.com/cs144/minnow</code> 获得源代码</p>
</li>
<li>
<p>Optional: Feel free to backup your repository to a private GitHub/GitLab/Bitbucket repository (e.g., using the instructions at <a class="link" href="https://stackoverflow.com/questions/10065526/"  target="_blank" rel="noopener"
    >https://stackoverflow.com/questions/10065526/</a> github-how-to-make-a-fork-of-public-repository-private), but please make absolutely sure that your work remains private.（可选项，其实就是让你备份）</p>
</li>
<li>
<p>进入文件夹: <code>cd minnow</code></p>
</li>
<li>
<p>创建一个目录来编译实验软件：<code>cmake -S . -B build</code></p>
</li>
<li>
<p>编译源文件: <code>cmake --build build</code></p>
</li>
<li>
<p>返回上层文件夹，打开 <code>writeups/check0.md</code> 文件，这是实验检查点报告的模板。</p>
<ul>
<li>. <img src="https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202403171228997.png"
	
	
	
	loading="lazy"
	
	
></li>
</ul>
</li>
</ol>
<h3 id="32-modern-c-mostly-safe-but-still-fast-and-low-level">3.2 Modern C++: mostly safe but still fast and low-level</h3>
<p>实验作业将使用现代C++风格编写，这种风格使用最近（2011年）的语言特性以尽可能安全地进行编程。这可能与过去编写C++的方式不同。关于这种风格的参考，请参见<a class="link" href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"  target="_blank" rel="noopener"
    >C++ Core Guidelines</a>。</p>
<p>具体来说：</p>
<ul>
<li>使用 <a class="link" href="https://en.cppreference.com"  target="_blank" rel="noopener"
    >https://en.cppreference.com</a> 作为编程资源。（我们建议您避免使用cplusplus.com，因为它可能已经过时。）</li>
<li>不要使用malloc()或free()。</li>
<li>不要使用new或delete。</li>
<li>尽量不使用原始指针（*），只在必要时使用“智能”指针（unique_ptr或shared_ptr）（在CS144中不需要使用这些）。</li>
<li>避免使用模板、线程、锁和虚函数（您在CS144中不需要使用这些）。</li>
<li>避免使用C风格字符串（char *str）或字符串函数（如strlen()，strcpy()）。这些容易出错。请改用std::string。</li>
<li>不要使用C风格强制转换（例如，(FILE *)x）。如果需要，请使用C++静态强制转换（通常在CS144中不需要这样做）。</li>
<li>优先通过常量引用传递函数参数（例如：const Address &amp; address）。</li>
<li>除非需要修改，否则使每个变量都为const。</li>
<li>除非需要修改对象，否则使每个方法都为const。</li>
<li>避免使用全局变量，并尽可能使每个变量的作用域最小。</li>
<li>在提交作业之前，运行<code>cmake --build build --target tid</code>y以获取有关如何根据C++编程实践改进代码的建议，并运行<code>cmake --build build --target format</code>以一致地格式化代码。</li>
</ul>
<h3 id="33-阅读minnow支持代码">3.3 阅读Minnow支持代码</h3>
<p>为了支持这种编程风格，Minnow使用类将操作系统的函数封装成现代C++的形式。这些类主要是对您在CS 110/111课程中已经接触过的概念，如套接字和文件描述符，进行封装。
您需要阅读这些类的公共接口，这些接口定义在<code>util/socket.hh</code>和<code>util/file descriptor.hh</code>文件中的<code>public:</code>之后的部分。特别要注意的是，Socket是FileDescriptor的一种类型，而TCPSocket又是Socket的一种类型。</p>
<p>这段话乍一看我头都大了，查阅了一下得到的解释如下：</p>
<ul>
<li>Socket是网络编程中的一个概念，它允许程序通过计算机网络进行通信。</li>
<li>FileDescriptor是一个更通用的概念，它通常指的是操作系统中的一个整数，用于标识打开的文件、套接字等资源。</li>
<li>在Minnow中，Socket是FileDescriptor的一个子类，这意味着Socket拥有FileDescriptor的所有功能，并且还有一些额外的网络通信相关的功能。同样，TCPSocket是Socket的子类，它提供了对TCP（传输控制协议）套接字的专门支持。</li>
</ul>
<p>如果听起来还是很抽象，那我们还是看看代码吧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Socket</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FileDescriptor</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! Bind a socket to a specified address with [bind(2)](\ref man2::bind), usually for listen/accept
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">bind</span><span class="p">(</span> <span class="k">const</span> <span class="n">Address</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Bind a socket to a specified device
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">bind_to_device</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">device_name</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Connect a socket to a specified peer address with [connect(2)](\ref man2::connect)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">connect</span><span class="p">(</span> <span class="k">const</span> <span class="n">Address</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Shut down a socket via [shutdown(2)](\ref man2::shutdown)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">shutdown</span><span class="p">(</span> <span class="kt">int</span> <span class="n">how</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Get local address of socket with [getsockname(2)](\ref man2::getsockname)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Address</span> <span class="nf">local_address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! Get peer address of socket with [getpeername(2)](\ref man2::getpeername)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Address</span> <span class="nf">peer_address</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Allow local address to be reused sooner via [SO_REUSEADDR](\ref man7::socket)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">set_reuseaddr</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Check for errors (will be seen on non-blocking sockets)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">throw_if_error</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到<code>Socket</code>类是<code>FileDescriptor</code>的子类，它定义了一些与套接字相关的操作，如绑定地址、连接、关闭、获取本地和对等地址等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TCPSocket</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Socket</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! \brief Construct from FileDescriptor (used by accept())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//! \param[in] fd is the FileDescriptor from which to construct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="n">TCPSocket</span><span class="p">(</span> <span class="n">FileDescriptor</span><span class="o">&amp;&amp;</span> <span class="n">fd</span> <span class="p">)</span> <span class="o">:</span> <span class="n">Socket</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">fd</span> <span class="p">),</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span> <span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! Default: construct an unbound, unconnected TCP socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TCPSocket</span><span class="p">()</span> <span class="o">:</span> <span class="n">Socket</span><span class="p">(</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span> <span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Mark a socket as listening for incoming connections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">listen</span><span class="p">(</span> <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="mi">16</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Accept a new incoming connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TCPSocket</span> <span class="nf">accept</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>TCPSocket</code>类是<code>Socket</code>的子类，它专门用于处理TCP套接字。</li>
<li><code>TCPSocket</code>类有两个构造函数，一个是默认构造函数，用于创建一个未绑定、未连接的TCP套接字；另一个是从<code>FileDescriptor</code>构造的，这通常是<code>accept</code>方法接受新连接时使用的。</li>
<li>重点讲一下<code>explicit TCPSocket( FileDescriptor&amp;&amp; fd ) : Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}</code>这个部分，这是之前没有遇到过的（C++学的比较浅）。
<ul>
<li>
<p>总的来说，<code>explicit TCPSocket( FileDescriptor&amp;&amp; fd ) : Socket( std::move(fd), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}</code>表示<code>TCPSocke</code>t构造函数接受一个右值引用的<code>FileDescriptor</code>类型的参数fd，并使用这个参数来初始化<code>Socket</code>对象。</p>
</li>
<li>
<p><code>explicit</code>关键字表示这个构造函数只能显式地被调用，不能隐式地转换类型。</p>
</li>
<li>
<p><code>FileDescriptor&amp;&amp; fd</code>表示这个构造函数接收一个<code>FileDescriptor</code>类型的参数，<code>&amp;&amp;</code>表示这个参数是右值引用，也就是说，这个参数可能是一个临时的对象。</p>
</li>
<li>
<p><code>: Socket( std::move( fd ), AF_INET, SOCK_STREAM, IPPROTO_TCP )</code> 这部分是构造函数的初始化列表。它的作用是初始化这个<code>TCPSocket</code>对象的父类<code>Socket</code>。实际上是在调用基类<code>Socket</code>的构造函数，并传递了构造函数的参数。这样做的好处是，它可以确保基类构造函数在派生类构造函数体执行之前被调用，从而正确初始化基类的部分。</p>
</li>
<li>
<p><code>std::move( fd )</code>表示将<code>fd</code>的所有权移动给<code>Socket</code>，这样可以避免不必要的复制。</p>
</li>
<li>
<p><code>AF_INET, SOCK_STREAM, IPPROTO_TCP</code>是创建<code>Socket</code>时需要的参数，它们分别表示使用的网络协议族（IPv4），套接字类型（流式套接字）和协议（TCP）。</p>
</li>
</ul>
</li>
</ul>
<p>如果你觉得上面解释的如果还不够清晰，那说明<del>你的c++和我一样学的半桶水</del>，接下来是一些举例的知识补充：</p>
<h4 id="explicit关键字">explicit关键字</h4>
<p>用一个更简单的例子来解释<code>explicit</code>关键字的作用。
想象一下你有一个装钱的钱包，这个钱包只能装纸币，不能装硬币。现在，你想要设计一个往钱包里放钱的功能。</p>
<ol>
<li><strong>没有<code>explicit</code>的情况</strong>：
你设计了一个钱包的构造函数，这个构造函数可以接受一个纸币面额的参数，比如<code>100</code>，然后钱包里就会自动有<code>100</code>块钱。这个构造函数没有使用<code>explicit</code>关键字。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Wallet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">Wallet</span><span class="p">(</span><span class="kt">int</span> <span class="n">money</span><span class="p">)</span> <span class="o">:</span> <span class="n">money</span><span class="p">(</span><span class="n">money</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">getMoney</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">money</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">money</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div>这时，你可以这样使用这个钱包：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Wallet</span> <span class="nf">wallet</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 明确地创建一个有100块钱的钱包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Wallet</span> <span class="n">anotherWallet</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">// 这里隐式地将200这个整数转换成了一个钱包
</span></span></span></code></pre></td></tr></table>
</div>
</div>在第二种情况中，你只是写了一个数字<code>200</code>，并没有明确地调用构造函数，但是编译器却自动帮你创建了一个钱包，并且里面有<code>200</code>块钱。这就是没有<code>explicit</code>关键字的构造函数允许的隐式转换。</li>
<li><strong>使用<code>explicit</code>的情况</strong>：
现在，你决定在设计钱包的时候，不允许这种隐式转换，你希望每次往钱包里放钱都必须明确地调用构造函数。这时，你可以在构造函数前加上<code>explicit</code>关键字。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Wallet</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">explicit</span> <span class="n">Wallet</span><span class="p">(</span><span class="kt">int</span> <span class="n">money</span><span class="p">)</span> <span class="o">:</span> <span class="n">money</span><span class="p">(</span><span class="n">money</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nf">getMoney</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">money</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">money</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div>这时，如果你尝试之前的那种隐式转换：
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Wallet</span> <span class="nf">wallet</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">// 这仍然是正确的，因为这是明确地调用构造函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Wallet</span> <span class="n">anotherWallet</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span> <span class="c1">// 这将是一个错误，因为构造函数是explicit的，不允许隐式转换
</span></span></span></code></pre></td></tr></table>
</div>
</div>第二行代码会导致编译错误，因为编译器不再允许你只是写一个数字就自动创建钱包。你必须明确地调用构造函数，像第一行那样。
所以，<code>explicit</code>关键字的作用就是防止构造函数的隐式调用，让类型转换更加明确，避免程序中出现意想不到的行为。</li>
</ol>
<p>在cs144这段代码中，如果我们尝试这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FileDescriptor</span> <span class="nf">fd</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span> <span class="c1">// 创建一个文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TCPSocket</span> <span class="n">socket</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>    <span class="c1">// 这将失败，因为TCPSocket的构造函数是explicit的
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这段代码会失败，因为TCPSocket的构造函数是explicit的，这意味着我们不能使用隐式类型转换将FileDescriptor类型的值转换为TCPSocket对象。我们必须明确地调用构造函数，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FileDescriptor</span> <span class="nf">fd</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span> <span class="c1">// 创建一个文件描述符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TCPSocket</span> <span class="nf">socket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fd</span><span class="p">));</span> <span class="c1">// 正确，明确地调用构造函数
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="右值引用">右值引用</h4>
<p>在C++中，我们有两种类型的引用：左值引用和右值引用。</p>
<p>左值引用是我们通常所说的引用，它引用的是一个具有明确存储位置的对象。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 左值引用
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>右值引用是C++11引入的新特性，它引用的是一个临时对象，或者说是一个将要销毁的对象。这种引用通常用于移动语义和完美转发。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">rref</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 右值引用
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，数字5是一个临时对象，我们可以用右值引用来引用它。</p>
<p><code>FileDescriptor&amp;&amp; fd</code>就是一个右值引用，它指向的是一个<code>FileDescriptor</code>类型的临时对象。这个构造函数的作用就是，直接取走这个临时对象的值，用来初始化一个新的<code>TCPSocket</code>对象，而不需要复制这个临时对象。</p>
<p>假设有个FileDescriptor对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FileDescriptor</span> <span class="nf">fd1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们尝试这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TCPSocket</span> <span class="nf">socket1</span><span class="p">(</span><span class="n">fd1</span><span class="p">);</span> <span class="c1">// 这会创建一个副本
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里，fd1是一个左值引用，因为它是一个有名字的对象。当我们传递fd1给TCPSocket的构造函数时，我们需要创建fd1的一个副本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 以下是创建TCPSocket对象的正确方式，使用右值引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">TCPSocket</span> <span class="nf">socket1</span><span class="p">(</span><span class="n">FileDescriptor</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> <span class="c1">// 创建了一个临时的FileDescriptor对象
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="stdmove">std::move()</h4>
<p>在C++中，<code>std::move</code>是一个函数模板，它将一个左值引用转换为右值引用。当你在代码中看到<code>std::move(fd)</code>时，它的作用是将<code>fd</code>这个左值引用转换为右值引用。这样，你就可以传递一个临时的对象，而不需要创建它的一个副本。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"> </span><span class="c1">// for std::move
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyObject</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyObject</span><span class="p">(</span><span class="n">MyObject</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">other</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// &#34;窃取&#34; other 的资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyObject</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">MyObject</span> <span class="n">obj2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">obj1</span><span class="p">));</span> <span class="c1">// 使用 std::move 将 obj1 转换为右值引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 现在，obj1 的值已经被 &#34;窃取&#34;，obj2 的值是 5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个例子中，我们有一个<code>MyObject</code>类，它有一个接受右值引用的构造函数。在<code>main</code>函数中，我们创建了一个<code>MyObject</code>对象<code>obj1</code>，然后我们使用<code>std::move(obj1)</code>将<code>obj1</code>转换为右值引用，然后将其传递给<code>obj2</code>的构造函数。这样，<code>obj2</code>的构造函数就可以直接接收<code>obj1</code>的所有权，而不需要复制<code>obj1</code>。</p>
<p>回到原始问题，<code>explicit TCPSocket( FileDescriptor&amp;&amp; fd ) : Socket( std::move(fd), AF_INET, SOCK_STREAM, IPPROTO_TCP ) {}</code>中的<code>std::move(fd)</code>也是类似的作用。它将<code>fd</code>这个左值引用转换为右值引用，这样就可以传递一个临时的<code>FileDescriptor</code>对象，而不需要创建它的一个副本。这可以提高性能，因为我们避免了不必要的对象复制。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FileDescriptor</span> <span class="nf">fd1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">TCPSocket</span> <span class="nf">socket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fd1</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这段代码中，<code>std::move(fd1)</code>将<code>fd1</code>转换为右值引用，然后将其传递给<code>TCPSocket</code>的构造函数。这样，<code>TCPSocket</code>的构造函数就可以直接接收<code>fd1</code>的所有权，而不需要复制<code>fd1</code>。注意，一旦你这样做了，你就不应再使用<code>fd1</code>了，因为它的值可能已经被&quot;窃取&quot;了。</p>
<h3 id="34-writing-webget">3.4 Writing webget</h3>
<p>误会了现在才到写的时候。。。</p>
<ol>
<li>在构建目录中，使用文本编辑器或集成开发环境打开…/apps/webget.cc文件。</li>
<li>在get URL函数中，实现如文件中所述的简单Web客户端，使用之前使用的HTTP（Web）请求格式。使用TCPSocket和Address类。</li>
<li>提示：
<ol>
<li>请注意，在HTTP中，每行必须以“\r\n”结束（仅使用“\n”或endl是不够的）。</li>
<li>不要忘记在你的客户端请求中包含“Connection: close”行。这告诉服务器在发送完这个请求后，不需要等待你的客户端发送更多的请求。相反，服务器将发送一个回复，然后会立即结束其发送的字节流（从服务器套接字到你的套接字）。你会发现你的传入字节流已经结束，因为当你的套接字读取完从服务器传来的整个字节流时，会达到“EOF”（文件结束）。这就是你的客户端知道服务器已经完成回复的方式。</li>
<li>确保读取并打印服务器所有输出直到套接字达到“EOF”（文件结束）——一次读取调用是不够的。</li>
<li>我们预计你将需要编写大约十行代码</li>
</ol>
</li>
</ol>
<p>我之前还尝试分析了一下源码，<del>后来发现是我想多了。</del></p>
<p>在写代码之前，首先来回顾一下TCP协议的Socket套接字编程。更基础的，让我们回顾一下一些基础概念：</p>
<h4 id="套接字">套接字</h4>
<p><del>其实这个概念我至今都觉得很抽象，不过他确实非常重要</del></p>
<p>首先先问个问题，请问Socket和socket有什么区别？
你可能和我一样有些云里雾里，在不同教材或者csdn上叫法都不太统一，<strong>这玩意难道不是同一个东西？</strong></p>
<p>以下是结合我个人的理解和gpt老师的答案：</p>
<p>在大多数情况下，“Socket”和“socket”指的是同一件事：计算机网络编程中用于通信的一种抽象概念，即套接字。套接字是网络通信的端点，允许不同进程在网络上进行通信。无论是大写还是小写，它们都是指同一个概念，只是书写时的大小写不同。在不同的编程语言或文档中可能会有不同的约定，但在通用的网络编程术语中，它们是等价的。</p>
<ol>
<li><strong>Socket（首字母大写）</strong>：
<ul>
<li>这通常是指操作系统提供的一个抽象层，它允许网络中的不同主机间进行通信。</li>
<li>在编程语境中，一个Socket代表一个网络连接的端点，可以看作是不同计算机进程间或同一计算机上不同进程间通信的一个门户。</li>
<li>在Unix和Linux系统中，Socket是实现进程间通信（IPC）和网络通信的一种机制。</li>
</ul>
</li>
<li><strong>socket（首字母小写）</strong>：
<ul>
<li>socket 是一组用于<strong>网络通信的 API</strong>，<strong>提供了一种统一的接口</strong>，使得应用程序可以通过网络进行通信。在不同的操作系统中，socket 的实现方式可能不同，但它们都遵循相同的规范和协议，<strong>可以实现跨平台的网络通信</strong>。</li>
<li>在使用C语言编写网络程序时，<code>socket()</code>函数是用来创建一个Socket连接的一个系统调用。</li>
<li>在Python等编程语言中，<code>socket</code>模块提供了一个用于网络通信的接口，通过这个模块可以创建Socket连接，进行数据的发送和接收。</li>
</ul>
</li>
</ol>
<h4 id="套接字与服务端进行通信流程">套接字与服务端进行通信流程</h4>
<p><del>其实我觉得以上都是废话</del>，简单来说，套接字就像是一个通信的桥梁，它允许不同设备上的应用程序进行数据交换。在编程中，我们通过套接字可以实现客户端和服务器之间的通信。</p>
<p>举例来说，当你使用浏览器访问一个网站时，你的电脑（作为客户端）和网站服务器之间就需要通过套接字来传输数据。这个过程大致如下：</p>
<ol>
<li>服务器程序首先在自己的计算机上创建一个套接字，并且告诉网络操作系统它需要监听哪个端口（Port），这个过程可以看作是服务器在告诉外界：“我现在在这个地址（端口）上等待连接。”</li>
<li>你的电脑（客户端）在浏览器中输入网址后，浏览器会向服务器发起一个连接请求，这个请求会通过你的电脑创建一个套接字，并且通过网络找到服务器的套接字。</li>
<li>服务器接收到连接请求后，会创建一个新的套接字与你的电脑的套接字进行连接，从而建立起一个数据传输的通道。</li>
<li>一旦连接建立，数据就可以在你的电脑和服务器之间双向传输。比如，服务器会通过这个连接发送网页的数据给你的电脑，你的电脑接收到数据后，浏览器将其渲染成你看到的网页。</li>
</ol>
<p>在这个例子中，套接字的作用就是使得客户端和服务器能够建立一个可靠的通信通道，从而实现数据的传输。无论是Web浏览、文件传输、即时通讯等网络应用，都离不开套接字技术的支持。</p>
<p>放一张陈年经典老图便于理解具体过程：
<img src="https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/202403291741844.png"
	
	
	
	loading="lazy"
	
	
></p>
<h4 id="c套接字编程相关函数">c++套接字编程相关函数</h4>
<p>cs144的lab是用c++写的，那就让我们来看看相关的类和成员函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//! A wrapper around [TCP sockets](\ref man7::tcp)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">TCPSocket</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Socket</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! \brief Construct from FileDescriptor (used by accept())
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//! \param[in] fd is the FileDescriptor from which to construct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">explicit</span> <span class="n">TCPSocket</span><span class="p">(</span> <span class="n">FileDescriptor</span><span class="o">&amp;&amp;</span> <span class="n">fd</span> <span class="p">)</span> <span class="o">:</span> <span class="n">Socket</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">fd</span> <span class="p">),</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span> <span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//! Default: construct an unbound, unconnected TCP socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TCPSocket</span><span class="p">()</span> <span class="o">:</span> <span class="n">Socket</span><span class="p">(</span> <span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span> <span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Mark a socket as listening for incoming connections
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">listen</span><span class="p">(</span> <span class="kt">int</span> <span class="n">backlog</span> <span class="o">=</span> <span class="mi">16</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">//! Accept a new incoming connection
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">TCPSocket</span> <span class="nf">accept</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>TCPSocket()</code> 是一个公有构造函数，用于创建一个未绑定，未连接的 TCP 套接字。</p>
</li>
<li>
<p><code>listen( int backlog = 16 )</code> 函数用于将套接字标记为监听状态，准备接收进来的连接请求。<code>backlog</code> 参数指定了等待连接队列的大小。</p>
</li>
<li>
<p><code>accept()</code> 函数用于接受一个新的连接请求。当有新的连接请求到来时，它会创建一个新的文件描述符来处理这个连接，然后使用这个文件描述符构造一个 <code>TCPSocket</code> 对象并返回。</p>
</li>
</ul>
<p>创建套接字，监听函数，接受函数都有了，其他函数呢？你可能会奇怪诶为什么<code>TCPSocket</code>类里没有定义？是不是在父类<code>Socket</code>里，在<code>socket.hh</code>头文件一找，嗯找到了连接函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="c1">//! Connect a socket to a specified peer address with [connect(2)](\ref man2::connect)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">connect</span><span class="p">(</span> <span class="k">const</span> <span class="n">Address</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>void connect( const Address&amp; address )</code>：这个函数用于将套接字连接到一个指定的地址。
还是没看到读写函数和关闭函数，这时候你发现<code>Socket</code>也有父类<code>FileDescriptor</code>，继续套娃，你发现原来在<code>file_descriptor.hh</code>里声明了，好家伙真是连环套。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Read into `buffer`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">buffer</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">buffers</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Attempt to write a buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// returns number of bytes written
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span> <span class="nf">write</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">buffer</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="nf">write</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;&amp;</span> <span class="n">buffers</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="nf">write</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">buffers</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Close the underlying file descriptor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="p">{</span> <span class="n">internal_fd_</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>void read( std::string&amp; buffer )</code> 和 <code>void read( std::vector&lt;std::string&gt;&amp; buffers )</code>：这两个函数用于从文件描述符读取数据。第一个函数将读取的数据存入一个字符串，第二个函数将读取的数据存入一个字符串向量。</li>
<li><code>size_t write( std::string_view buffer )</code>、<code>size_t write( const std::vector&lt;std::string_view&gt;&amp; buffers )</code> 和 <code>size_t write( const std::vector&lt;std::string&gt;&amp; buffers )</code>：这三个函数用于向文件描述符写入数据。第一个函数写入一个字符串，第二个函数写入一个字符串向量，第三个函数也写入一个字符串向量。这三个函数都返回写入的字节数。</li>
<li><code>void close()</code>：这个函数用于关闭文件描述符。</li>
</ul>
<h4 id="http报文格式">http报文格式</h4>
<p>这部分不是代码的重点，不过还是简单介绍一下我们这次需要填写的GET请求报文，详情请参考相关专业书籍以及这个<a class="link" href="https://blog.csdn.net/csdnlijingran/article/details/88909370"  target="_blank" rel="noopener"
    >博客</a>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">GET path HTTP/1.1
</span></span><span class="line"><span class="cl">Host: host
</span></span><span class="line"><span class="cl">Connection: close
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意最后还有一个空行。
用cpp实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">string</span> <span class="n">request</span> <span class="p">{</span> <span class="s">&#34;GET &#34;</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">&#34; HTTP/1.1</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;Host: &#34;</span> <span class="o">+</span> <span class="n">host</span> <span class="o">+</span> <span class="s">&#34;</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;Connection: close</span><span class="se">\r\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                         <span class="o">+</span> <span class="s">&#34;</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="实现代码">实现代码</h4>
<p>这下，你终于找齐了图上所有函数，填写好简单请求报文。可以开始编程了！结合上面的流程图和函数，你可以填补get_URL函数模拟网页访问了。实际上代码确实很短，你只需要实现TCP套接字编程的客户端部分。</p>
<ol>
<li>创建socket</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">TCPSocket</span> <span class="n">socket</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>建立连接</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">string</span> <span class="n">service</span> <span class="p">{</span> <span class="s">&#34;http&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">socket</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span> <span class="n">Address</span><span class="p">(</span> <span class="n">host</span><span class="p">,</span> <span class="n">service</span> <span class="p">)</span> <span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>发送请求</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">string</span> <span class="n">request</span> <span class="p">{</span> <span class="s">&#34;GET &#34;</span> <span class="o">+</span> <span class="n">path</span> <span class="o">+</span> <span class="s">&#34; HTTP/1.1</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;Host: &#34;</span> <span class="o">+</span> <span class="n">host</span> <span class="o">+</span> <span class="s">&#34;</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="o">+</span> <span class="s">&#34;Connection: close</span><span class="se">\r\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">                         <span class="o">+</span> <span class="s">&#34;</span><span class="se">\r\n</span><span class="s">&#34;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">socket</span><span class="p">.</span><span class="n">write</span><span class="p">(</span> <span class="n">request</span> <span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>读取响应并输出</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="n">string</span> <span class="n">response</span><span class="p">,</span> <span class="n">buffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span> <span class="n">socket</span><span class="p">.</span><span class="n">read</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">),</span> <span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">response</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>关闭连接</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="n">socket</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>好的以上就是所有代码，这次小实验主要是让我们初步上手套接字编程。接下来让我们来测试一下：</p>
<h4 id="代码测试">代码测试</h4>
<p>在终端执行以下代码进行测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake --build build --target check_webget
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你的代码还没完成/出现错误，那么将会出现类似以下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Test project /home/cs144/minnow/build
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Start 1: compile with bug-checkers
</span></span><span class="line"><span class="cl">1/2 Test <span class="c1">#1: compile with bug-checkers ........</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Passed
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">1.02 sec
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Start 2: t_webget
</span></span><span class="line"><span class="cl">2/2 Test <span class="c1">#2: t_webget .........................***Failed</span>
</span></span><span class="line"><span class="cl">Function called: get_URL<span class="o">(</span>cs144.keithw.org, /nph-hasher/xyzzy<span class="o">)</span>
</span></span><span class="line"><span class="cl">Warning: get_URL<span class="o">()</span> has not been implemented yet.
</span></span><span class="line"><span class="cl">ERROR: webget returned output that did not match the test<span class="err">&#39;</span>s expectations
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果成功，就会出现如下类似结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cs144@vm:~/minnow$ cmake --build build --target check_webget
</span></span><span class="line"><span class="cl">Test project /home/cs144/minnow/build
</span></span><span class="line"><span class="cl">    Start 1: compile with bug-checkers
</span></span><span class="line"><span class="cl">1/2 Test <span class="c1">#1: compile with bug-checkers ........   Passed    0.15 sec</span>
</span></span><span class="line"><span class="cl">    Start 2: t_webget
</span></span><span class="line"><span class="cl">2/2 Test <span class="c1">#2: t_webget .........................   Passed    3.26 sec</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">100% tests passed, <span class="m">0</span> tests failed out of <span class="m">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>   3.41 sec
</span></span><span class="line"><span class="cl">Built target check_webget
</span></span></code></pre></td></tr></table>
</div>
</div><p>这时候你发现他好像有点慢，官方文档里t_webget才0.72s。诶是怎么一回事呢？
在这里挖一个坑待填~~（因为我的c++学的真是太差了）~~</p>
<h2 id="4an-in-memory-reliable-byte-stream">4.An in-memory reliable byte stream</h2>
<p>正当我以为lab0就大功告成，真是易如反掌，易如反掌啊的时候，我惊喜地发现那只是前菜，接下来的字节流编程更是折磨。</p>
<p>（待填）</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/lab/">lab</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">Related content</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">TCP、IP网络编程第三章笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">TCP、IP网络编程第二章笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/tcpip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">TCP、IP网络编程第一章笔记</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E7%BD%91%E7%BB%9C%E5%B1%82/">
        
        

        <div class="article-details">
            <h2 class="article-title">网络层</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/posts/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">
        
        

        <div class="article-details">
            <h2 class="article-title">数据链路层</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="Anonymity-0/Anonymity-0.github.io"
    data-repo-id="R_kgDOKsFzXQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOKsFzXc4Ca3tc"
    data-mapping="url"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="dark_high_contrast"
    data-lang="en"
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('dark_high_contrast');
            } else {
                setGiscusTheme('0');
            }
        }
    })();
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 AGA
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.21.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
