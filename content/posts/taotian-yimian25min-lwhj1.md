---
title: 淘天一面-25min
slug: taotian-yimian25min-lwhj1
url: /post/taotian-yimian25min-lwhj1.html
date: '2025-08-25 20:03:44+08:00'
lastmod: '2025-08-25 21:18:33+08:00'
categories:
  - 秋招面经
toc: true
isCJKLanguage: true
draft: true
---





‍

秋招第一面，实在是有点猝不及防。本来以为阿里系要么会因本科学历卡我简历，要么会先安排笔试让我好好准备一周，没想到一个电话就直接来了。太久没准备八股文，答得相当细碎，赶紧复盘一下。

---

### **面试流程回顾**

####  **- 自我介绍**

（常规环节，简要带过）

####  **- 实习经历深挖**

**1. 介绍一下你负责的工作**  
（此部分根据个人项目阐述）

**2. 面试官追问：分页查询的必要性**  
面试官提出，如果有多台机器，可以同时查询，每台查50个数据，似乎就没必要用游标分页了。

- **我的理解：**  我当时解释说，传统 `LIMIT offset, size` 在 `offset` 很大的时候性能会下降，因为它需要扫描并跳过大量数据。而我们使用的 `WHERE id > x` 这种**游标分页（cursor-based pagination）**  方式，正好可以规避这个问题。
- **我的现场回答：**  我回答的是公司出于降本增效的考虑，没办法提供这么多台机器。（x
- **更优回答（来自AI）：**  “我理解您的意思。其实 `WHERE id > x` 在有索引的情况下效率极高，因为它避免了 `OFFSET` 带来的全扫描问题。如果我们面对的是超大数据量，确实可以考虑多机并行查询，但这通常是在分库分表的架构下进行的。在那种架构里，每个分片内部仍然会使用 `WHERE id > x` 这种游标方式来实现高效分页。所以，**并行查询是架构扩展的手段，而游标分页是查询优化的手段，两者是互补关系，而非替代关系。** ”

**3. XXL-Job 调度原理**  
这里其实稍微看过一点源码，但是没回答好，把“调度中心”说成“注册中心”了。

- **核心原理：**  大致流程是，调度中心向执行器发送指令，执行器接收任务并执行。两者通过 HTTP 通信，执行器完成任务后会回调结果给调度中心。整个系统依赖数据库共享信息，从而实现分布式定时任务的调度。
- **个人 Flag：**  这里挖个坑，我一定要把源码的讲解视频看完！

**4. Kafka/ES 的了解程度**  
面试官：“看到你简历这边用了 Kafka 和 ES，了解到什么程度？”

- **我的回答：**  我回答说，会使用它们对应的 API 和方法。
- **面试官反馈：**  表示这还不够，应该深入挖掘源码。（看不完的源码系列又增加了...）

**5. JMM（Java Memory Model）了解吗？**   
天啊！面试前刚复习了 JVM 就是没看 JMM！

- **知识点补充：**   
  JMM（Java Memory Model）是一种抽象规范，它定义了 Java 虚拟机在多线程环境下如何与主内存（Main Memory）进行交互，以及线程之间的可见性和顺序性。

  - 每个线程都有自己的工作内存（Working Memory），存放主内存中变量的副本。
  - 线程间的通信必须通过主内存完成。
- **JMM 的三大特性：**

  - **原子性 (Atomicity)：**  保证基本数据类型的读写操作是不可中断的。
  - **可见性 (Visibility)：**  当一个线程修改了共享变量的值，能保证其他线程立即看到这个修改。`volatile` 关键字是实现可见性的关键。
  - **有序性 (Ordering)：**  保证程序的执行顺序符合代码的逻辑顺序。编译器和处理器可能会进行指令重排，JMM 通过 `volatile` 和 `synchronized` 等机制来保证特定场景下的“有序性”。

**6. 集合：LinkedHashSet 的底层知道吗？**   
集合的八股文肯定是背过的，但是 `LinkedHashSet` 真的是超出我的知识范围了……

- **核心原理：**  `LinkedHashSet` 的底层其实是 `HashMap` 和一个双向链表的结合。

  - **去重复：**  它利用 `HashMap` 的 `key` 不可重复的特性。当添加元素时，会先计算元素的 `hashCode()` 找到存储位置。如果该位置已有元素，再通过 `equals()` 方法判断是否为同一对象。如果是，则不添加。
  - **保证顺序：**  内部维护了一个双向链表，记录了元素的插入顺序。比如你依次添加 A、B、C，它们在哈希表中的位置可能是分散的，但在链表上它们的顺序是 A → B → C。遍历时，程序会沿着这条链表进行，从而保证输出的顺序就是插入的顺序。

**7. 了解多线程吗？线程池平时有什么设计？**

- **我的项目关联：**  其实我们组里用了 `Future` 来进行 AI 的 Client 调用，但是我没注意看具体实现（这个可以之后去看看）。
- **线程池七大参数：**  开始吟唱！

  1. ​`corePoolSize`: 核心线程数
  2. ​`maximumPoolSize`: 最大线程数
  3. ​`keepAliveTime`: 非核心线程的空闲存活时间
  4. ​`unit`: 存活时间的单位
  5. ​`workQueue`: 任务队列
  6. ​`threadFactory`: 线程工厂
  7. ​`handler`: 拒绝策略
- **追问：**​**​`keepAliveTime`​** **在多 CPU 或多 IO 场景下该如何设计？**   
  一开始没太听懂，后面面试官解释了一下，我还是有点懵。他的意思是，**对于 IO 密集型任务，这个时间可以设置得更短一些**，因为如果一个非核心线程长时间阻塞在等待 IO 上，它就占用了资源却没在工作，尽早回收可以减少资源浪费。（学到了！）
- **追问：拒绝策略有哪些？**   
  继续吟唱！

  1. ​`AbortPolicy`：直接抛异常。（追问是哪个异常，我当时不知道，其实是运行时异常 **​`RejectedExecutionException`​**）
  2. ​`DiscardPolicy`：静默拒绝，直接丢弃任务。
  3. ​`DiscardOldestPolicy`：丢掉任务队列里最老的任务。
  4. ​`CallerRunsPolicy`：把它返回给调用者线程自己去执行。

**8. Java 的异常与错误体系**  
由拒绝策略的异常，引申到了 Java 的异常体系。

- **我的回答：**  我说分为 `Error` (错误) 和 `Exception` (异常)。

  - **Error：**  是系统级别的问题，程序通常无法处理，比如 `OOM` (OutOfMemoryError)。
  - **Exception：**  又区分为 **运行时异常** 和 **非运行时异常** (也叫检查型异常)。

    - **运行时异常** (RuntimeException)：`NullPointerException` 等。**不需要强制** **​`try-catch`​** **或** **​`throws`​**，通常是代码逻辑问题导致的。
    - **非运行时异常** (Checked Exception)：`IOException`、`SQLException` 等。**编译器强制要求处理**，要么 `try-catch`，要么 `throws` 声明，否则编译不通过。

**9. Java 线程安全与锁机制 (宏观角度)**   
面试官：“能不能像刚才讲异常那样，从宏观架构的层面聊聊你了解的锁？”

- **我的回答：**  当时脑子已经晕了，只记得 `synchronized` 和 `Lock`，以及悲观锁和乐观锁这些概念。
- **更体系化的回答参考（来自AI）：**   
  可以从不同层级对 Java 的并发控制机制进行分类，这有助于形成宏观的理解。

|层级|机制|典型代表|特点|适用场景|
| :---------------------| :------------------| :-------------| :-------------------------------------------------------------------------| :---------------------------------------|
|**1. 语言层锁**<br />（JVM 原生支持）|内置互斥锁|​`synchronized`​|简单、安全、自动释放，JVM 会进行锁升级优化（偏向锁、轻量级锁、重量级锁）|一般并发场景，代码块或方法级同步|
|**2. API 层锁**<br />（JUC 包，显式锁）|可重入锁 / 读写锁|​`ReentrantLock`​<br />`ReentrantReadWriteLock`​|灵活：支持公平/非公平、可中断、尝试获取锁、超时等|高并发、需要精细化控制的复杂场景|
|**3. 无锁并发**<br />（原子操作）|CAS 机制|​`AtomicInteger`​<br />`AtomicReference`​|无阻塞、高性能，基于硬件指令实现，但有 ABA 问题|简单变量的并发更新（计数器、状态标志）|
|**4. 避免共享**<br />（无状态设计）|不可变 & 线程本地|​`final`、`String`​<br />`ThreadLocal`​|从根本上避免竞争：数据要么不可变，要么每个线程人手一份|高并发读、避免状态共享的场景|
|**5. 并发容器**<br />（高级封装）|分段锁 / 写时复制|​`ConcurrentHashMap`​<br />`CopyOnWriteArrayList`​|内部已实现高效并发控制，开发者使用时无需关心锁细节|高并发读写集合，如缓存、注册中心等|

---

### **反问环节**

**1. 电话面是筛选简历的面试吗？之后还需要笔试和测评对吗？**

- 面试官答：是的，这是第一轮技术筛选，之后还会有**笔试、测评、两轮技术面 + 一轮 HR 面**。

**2. 对应届生有什么要求呢？**

- 面试官答：

  1. **基础要扎实**（对，骂的就是本人）。
  2. 如果有自己的**技术博客或者公众号会很加分**（本人有，但是毫无技术含量 x）。
  3. 实习中可能碰到的业务比较基础，但要**学会深入思考为什么用这个技术，深入理解它的原理**。（决定了！要开一个“看不完的源码”系列，谁来替我做需求啊！）

---

### **面试感想**

其实没对阿里抱太多希望（总担心学历会被卡），这次面试答得也是一坨，秒挂也在情理之中。但面试官懂得很多，人也很好，让我学到了新的场景题解法，也算是一次非常宝贵的查缺补漏。

继续加油！

![image](https://raw.githubusercontent.com/Anonymity-0/Picgo/main/img/20250825211827.png)
