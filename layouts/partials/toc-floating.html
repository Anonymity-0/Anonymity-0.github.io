<!-- 阅读进度条 - 放在页面顶部 -->
<div class="reading-progress-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 4px; background: rgba(0, 0, 0, 0.1); z-index: 9998;">
  <div id="reading-progress" class="reading-progress-bar" style="height: 100%; background: linear-gradient(90deg, #3b82f6, #1d4ed8); width: 0%; transition: width 0.1s ease-out;"></div>
</div>

<!-- 悬浮目录导航 - 透明条状设计 -->
<div id="floating-toc" class="floating-toc" style="position: fixed; top: 50%; right: 30px; transform: translateY(-50%); z-index: 9999; opacity: 1; visibility: visible;">

  <!-- 目录条状列表 -->
  <div id="floating-toc-content" class="floating-toc-content" style="display: flex; flex-direction: column; gap: 8px; align-items: flex-end;">
    <ul id="floating-toc-list" class="floating-toc-list" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
      <!-- 目录项将通过JavaScript动态生成为透明条状 -->
    </ul>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const floatingToc = document.getElementById('floating-toc');
  const tocContent = document.getElementById('floating-toc-content');
  const tocList = document.getElementById('floating-toc-list');
  const progressBar = document.getElementById('reading-progress');

  if (!floatingToc) return;
  
  // 获取文章内容区域
  const articleContent = document.querySelector('.content.article-content') ||
                         document.querySelector('.article-content') ||
                         document.querySelector('.content') ||
                         document.querySelector('main') ||
                         document.querySelector('article');

  if (!articleContent) {
    floatingToc.style.display = 'none';
    return;
  }

  // 获取所有标题，但排除文章标题（通常是第一个h1）
  const allHeadings = articleContent.querySelectorAll('h1, h2, h3, h4, h5, h6');
  const headings = Array.from(allHeadings).filter((heading, index) => {
    // 如果是第一个h1且内容与页面标题相同，则跳过
    if (index === 0 && heading.tagName === 'H1') {
      const pageTitle = document.querySelector('h1.hx\\:text-center, h1.hx\\:text-4xl');
      if (pageTitle && heading.textContent.trim() === pageTitle.textContent.trim()) {
        return false;
      }
    }
    return true;
  });

  if (!headings || headings.length === 0) {
    floatingToc.style.display = 'none';
    return;
  }

  // 确保TOC可见
  floatingToc.style.display = 'block';
  floatingToc.style.opacity = '1';
  floatingToc.style.visibility = 'visible';
  
  // 生成透明条状目录
  function generateToc() {
    if (!tocList || !headings) return;

    // 清理之前的文字覆盖层
    const oldOverlays = document.querySelectorAll('.toc-text-overlay');
    oldOverlays.forEach(overlay => overlay.remove());

    tocList.innerHTML = '';

    headings.forEach((heading, index) => {
      if (!heading) return;

      // 为标题添加ID（如果没有的话）
      if (!heading.id) {
        heading.id = `heading-${index}`;
      }

      const li = document.createElement('li');
      const bar = document.createElement('div');

      // 根据标题级别设置条的长度和样式
      const level = parseInt(heading.tagName.charAt(1));
      const baseWidth = 80;
      const width = baseWidth - (level - 1) * 15; // h1最长，h6最短

      bar.className = `toc-bar toc-bar-${level}`;
      bar.style.cssText = `
        width: ${width}px;
        height: 4px;
        background: rgba(59, 130, 246, 0.3);
        border-radius: 2px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 2px 0;
        position: relative;
      `;

      // 创建点击时显示的标题文字（覆盖在条上）
      const textOverlay = document.createElement('div');
      const headingText = heading.textContent || `标题 ${index + 1}`;

      // 计算标题层级编号（从H2开始计算，忽略H1）
      let levelNumber = '';
      const headingLevel = parseInt(heading.tagName.charAt(1));

      // 只处理H2及以下级别的标题
      if (headingLevel >= 2) {
        // 计算当前标题的编号
        let h2Count = 0, h3Count = 0, h4Count = 0, h5Count = 0, h6Count = 0;

        for (let i = 0; i <= index; i++) {
          const currentLevel = parseInt(headings[i].tagName.charAt(1));
          if (currentLevel === 2) {
            h2Count++;
            h3Count = h4Count = h5Count = h6Count = 0;
          } else if (currentLevel === 3) {
            h3Count++;
            h4Count = h5Count = h6Count = 0;
          } else if (currentLevel === 4) {
            h4Count++;
            h5Count = h6Count = 0;
          } else if (currentLevel === 5) {
            h5Count++;
            h6Count = 0;
          } else if (currentLevel === 6) {
            h6Count++;
          }
        }

        // 生成层级编号（从2级开始，作为顶级）
        if (headingLevel === 2) {
          levelNumber = `${h2Count}. `;
        } else if (headingLevel === 3) {
          levelNumber = `${h2Count}.${h3Count} `;
        } else if (headingLevel === 4) {
          levelNumber = `${h2Count}.${h3Count}.${h4Count} `;
        } else if (headingLevel === 5) {
          levelNumber = `${h2Count}.${h3Count}.${h4Count}.${h5Count} `;
        } else if (headingLevel === 6) {
          levelNumber = `${h2Count}.${h3Count}.${h4Count}.${h5Count}.${h6Count} `;
        }
      }

      const displayText = levelNumber + headingText;
      textOverlay.textContent = displayText;
      textOverlay.className = 'toc-text-overlay';

      // 根据文字长度动态调整条的宽度和高度
      const textLength = displayText.length;
      const dynamicWidth = Math.max(width, Math.min(textLength * 7 + 30, 250)); // 增加宽度以适应层级编号
      const dynamicHeight = textLength > 20 ? 24 : 18; // 调整高度

      textOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: ${dynamicWidth}px;
        height: ${dynamicHeight}px;
        background: rgba(59, 130, 246, 0.95);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: ${textLength > 20 ? '0.6rem' : '0.7rem'};
        font-weight: 500;
        border-radius: 2px;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1;
        pointer-events: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 0 6px;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
      `;

      // 同时调整原条的样式以适应动态尺寸
      bar.style.width = `${width}px`;
      bar.style.height = '4px';
      bar.dataset.dynamicWidth = dynamicWidth;
      bar.dataset.dynamicHeight = dynamicHeight;

      // 将文字覆盖层添加到条上
      bar.appendChild(textOverlay);
      li.appendChild(bar);
      tocList.appendChild(li);

      // 点击效果 - 显示文字覆盖层并动态调整尺寸
      bar.addEventListener('click', function(e) {
        e.preventDefault();

        // 动态调整条的尺寸以适应文字
        const dynamicWidth = this.dataset.dynamicWidth;
        const dynamicHeight = this.dataset.dynamicHeight;

        this.style.width = `${dynamicWidth}px`;
        this.style.height = `${dynamicHeight}px`;
        this.style.transition = 'all 0.3s ease';

        // 显示文字覆盖层
        textOverlay.style.opacity = '1';
        textOverlay.style.visibility = 'visible';

        // 1.5秒后恢复原状
        setTimeout(() => {
          textOverlay.style.opacity = '0';
          textOverlay.style.visibility = 'hidden';
          this.style.width = `${width}px`;
          this.style.height = '4px';
        }, 1500);

        // 跳转到对应标题
        heading.scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      });

      // 悬停效果
      bar.addEventListener('mouseenter', function(e) {
        this.style.background = `rgba(59, 130, 246, 0.8)`;
        this.style.transform = 'translateX(-5px) scale(1.1)';
        this.style.boxShadow = '0 2px 8px rgba(59, 130, 246, 0.4)';
      });

      bar.addEventListener('mouseleave', function() {
        this.style.background = `rgba(59, 130, 246, 0.3)`;
        this.style.transform = 'translateX(0) scale(1)';
        this.style.boxShadow = 'none';
      });
    });
  }
  
  // 更新当前激活的目录条
  function updateActiveToc() {
    if (!headings || !tocList) return;

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const windowHeight = window.innerHeight;

    let activeHeading = null;
    let minDistance = Infinity;

    headings.forEach(heading => {
      if (!heading) return;

      const rect = heading.getBoundingClientRect();
      const distance = Math.abs(rect.top);

      if (rect.top <= windowHeight * 0.3 && distance < minDistance) {
        minDistance = distance;
        activeHeading = heading;
      }
    });

    // 更新所有目录条的激活状态
    const tocBars = tocList.querySelectorAll('.toc-bar');
    tocBars.forEach((bar, index) => {
      if (activeHeading && headings[index] === activeHeading) {
        bar.style.background = 'rgba(59, 130, 246, 1)';
        bar.style.boxShadow = '0 0 12px rgba(59, 130, 246, 0.6)';
        bar.style.height = '6px';
      } else {
        bar.style.background = 'rgba(59, 130, 246, 0.3)';
        bar.style.boxShadow = 'none';
        bar.style.height = '4px';
      }
    });
  }
  
  // 更新阅读进度
  function updateReadingProgress() {
    if (!progressBar) return;

    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const windowHeight = window.innerHeight;
    const docHeight = document.documentElement.scrollHeight;
    const totalScrollable = docHeight - windowHeight;

    if (totalScrollable <= 0) {
      progressBar.style.width = '100%';
      return;
    }

    const progress = (scrollTop / totalScrollable) * 100;
    progressBar.style.width = Math.min(100, Math.max(0, progress)) + '%';
  }
  
  // 透明条状目录不需要最小化功能
  
  // 滚动事件监听
  let ticking = false;
  function onScroll() {
    if (!ticking) {
      requestAnimationFrame(function() {
        updateActiveToc();
        updateReadingProgress();
        ticking = false;
      });
      ticking = true;
    }
  }
  
  // 显示/隐藏悬浮目录
  function toggleTocVisibility() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    // 暂时总是显示，用于调试
    floatingToc.classList.add('visible');

    // if (scrollTop > 100) {  // 降低阈值，更容易触发
    //   floatingToc.classList.add('visible');
    // } else {
    //   floatingToc.classList.remove('visible');
    // }
  }
  
  // 初始化
  generateToc();

  // 立即检查是否应该显示TOC
  toggleTocVisibility();

  // 绑定事件
  window.addEventListener('scroll', function() {
    onScroll();
    toggleTocVisibility();
  });
  
  // 窗口大小改变时重新计算
  window.addEventListener('resize', function() {
    updateActiveToc();
    updateReadingProgress();
  });
  
  // 透明条状目录的悬停效果已在生成时添加
});
</script>
